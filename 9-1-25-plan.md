# Implementation Plan: Test Execution Tracing Feature

## Overview
Add functionality to TestIntelligence library that allows users to specify a test method and discover all production code that it executes (directly or indirectly). This is the **forward direction** of coverage analysis - instead of "what tests exercise this method?", we answer "what code does this test exercise?".

## Current State Analysis (UPDATED 9/1/25)
The library currently has:
- ✅ **RoslynAnalyzer**: Builds call graphs and analyzes method dependencies with forward traversal capabilities  
- ✅ **MethodCallGraph**: Tracks method calls and can find dependencies via `GetMethodCalls()` and transitive calls
- ✅ **Test Discovery**: NUnitTestDiscovery for finding test methods with comprehensive attribute support
- ✅ **TestCoverageInfo Model**: Already implemented for representing test-to-method relationships
- ✅ **TestCoverageAnalyzer**: **COMPLETED** - Implements reverse lookup (method-to-test)
- ✅ **CLI Integration**: **COMPLETED** - `find-tests` command works
- ✅ **API Integration**: **COMPLETED** - TestCoverageController exists

**Missing**: Forward execution tracing from test method to all production code it exercises (opposite direction).

## Implementation Plan (REVISED 9/1/25)

**STATUS**: Method-to-Test reverse lookup is **COMPLETE**. This plan now focuses on the **forward direction**: Test-to-Method execution tracing.

### Phase 1: Test Execution Tracer Service
**Files to Create:**
- `src/TestIntelligence.Core/Services/TestExecutionTracer.cs`
- `src/TestIntelligence.Core/Interfaces/ITestExecutionTracer.cs` 
- `src/TestIntelligence.Core/Models/ExecutionTrace.cs`

**Functionality:** (leverages existing `MethodCallGraph.GetMethodCalls()`)
```csharp
public interface ITestExecutionTracer
{
    Task<ExecutionTrace> TraceTestExecutionAsync(
        string testMethodId, 
        string solutionPath, 
        CancellationToken cancellationToken = default);
        
    Task<IReadOnlyList<ExecutionTrace>> TraceMultipleTestsAsync(
        IEnumerable<string> testMethodIds, 
        string solutionPath, 
        CancellationToken cancellationToken = default);
        
    Task<ExecutionCoverageReport> GenerateCoverageReportAsync(
        string solutionPath,
        CancellationToken cancellationToken = default);
}
```

### Phase 2: Leverage Existing Call Graph (minimal changes needed)
**Files to Use:** (NO NEW FILES - reuse existing)
- `src/TestIntelligence.ImpactAnalyzer/Analysis/RoslynAnalyzerV2.cs` (already exists)
- `src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs` (already exists)

**Implementation:** Reverse the BFS traversal logic in TestCoverageAnalyzer to go forward from test→production instead of production←test.

### Phase 3: Production Code Classification (reuse existing)
**Files to Use:** (NO NEW FILES - reuse existing)  
- `src/TestIntelligence.ImpactAnalyzer/Classification/TestMethodClassifier.cs` (already exists)

**Enhancement:** Add production code filtering logic to existing classifier.

### Phase 4: CLI Integration 
**Files to Modify:**
- `src/TestIntelligence.CLI/Program.cs` (add new command)

**New Command:**
```bash
testintel trace-execution --test "MyNamespace.MyTestClass.MyTestMethod" --solution "MySolution.sln"
testintel trace-execution --test-pattern "*IntegrationTest*" --solution "MySolution.sln" --max-depth 10
```

### Phase 5: API Integration
**Files to Create:**
- `src/TestIntelligence.API/Controllers/ExecutionTraceController.cs`

**New Endpoints:**
- `GET /api/execution-trace/test/{testMethodId}`
- `POST /api/execution-trace/bulk` (for multiple tests)
- `GET /api/execution-trace/coverage-report/{solutionId}`

## Technical Implementation Details

### Core Algorithm
1. **Identify Test Method**: Locate test method in call graph using existing discovery mechanisms
2. **Forward Traversal**: From test method, traverse all called methods recursively
3. **Production Code Filtering**: Filter results to show only relevant production code
4. **Path Tracking**: Maintain call paths showing how test reaches each production method
5. **Metrics Generation**: Calculate coverage metrics and execution complexity

### Data Structures
```csharp
public class ExecutionTrace
{
    public string TestMethodId { get; set; }
    public string TestMethodName { get; set; }
    public string TestClassName { get; set; }
    public List<ExecutedMethod> ExecutedMethods { get; set; }
    public int TotalMethodsCalled { get; set; }
    public int ProductionMethodsCalled { get; set; }
    public TimeSpan EstimatedExecutionComplexity { get; set; }
    public DateTime TraceTimestamp { get; set; }
}

public class ExecutedMethod
{
    public string MethodId { get; set; }
    public string MethodName { get; set; }
    public string ContainingType { get; set; }
    public string FilePath { get; set; }
    public int LineNumber { get; set; }
    public string[] CallPath { get; set; } // Path from test to this method
    public int CallDepth { get; set; }
    public bool IsProductionCode { get; set; }
    public MethodCategory Category { get; set; } // Business, Infrastructure, Framework
}

public class ExecutionCoverageReport
{
    public Dictionary<string, ExecutionTrace> TestToExecutionMap { get; set; }
    public List<string> UncoveredMethods { get; set; } // Production methods not hit by any test
    public CoverageStatistics Statistics { get; set; }
    public DateTime GeneratedTimestamp { get; set; }
}

public enum MethodCategory
{
    Unknown,
    BusinessLogic,
    DataAccess,
    Infrastructure,
    Framework,
    ThirdParty,
    TestUtility
}
```

## Validation & Testing

### Test Cases to Create
1. **Simple Test Tracing**: Test that calls one production method directly
2. **Complex Call Chain**: Test that exercises deep call hierarchies
3. **Multiple Paths**: Test that calls same production method via different paths
4. **Async Method Calls**: Test that uses async/await patterns
5. **Interface Calls**: Test that calls through interfaces/abstractions
6. **Generic Method Calls**: Test that calls generic methods
7. **Recursive Methods**: Handling of recursive method calls (with depth limits)
8. **Framework Filtering**: Ensure framework methods are properly filtered

### Integration Points
- Verify compatibility with existing call graph analysis
- Ensure test discovery works with execution tracing
- Test performance with large test suites (100+ test methods)
- Validate filtering accuracy (production vs test/framework code)

## Success Criteria (UPDATED 9/1/25)
1. ⏳ Given a test method identifier, return all production code it executes
2. ⏳ Support both direct and transitive (indirect) method calls  
3. ⏳ Provide execution paths showing how test reaches each production method
4. ⏳ Filter out framework and test utility methods to focus on business logic
5. ⏳ Performance: Process 100+ test methods in <60 seconds
6. ⏳ Integration: Works with existing CLI and API interfaces
7. ⏳ Coverage Reporting: Generate comprehensive execution coverage reports

**NOTE**: The reverse direction (method-to-test lookup) is ✅ **COMPLETE** via TestCoverageAnalyzer and `find-tests` CLI command.

## Use Cases Enabled

### Development Scenarios
- **Test Impact Assessment**: "What production code does this test actually verify?"
- **Refactoring Safety**: "If I change this test, what production code might be affected?"
- **Test Redundancy Analysis**: "Do these tests exercise the same production code?"
- **Coverage Gap Analysis**: "What production code is not exercised by any tests?"

### Quality Assurance
- **Test Effectiveness Measurement**: Quantify how much production code each test exercises
- **Test Suite Optimization**: Identify tests with overlapping execution paths
- **Code Coverage Validation**: Verify that critical business logic is adequately tested

### Code Review Support
- **Test Review**: Understand what a test actually validates by seeing execution traces
- **Production Code Review**: See which tests would verify changes to production methods

## Future Enhancements (Out of Scope)
- Visual execution flow diagrams
- Integration with code coverage tools
- Real-time execution tracing during test runs
- Performance profiling integration
- Test execution time estimation based on call complexity

## Estimated Timeline (REVISED 9/1/25)
**MAJOR REDUCTION** since reverse lookup is complete:

- **Phase 1**: 1-2 days (Core tracing implementation - leverages existing call graph)
- **Phase 2**: 0.5 days (Modify existing BFS algorithm direction)  
- **Phase 3**: 0.5 days (Add production code filtering to existing classifier)
- **Phase 4**: 1 day (CLI integration - similar to existing `find-tests`)
- **Phase 5**: 1 day (API integration - similar to existing TestCoverageController)  
- **Testing**: 1-2 days (Tests for new functionality)

**Total**: 4-6 days (reduced from 8-13 days due to existing infrastructure)

## Technical Considerations

### Performance Optimizations
- **Call Depth Limits**: Default max depth of 20 to prevent infinite traversals
- **Method Caching**: Cache method metadata to avoid repeated analysis
- **Selective Filtering**: Apply filters during traversal, not post-processing
- **Incremental Analysis**: Only recompute traces for changed methods

### Accuracy Considerations
- **Interface Resolution**: Properly resolve interface calls to concrete implementations
- **Dynamic Dispatch**: Handle virtual method calls and polymorphism
- **Reflection Calls**: Detect and trace reflection-based method invocations where possible
- **Async Patterns**: Correctly trace through Task/async method boundaries

## What's Already Working (9/1/25)

### Existing Reverse Lookup (`find-tests` command):
```bash
# Find tests that exercise a specific method (WORKING)
dotnet src/TestIntelligence.CLI/bin/Debug/net8.0/TestIntelligence.CLI.dll find-tests \
  --method "MyNamespace.MyClass.MyMethod" \
  --solution "MySolution.sln" \
  --verbose
```

### Existing API Endpoints (WORKING):
- `POST /api/testcoverage/methods` - Find tests for multiple methods
- `GET /api/testcoverage/statistics/{solutionId}` - Coverage statistics

---

This **updated plan** focuses on implementing the **forward direction** (test→production code) to complement the existing **reverse direction** (production code→tests) functionality.