# Implementation Plan: Test Execution Tracing Feature

## Overview
Add functionality to TestIntelligence library that allows users to specify a test method and discover all production code that it executes (directly or indirectly). This is the inverse of the method-to-test lookup - instead of "what tests exercise this method?", we answer "what code does this test exercise?".

## Current State Analysis
The library currently has:
- ✅ **RoslynAnalyzer**: Builds call graphs and analyzes method dependencies with forward traversal capabilities
- ✅ **MethodCallGraph**: Tracks method calls and can find dependencies via `GetMethodCalls()` and transitive calls
- ✅ **Test Discovery**: NUnitTestDiscovery for finding test methods with comprehensive attribute support
- ✅ **TestCoverageInfo Model**: Already implemented for representing test-to-method relationships

**Missing**: Forward execution tracing from test method to all production code it exercises.

## Implementation Plan

### Phase 1: Test Execution Tracer Service
**Files to Create:**
- `src/TestIntelligence.Core/Services/TestExecutionTracer.cs`
- `src/TestIntelligence.Core/Interfaces/ITestExecutionTracer.cs`
- `src/TestIntelligence.Core/Models/ExecutionTrace.cs`

**Functionality:**
```csharp
public interface ITestExecutionTracer
{
    Task<ExecutionTrace> TraceTestExecutionAsync(
        string testMethodId, 
        string solutionPath, 
        CancellationToken cancellationToken = default);
        
    Task<IReadOnlyList<ExecutionTrace>> TraceMultipleTestsAsync(
        IEnumerable<string> testMethodIds, 
        string solutionPath, 
        CancellationToken cancellationToken = default);
        
    Task<ExecutionCoverageReport> GenerateCoverageReportAsync(
        string solutionPath,
        CancellationToken cancellationToken = default);
}
```

### Phase 2: Enhanced Call Graph Integration
**Files to Modify:**
- `src/TestIntelligence.ImpactAnalyzer/Analysis/RoslynAnalyzer.cs`

**Enhancements:**
1. Add method to perform forward traversal from test methods through call graph
2. Implement depth-limited traversal to avoid infinite recursion
3. Add filtering to exclude framework/library methods and focus on production code
4. Support async method call patterns and delegates

### Phase 3: Production Code Classification
**Files to Create:**
- `src/TestIntelligence.Core/Classification/ProductionCodeClassifier.cs`

**Functionality:**
- Distinguish between production code and test code
- Filter out framework calls (System.*, Microsoft.*, etc.)
- Identify meaningful business logic vs infrastructure code
- Handle third-party libraries appropriately

### Phase 4: CLI Integration
**Files to Modify:**
- `src/TestIntelligence.CLI/Program.cs`
- `src/TestIntelligence.CLI/Services/AnalysisService.cs`

**New Command:**
```bash
testintel trace-execution --test "MyNamespace.MyTestClass.MyTestMethod" --solution "MySolution.sln"
testintel trace-execution --test-pattern "*IntegrationTest*" --solution "MySolution.sln" --max-depth 10
```

### Phase 5: API Integration
**Files to Create:**
- `src/TestIntelligence.API/Controllers/ExecutionTraceController.cs`

**New Endpoints:**
- `GET /api/execution-trace/test/{testMethodId}`
- `POST /api/execution-trace/bulk` (for multiple tests)
- `GET /api/execution-trace/coverage-report/{solutionId}`

### Phase 6: Performance Optimizations
**Features:**
1. **Memoization**: Cache execution traces to avoid recomputing identical paths
2. **Pruning**: Stop traversal at certain depth levels or when hitting framework boundaries
3. **Parallel Processing**: Trace multiple test methods concurrently
4. **Smart Filtering**: Exclude commonly uninteresting methods (getters, setters, constructors)

## Technical Implementation Details

### Core Algorithm
1. **Identify Test Method**: Locate test method in call graph using existing discovery mechanisms
2. **Forward Traversal**: From test method, traverse all called methods recursively
3. **Production Code Filtering**: Filter results to show only relevant production code
4. **Path Tracking**: Maintain call paths showing how test reaches each production method
5. **Metrics Generation**: Calculate coverage metrics and execution complexity

### Data Structures
```csharp
public class ExecutionTrace
{
    public string TestMethodId { get; set; }
    public string TestMethodName { get; set; }
    public string TestClassName { get; set; }
    public List<ExecutedMethod> ExecutedMethods { get; set; }
    public int TotalMethodsCalled { get; set; }
    public int ProductionMethodsCalled { get; set; }
    public TimeSpan EstimatedExecutionComplexity { get; set; }
    public DateTime TraceTimestamp { get; set; }
}

public class ExecutedMethod
{
    public string MethodId { get; set; }
    public string MethodName { get; set; }
    public string ContainingType { get; set; }
    public string FilePath { get; set; }
    public int LineNumber { get; set; }
    public string[] CallPath { get; set; } // Path from test to this method
    public int CallDepth { get; set; }
    public bool IsProductionCode { get; set; }
    public MethodCategory Category { get; set; } // Business, Infrastructure, Framework
}

public class ExecutionCoverageReport
{
    public Dictionary<string, ExecutionTrace> TestToExecutionMap { get; set; }
    public List<string> UncoveredMethods { get; set; } // Production methods not hit by any test
    public CoverageStatistics Statistics { get; set; }
    public DateTime GeneratedTimestamp { get; set; }
}

public enum MethodCategory
{
    Unknown,
    BusinessLogic,
    DataAccess,
    Infrastructure,
    Framework,
    ThirdParty,
    TestUtility
}
```

## Validation & Testing

### Test Cases to Create
1. **Simple Test Tracing**: Test that calls one production method directly
2. **Complex Call Chain**: Test that exercises deep call hierarchies
3. **Multiple Paths**: Test that calls same production method via different paths
4. **Async Method Calls**: Test that uses async/await patterns
5. **Interface Calls**: Test that calls through interfaces/abstractions
6. **Generic Method Calls**: Test that calls generic methods
7. **Recursive Methods**: Handling of recursive method calls (with depth limits)
8. **Framework Filtering**: Ensure framework methods are properly filtered

### Integration Points
- Verify compatibility with existing call graph analysis
- Ensure test discovery works with execution tracing
- Test performance with large test suites (100+ test methods)
- Validate filtering accuracy (production vs test/framework code)

## Success Criteria
1. ✅ Given a test method identifier, return all production code it executes
2. ✅ Support both direct and transitive (indirect) method calls
3. ✅ Provide execution paths showing how test reaches each production method
4. ✅ Filter out framework and test utility methods to focus on business logic
5. ✅ Performance: Process 100+ test methods in <60 seconds
6. ✅ Integration: Works with existing CLI and API interfaces
7. ✅ Coverage Reporting: Generate comprehensive execution coverage reports

## Use Cases Enabled

### Development Scenarios
- **Test Impact Assessment**: "What production code does this test actually verify?"
- **Refactoring Safety**: "If I change this test, what production code might be affected?"
- **Test Redundancy Analysis**: "Do these tests exercise the same production code?"
- **Coverage Gap Analysis**: "What production code is not exercised by any tests?"

### Quality Assurance
- **Test Effectiveness Measurement**: Quantify how much production code each test exercises
- **Test Suite Optimization**: Identify tests with overlapping execution paths
- **Code Coverage Validation**: Verify that critical business logic is adequately tested

### Code Review Support
- **Test Review**: Understand what a test actually validates by seeing execution traces
- **Production Code Review**: See which tests would verify changes to production methods

## Future Enhancements (Out of Scope)
- Visual execution flow diagrams
- Integration with code coverage tools
- Real-time execution tracing during test runs
- Performance profiling integration
- Test execution time estimation based on call complexity

## Estimated Timeline
- **Phase 1-2**: 2-3 days (Core tracing implementation)
- **Phase 3**: 1-2 days (Production code classification)
- **Phase 4-5**: 1-2 days (CLI/API integration)  
- **Phase 6**: 2-3 days (Performance optimization)
- **Testing**: 2-3 days (Comprehensive test coverage)

**Total**: 8-13 days for complete implementation

## Technical Considerations

### Performance Optimizations
- **Call Depth Limits**: Default max depth of 20 to prevent infinite traversals
- **Method Caching**: Cache method metadata to avoid repeated analysis
- **Selective Filtering**: Apply filters during traversal, not post-processing
- **Incremental Analysis**: Only recompute traces for changed methods

### Accuracy Considerations
- **Interface Resolution**: Properly resolve interface calls to concrete implementations
- **Dynamic Dispatch**: Handle virtual method calls and polymorphism
- **Reflection Calls**: Detect and trace reflection-based method invocations where possible
- **Async Patterns**: Correctly trace through Task/async method boundaries

This plan provides a comprehensive approach to implementing test execution tracing, enabling developers to understand exactly what production code their tests exercise and identify potential gaps in test coverage.