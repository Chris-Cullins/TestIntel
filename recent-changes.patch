diff --git a/focused-changes.patch b/focused-changes.patch
index 278a818..b141b98 100644
--- a/focused-changes.patch
+++ b/focused-changes.patch
@@ -1,22 +1,97 @@
-diff --git a/src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs b/src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
-index 410eadf..dc9ed54 100644
---- a/src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
-+++ b/src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
-@@ -247,4 +247,4 @@ namespace TestIntelligence.Core.Discovery
-             DiscoveryError?.Invoke(this, new TestDiscoveryErrorEventArgs(assemblyPath, exception));
+diff --git a/src/TestIntelligence.ImpactAnalyzer/Analysis/GitDiffParser.cs b/src/TestIntelligence.ImpactAnalyzer/Analysis/GitDiffParser.cs
+index 63f045f..82772e8 100644
+--- a/src/TestIntelligence.ImpactAnalyzer/Analysis/GitDiffParser.cs
++++ b/src/TestIntelligence.ImpactAnalyzer/Analysis/GitDiffParser.cs
+@@ -32,6 +32,15 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
+         private static readonly Regex MethodSignaturePattern = new Regex(
+             @"(?:(?:public|private|protected|internal)\s+)?(?:(?:static|virtual|override|async|abstract)\s+)*(?:Task<?[\w<>,\s]*>?|void|bool|int|string|[\w<>\[\],]+)\s+(\w+)(?:<[^>]*>)?\s*\([^)]*\)(?:\s+where\s+[^{]*)?\s*",
+             RegexOptions.Multiline | RegexOptions.IgnoreCase);
++        
++        // Additional patterns for method-related changes
++        private static readonly Regex SimplerMethodPattern = new Regex(
++            @"(\w+)\s*\([^)]*\)\s*(?:;|{|\s*$)",
++            RegexOptions.Multiline);
++            
++        private static readonly Regex VariableAssignmentPattern = new Regex(
++            @"var\s+(\w+)\s*=|(\w+)\s+(\w+)\s*=",
++            RegexOptions.Multiline);
+ 
+         public GitDiffParser(ILogger<GitDiffParser> logger, IRoslynAnalyzer roslynAnalyzer)
+         {
+@@ -125,6 +134,13 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
+             }
+ 
+             _logger.LogInformation("Parsed {ChangeCount} code changes from diff", changes.Count);
++            foreach (var change in changes)
++            {
++                _logger.LogDebug("Code change: {FilePath} ({ChangeType}) - {MethodCount} methods: [{Methods}]", 
++                    change.FilePath, change.ChangeType, change.ChangedMethods.Count, 
++                    string.Join(", ", change.ChangedMethods));
++            }
++            
+             return Task.FromResult(new CodeChangeSet(changes));
          }
-     }
--}
-\ No newline at end of file
-+}// Test change for coverage analysis
-diff --git a/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs b/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs
-index d7f075c..7b686cd 100644
---- a/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs
-+++ b/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs
-@@ -723,4 +723,4 @@ namespace TestIntelligence.ImpactAnalyzer.Services
-             return false;
-         }
-     }
--}
-\ No newline at end of file
-+}// Test change for coverage analysis
+ 
+@@ -190,9 +206,14 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
+                 var changedMethods = ExtractMethodNames(changedLines);
+                 var changedTypes = ExtractTypeNames(changedLines);
+ 
+-                if (!changedMethods.Any() && !changedTypes.Any())
++                // If we have any changed lines in a C# file, create a change even if we can't detect specific methods/types
++                // This ensures we don't lose changes due to parsing limitations
++                if (!changedLines.Any())
+                     return null;
+ 
++                _logger.LogDebug("Creating code change for {FilePath}: {MethodCount} methods, {TypeCount} types, {LineCount} changed lines", 
++                    filePath, changedMethods.Count, changedTypes.Count, changedLines.Count);
++
+                 return new CodeChange(filePath, changeType, changedMethods.ToList(), changedTypes.ToList());
+             }
+             catch (Exception ex)
+@@ -216,6 +237,7 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
+ 
+             foreach (var line in lines)
+             {
++                // Try primary method pattern
+                 var matches = MethodSignaturePattern.Matches(line);
+                 foreach (Match match in matches)
+                 {
+@@ -225,9 +247,38 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
+                         if (!string.IsNullOrEmpty(methodName) && IsValidMethodName(methodName))
+                         {
+                             methodNames.Add(methodName);
++                            _logger.LogDebug("Found method via primary pattern: {MethodName}", methodName);
++                        }
++                    }
++                }
++
++                // Try simpler method pattern for method calls and definitions
++                var simpleMatches = SimplerMethodPattern.Matches(line);
++                foreach (Match match in simpleMatches)
++                {
++                    if (match.Groups.Count > 1)
++                    {
++                        var methodName = match.Groups[1].Value.Trim();
++                        if (!string.IsNullOrEmpty(methodName) && IsValidMethodName(methodName))
++                        {
++                            methodNames.Add(methodName);
++                            _logger.LogDebug("Found method via simple pattern: {MethodName}", methodName);
+                         }
+                     }
+                 }
++
++                // Extract variable names from assignments (related to changed logic)
++                var varMatches = VariableAssignmentPattern.Matches(line);
++                foreach (Match match in varMatches)
++                {
++                    var varName = match.Groups.Count > 2 && !string.IsNullOrEmpty(match.Groups[2].Value) ? 
++                        match.Groups[2].Value.Trim() : match.Groups[1].Value.Trim();
++                    if (!string.IsNullOrEmpty(varName) && IsValidMethodName(varName))
++                    {
++                        methodNames.Add($"Variable_{varName}"); // Prefix to distinguish variables
++                        _logger.LogDebug("Found variable assignment: {VarName}", varName);
++                    }
++                }
+             }
+ 
+             return methodNames;
diff --git a/recent-changes.patch b/recent-changes.patch
index 6d0dbc7..1150eec 100644
--- a/recent-changes.patch
+++ b/recent-changes.patch
@@ -1,2102 +0,0 @@
-diff --git a/.claude/commands/debug-find-tests.md b/.claude/commands/debug-find-tests.md
-new file mode 100644
-index 0000000..10c1e5e
---- /dev/null
-+++ b/.claude/commands/debug-find-tests.md
-@@ -0,0 +1,454 @@
-+# Debug Find-Tests Command
-+
-+Debug version of find-tests testing with enhanced tracing to troubleshoot issues we've been experiencing with the find-tests command accuracy.
-+
-+## Known Issues to Investigate
-+- Potential false positives in test detection
-+- Missing tests that should be found
-+- Incorrect confidence scoring
-+- Call graph traversal problems
-+- Assembly loading or reflection issues
-+
-+## Debug Testing Protocol
-+
-+### Step 1: Select Target Method with Debug Context
-+1. **Choose a well-known method** with clear test relationships:
-+   ```bash
-+   # Example: Pick a method we know is tested
-+   echo "üîç Selecting target method for debug analysis..."
-+   grep -r "DiscoverTestsAsync\|AnalyzeAssembly\|ProcessDependencies" src/ --include="*.cs" -n | head -5
-+   ```
-+
-+2. **Document expected behavior**:
-+   ```bash
-+   echo "üìù Documenting what we expect to find..."
-+   # Manually identify tests that should be found
-+   grep -r "TargetMethodName" tests/ --include="*.cs" -l
-+   ```
-+
-+### Step 2: Add Debug Tracing to Source Code
-+
-+Before running the command, temporarily add debug statements to trace execution:
-+
-+```bash
-+# Backup original files
-+cp src/TestIntelligence.CLI/Commands/FindTestsCommand.cs src/TestIntelligence.CLI/Commands/FindTestsCommand.cs.debug-backup
-+cp src/TestIntelligence.Core/Services/TestMethodMapper.cs src/TestIntelligence.Core/Services/TestMethodMapper.cs.debug-backup
-+```
-+
-+#### Add debug statements to key files:
-+
-+**1. FindTestsCommand.cs - Entry point tracing**:
-+```csharp
-+// Add after method signature
-+Console.WriteLine($"üîç DEBUG: Starting find-tests for method: {methodName}");
-+Console.WriteLine($"üîç DEBUG: Solution path: {solutionPath}");
-+Console.WriteLine($"üîç DEBUG: Output format: {format}");
-+```
-+
-+**2. TestMethodMapper.cs - Core logic tracing**:
-+```csharp
-+// Add in FindTestsForMethod
-+Console.WriteLine($"üîç DEBUG: Loading solution: {solutionPath}");
-+Console.WriteLine($"üîç DEBUG: Target method: {targetMethod}");
-+Console.WriteLine($"üîç DEBUG: Found {projects.Count} projects to analyze");
-+
-+// Add in call graph traversal
-+Console.WriteLine($"üîç DEBUG: Building call graph for method: {method.Name}");
-+Console.WriteLine($"üîç DEBUG: Found {callers.Count} direct callers");
-+
-+// Add in test discovery
-+Console.WriteLine($"üîç DEBUG: Discovered {testMethods.Count} total test methods");
-+Console.WriteLine($"üîç DEBUG: Filtering tests that call target method...");
-+```
-+
-+**3. Assembly loading tracing**:
-+```csharp
-+// Add assembly loading debug info
-+Console.WriteLine($"üîç DEBUG: Loading assembly: {assemblyPath}");
-+Console.WriteLine($"üîç DEBUG: Assembly loaded successfully: {assembly.FullName}");
-+Console.WriteLine($"üîç DEBUG: Found {types.Length} types in assembly");
-+```
-+
-+### Step 3: Run Debug-Enhanced Find-Tests Command
-+
-+```bash
-+# Clear cache to ensure fresh analysis
-+dotnet run --project src/TestIntelligence.CLI cache \
-+  --solution TestIntelligence.sln \
-+  --action clear
-+
-+echo "üöÄ Running debug find-tests command..."
-+dotnet run --project src/TestIntelligence.CLI find-tests \
-+  --method "TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync" \
-+  --solution TestIntelligence.sln \
-+  --format json \
-+  --output debug-find-tests-result.json \
-+  --verbose 2>&1 | tee debug-find-tests-trace.log
-+```
-+
-+### Step 4: Enhanced Debug Analysis
-+
-+#### 4.1 Trace Analysis
-+```bash
-+echo "üìä Analyzing debug trace..."
-+
-+# Check if solution loaded correctly
-+grep "Loading solution" debug-find-tests-trace.log
-+grep "Found.*projects" debug-find-tests-trace.log
-+
-+# Check assembly loading
-+grep "Loading assembly" debug-find-tests-trace.log
-+grep "Assembly loaded successfully" debug-find-tests-trace.log
-+
-+# Check call graph construction
-+grep "Building call graph" debug-find-tests-trace.log
-+grep "Found.*callers" debug-find-tests-trace.log
-+
-+# Check test discovery
-+grep "Discovered.*test methods" debug-find-tests-trace.log
-+grep "Filtering tests" debug-find-tests-trace.log
-+```
-+
-+#### 4.2 Validate Each Step
-+```bash
-+echo "üîç Step-by-step validation..."
-+
-+# 1. Verify target method exists
-+echo "1. Checking if target method exists in codebase:"
-+grep -r "DiscoverTestsAsync" src/ --include="*.cs" -A 2 -B 2
-+
-+# 2. Verify test methods that should be found
-+echo "2. Manual search for tests that should be found:"
-+grep -r "DiscoverTestsAsync\|NUnitTestDiscovery" tests/ --include="*.cs" -n
-+
-+# 3. Check for false positives in results
-+echo "3. Examining found tests for false positives:"
-+jq '.foundTests[].testName' debug-find-tests-result.json
-+
-+# 4. Cross-reference with actual test code
-+echo "4. Cross-referencing with actual test implementations:"
-+for test in $(jq -r '.foundTests[].testName' debug-find-tests-result.json); do
-+  echo "Examining test: $test"
-+  # Find the test file and examine it
-+  grep -r "$test" tests/ --include="*.cs" -A 10 -B 2
-+done
-+```
-+
-+### Step 5: Deep Dive Debugging
-+
-+#### 5.1 Call Graph Debugging
-+```bash
-+echo "üï∏Ô∏è Deep dive into call graph construction..."
-+
-+# Generate call graph for target method
-+dotnet run --project src/TestIntelligence.CLI callgraph \
-+  --path TestIntelligence.sln \
-+  --format json \
-+  --output debug-callgraph.json \
-+  --verbose
-+
-+# Compare call graph with find-tests results
-+echo "Comparing call graph with find-tests results..."
-+jq '.methods[] | select(.name | contains("DiscoverTestsAsync"))' debug-callgraph.json
-+```
-+
-+#### 5.2 Assembly Reflection Debugging
-+Add deeper assembly inspection:
-+```csharp
-+// Add to assembly loading section
-+Console.WriteLine($"üîç DEBUG: Assembly types found:");
-+foreach (var type in assembly.GetTypes())
-+{
-+    Console.WriteLine($"  - {type.FullName}");
-+    if (type.Name.Contains("Test"))
-+    {
-+        var methods = type.GetMethods().Where(m => m.GetCustomAttributes().Any());
-+        Console.WriteLine($"    Test methods: {methods.Count()}");
-+        foreach (var method in methods)
-+        {
-+            Console.WriteLine($"      - {method.Name}");
-+        }
-+    }
-+}
-+```
-+
-+### Step 6: Issue Classification and Reporting
-+
-+#### 6.1 Categorize Issues Found
-+```bash
-+echo "üìã Categorizing issues found during debug session..."
-+
-+# False Positives Analysis
-+echo "‚ùå FALSE POSITIVES:"
-+echo "Tests that were found but don't actually call the target method:"
-+# Manual analysis based on code examination
-+
-+# False Negatives Analysis  
-+echo "‚ùå FALSE NEGATIVES:"
-+echo "Tests that should have been found but weren't:"
-+# Compare manual grep results with CLI output
-+
-+# Confidence Score Issues
-+echo "‚ö†Ô∏è CONFIDENCE SCORE ISSUES:"
-+echo "Tests with inappropriate confidence scores:"
-+# Analyze if scores match call depth/complexity
-+```
-+
-+#### 6.2 Root Cause Analysis
-+Based on debug output, identify likely causes:
-+
-+**Common Issues to Look For**:
-+- **Assembly Loading**: Are all test assemblies being loaded?
-+- **Reflection Issues**: Are test attributes being detected correctly?
-+- **Call Graph**: Is method call traversal working correctly?
-+- **Name Matching**: Are there namespace or overload resolution issues?
-+- **Caching**: Are cached results stale or incorrect?
-+
-+### Step 7: Debug Report Format
-+
-+```
-+## Debug Find-Tests Analysis Report
-+
-+**Target Method**: TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync
-+**Debug Session Date**: [Current Date]
-+**Known Issues Being Investigated**: False positives, missing integration tests
-+
-+### Debug Trace Summary
-+- ‚úÖ Solution loaded: 15 projects found
-+- ‚úÖ Target method located in: TestIntelligence.Core.dll
-+- ‚ö†Ô∏è Assembly loading: 2 warnings about dependency versions
-+- ‚úÖ Call graph construction: 45 direct callers found
-+- ‚ùå Test discovery: Only 12 test methods found (expected ~20)
-+
-+### Execution Flow Analysis
-+
-+#### 1. Solution Loading (‚úÖ Working)
-+```
-+üîç DEBUG: Loading solution: TestIntelligence.sln
-+üîç DEBUG: Found 15 projects to analyze
-+```
-+
-+#### 2. Target Method Resolution (‚úÖ Working)
-+```
-+üîç DEBUG: Target method: TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync
-+üîç DEBUG: Method located in assembly: TestIntelligence.Core
-+```
-+
-+#### 3. Call Graph Construction (‚ö†Ô∏è Partial Issue)
-+```
-+üîç DEBUG: Building call graph for method: DiscoverTestsAsync
-+üîç DEBUG: Found 45 direct callers
-+Issue: Missing some integration test callers due to indirect invocation
-+```
-+
-+#### 4. Test Discovery (‚ùå Major Issue)
-+```
-+üîç DEBUG: Discovered 89 total test methods
-+üîç DEBUG: Filtering tests that call target method...
-+Issue: Filter logic excluding valid tests with indirect calls
-+```
-+
-+### Issues Identified
-+
-+#### ‚ùå Issue #1: Missing Integration Tests
-+**Problem**: Integration tests that call TestAnalyzer.AnalyzeAssembly (which calls DiscoverTestsAsync) are not being found
-+**Root Cause**: Call graph depth limit or indirect call resolution
-+**Evidence**: Manual grep found 8 integration tests, CLI found only 2
-+**Debug Trace**: 
-+```
-+Manual: grep -r "AnalyzeAssembly" tests/ found 8 matches
-+CLI Result: Only 2 tests with confidence scores > 0.5
-+```
-+
-+#### ‚ùå Issue #2: False Positive Detection
-+**Problem**: Test "SomeUnrelatedTest" was found with 0.3 confidence
-+**Root Cause**: Name collision or incorrect dependency analysis
-+**Evidence**: Test code shows no actual calls to target method
-+**Debug Trace**:
-+```
-+Test code analysis: Only calls DatabaseHelper.Setup() and Assert methods
-+No path to DiscoverTestsAsync found in manual trace
-+```
-+
-+#### ‚ö†Ô∏è Issue #3: Confidence Score Inaccuracy
-+**Problem**: Direct test has confidence 0.7, indirect test has 0.8
-+**Root Cause**: Scoring algorithm may be inverted or considering other factors
-+**Evidence**: NUnitTestDiscoveryTests.DirectTest should have higher confidence than IntegrationTests.IndirectTest
-+
-+### Recommended Fixes
-+
-+1. **Call Graph Depth**: Increase traversal depth for integration tests
-+2. **Filter Logic**: Review test filtering criteria to include indirect callers
-+3. **Name Resolution**: Improve method name matching to avoid false positives
-+4. **Confidence Scoring**: Review algorithm to properly weight direct vs indirect calls
-+
-+### Next Steps
-+1. Apply debug fixes to core components
-+2. Re-run debug session to validate improvements
-+3. Add unit tests for edge cases discovered
-+4. Update documentation with known limitations
-+```
-+
-+### Step 8: Fix Issues Found
-+
-+**CRITICAL**: After identifying issues through debugging, you MUST implement fixes for all problems discovered.
-+
-+#### 8.1 Apply Fixes Based on Root Cause Analysis
-+
-+Based on the issues identified in the debug report, implement the following fixes:
-+
-+**Fix #1: Call Graph Depth Issues**
-+```bash
-+echo "üîß Fixing call graph traversal depth..."
-+
-+# Edit the call graph construction to increase depth limit
-+# Look for depth limiting code in TestMethodMapper or CallGraphBuilder
-+grep -r "depth\|limit" src/TestIntelligence.Core/ --include="*.cs" -n
-+
-+# Implement fix - example:
-+# Change: const int MAX_DEPTH = 3;
-+# To:     const int MAX_DEPTH = 5;
-+```
-+
-+**Fix #2: Test Filtering Logic**
-+```bash
-+echo "üîß Fixing test filtering to include indirect callers..."
-+
-+# Find and fix the test filtering logic
-+# Look for filtering criteria that might be too restrictive
-+grep -r "filter\|where.*confidence\|threshold" src/TestIntelligence.Core/ --include="*.cs" -A 3 -B 3
-+```
-+
-+**Fix #3: Confidence Score Algorithm**
-+```bash
-+echo "üîß Fixing confidence scoring algorithm..."
-+
-+# Locate confidence scoring logic
-+grep -r "confidence.*score\|calculateConfidence" src/TestIntelligence.Core/ --include="*.cs" -n
-+
-+# Review and fix scoring to properly weight:
-+# - Direct calls: Higher confidence (0.8-1.0)
-+# - One-hop indirect: Medium confidence (0.6-0.8)  
-+# - Multi-hop indirect: Lower confidence (0.3-0.6)
-+# - No relation: Very low confidence (0.0-0.2)
-+```
-+
-+**Fix #4: False Positive Prevention**
-+```bash
-+echo "üîß Implementing false positive detection..."
-+
-+# Add stricter validation for method relationships
-+# Implement additional verification steps before including tests
-+```
-+
-+#### 8.2 Implement Specific Code Changes
-+
-+For each identified issue, make the actual code changes:
-+
-+```bash
-+echo "üìù Implementing code fixes..."
-+
-+# Example fix for call graph depth
-+# Find the relevant file and implement the change
-+# Use Edit tool to modify the source code with the fix
-+```
-+
-+#### 8.3 Validate Fixes
-+
-+After implementing fixes, validate they work:
-+
-+```bash
-+echo "‚úÖ Validating fixes..."
-+
-+# Rebuild the solution
-+dotnet build
-+
-+# Clear cache to ensure fresh analysis
-+dotnet run --project src/TestIntelligence.CLI cache \
-+  --solution TestIntelligence.sln \
-+  --action clear
-+
-+# Re-run the find-tests command to verify improvements
-+dotnet run --project src/TestIntelligence.CLI find-tests \
-+  --method "TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync" \
-+  --solution TestIntelligence.sln \
-+  --format json \
-+  --output fixed-find-tests-result.json \
-+  --verbose
-+
-+echo "üîç Comparing before/after results..."
-+# Compare original debug results with fixed results
-+echo "Before fix - tests found: $(jq '.foundTests | length' debug-find-tests-result.json)"
-+echo "After fix - tests found: $(jq '.foundTests | length' fixed-find-tests-result.json)"
-+
-+# Verify specific issues were resolved:
-+echo "Checking if missing integration tests are now found..."
-+echo "Checking if false positives were eliminated..."
-+echo "Checking if confidence scores are more accurate..."
-+```
-+
-+#### 8.4 Run Comprehensive Tests
-+
-+Ensure fixes don't break other functionality:
-+
-+```bash
-+echo "üß™ Running comprehensive tests after fixes..."
-+
-+# Run all relevant tests
-+dotnet test tests/TestIntelligence.Core.Tests/ -v normal
-+dotnet test tests/TestIntelligence.ImpactAnalyzer.Tests/ -v normal
-+
-+# Test with different target methods to ensure general improvement
-+dotnet run --project src/TestIntelligence.CLI find-tests \
-+  --method "TestIntelligence.Core.TestAnalyzer.AnalyzeAssembly" \
-+  --solution TestIntelligence.sln \
-+  --output validation-test-2.json
-+
-+dotnet run --project src/TestIntelligence.CLI find-tests \
-+  --method "TestIntelligence.DataTracker.DatabaseAnalyzer.AnalyzeDependencies" \
-+  --solution TestIntelligence.sln \
-+  --output validation-test-3.json
-+```
-+
-+### Step 9: Cleanup and Restoration
-+
-+```bash
-+echo "üßπ Cleaning up debug modifications..."
-+
-+# Restore original files (debug tracing code)
-+mv src/TestIntelligence.CLI/Commands/FindTestsCommand.cs.debug-backup src/TestIntelligence.CLI/Commands/FindTestsCommand.cs
-+mv src/TestIntelligence.Core/Services/TestMethodMapper.cs.debug-backup src/TestIntelligence.Core/Services/TestMethodMapper.cs
-+
-+# Keep debug logs and results for reference
-+mkdir -p debug-logs
-+mv debug-find-tests-trace.log debug-logs/
-+mv debug-find-tests-result.json debug-logs/
-+mv fixed-find-tests-result.json debug-logs/
-+mv debug-callgraph.json debug-logs/
-+mv validation-test-*.json debug-logs/
-+
-+echo "‚úÖ Debug session complete with fixes applied. Logs saved to debug-logs/"
-+```
-+
-+## Usage Instructions for Claude
-+
-+When running this debug command, you MUST:
-+
-+1. **Be systematic** - Follow each debug step to identify the exact failure point
-+2. **Preserve evidence** - Save all debug output and manual verification results
-+3. **Compare exhaustively** - Cross-reference CLI results with manual code analysis
-+4. **Focus on root causes** - Don't just identify symptoms, trace to underlying issues
-+5. **Document thoroughly** - Create detailed reports to help fix the underlying problems
-+6. **IMPLEMENT FIXES** - Actually modify the source code to resolve identified issues
-+7. **Validate fixes** - Re-run debug session and tests after applying fixes
-+8. **Test comprehensively** - Ensure fixes don't break other functionality
-+
-+**CRITICAL REQUIREMENT**: This command is not complete until you have:
-+- ‚úÖ Identified all issues through debugging
-+- ‚úÖ Implemented code fixes for each identified problem
-+- ‚úÖ Validated that fixes resolve the issues
-+- ‚úÖ Confirmed no regressions were introduced
-+- ‚úÖ Updated any relevant tests or documentation
-+
-+This debug-and-fix approach will not only identify where the find-tests command is failing but will also resolve those issues to improve the overall accuracy and reliability of the TestIntelligence library.
-\ No newline at end of file
-diff --git a/.claude/commands/test-analyze-coverage.md b/.claude/commands/test-analyze-coverage.md
-new file mode 100644
-index 0000000..9eb3bdc
---- /dev/null
-+++ b/.claude/commands/test-analyze-coverage.md
-@@ -0,0 +1,187 @@
-+# Test Analyze Coverage Command
-+
-+Instructions for Claude to test the analyze-coverage command by selecting test methods and verifying how well they cover code changes.
-+
-+## Testing Protocol
-+
-+### Step 1: Create Test Scenario
-+1. **Select Target Tests**: Choose 2-3 test methods from different test projects:
-+   - Pick tests that exercise different parts of the codebase
-+   - Include both unit tests and integration tests
-+   - Choose tests you can manually trace through
-+
-+2. **Create Mock Changes**: Generate a git diff to analyze:
-+   ```bash
-+   # Option A: Create actual changes and diff them
-+   echo "// Test change" >> src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
-+   git add -A
-+   git diff --cached > test-changes.patch
-+   git reset HEAD
-+   
-+   # Option B: Use existing git history
-+   git diff HEAD~1 > recent-changes.patch
-+   ```
-+
-+### Step 2: Run the Analyze-Coverage Command
-+```bash
-+dotnet run --project src/TestIntelligence.CLI analyze-coverage \
-+  --solution TestIntelligence.sln \
-+  --tests "TestClass1.TestMethod1" "TestClass2.TestMethod2" "TestClass3.TestMethod3" \
-+  --git-command "diff HEAD~1" \
-+  --verbose \
-+  --output coverage-analysis.json
-+```
-+
-+Alternative with diff file:
-+```bash
-+dotnet run --project src/TestIntelligence.CLI analyze-coverage \
-+  --solution TestIntelligence.sln \
-+  --tests "TestClass1.TestMethod1" "TestClass2.TestMethod2" \
-+  --diff-file test-changes.patch \
-+  --verbose \
-+  --output coverage-analysis.json
-+```
-+
-+### Step 3: Manual Verification Process
-+
-+#### 3.1 Analyze the Output
-+1. **Read Coverage Report**: Examine JSON results for:
-+   - Coverage percentage for each test
-+   - List of changed methods/classes covered by each test
-+   - Uncovered changes identified
-+   - Overall coverage metrics
-+
-+2. **Understand Change Set**: Review the git diff to identify:
-+   - Which files were modified
-+   - Which methods/classes were changed
-+   - Nature of changes (new code, modifications, deletions)
-+
-+#### 3.2 Manual Coverage Verification
-+For each test method:
-+
-+1. **Trace Test Execution**:
-+   - Read the test method source code
-+   - Follow all method calls made by the test
-+   - Map the execution path through the codebase
-+
-+2. **Match Against Changes**:
-+   - Compare test execution path with changed code
-+   - Identify which changed methods/classes the test actually exercises
-+   - Note any changed code the test doesn't reach
-+
-+3. **Validate Coverage Calculation**:
-+   - Count changed methods covered vs. total changed methods
-+   - Verify the coverage percentage is mathematically correct
-+   - Check if the analysis missed any coverage or overcounted
-+
-+#### 3.3 Gap Analysis
-+1. **Identify Uncovered Changes**:
-+   - Find changed code not exercised by any of the selected tests
-+   - Verify these are truly uncovered (not false negatives)
-+
-+2. **Find Coverage Gaps**:
-+   - Look for changed code that should be covered but isn't
-+   - Search for additional tests that might cover the gaps
-+
-+### Step 4: Verification Commands
-+
-+```bash
-+# Search for tests that might cover a specific changed class
-+grep -r "ChangedClassName" tests/ --include="*.cs" -l
-+
-+# Look at specific changed file to understand modifications
-+git show HEAD~1:src/path/to/ChangedFile.cs | diff - src/path/to/ChangedFile.cs
-+
-+# Find all tests in a specific test class
-+grep -n "\[Test\]\|\[Fact\]\|\[TestMethod\]" tests/path/to/TestClass.cs
-+
-+# Trace method usage across the codebase
-+grep -r "ChangedMethodName" src/ --include="*.cs"
-+```
-+
-+### Step 5: Sample Verification Report Format
-+
-+```
-+## Analyze-Coverage Verification Report
-+
-+**Test Scenario**:
-+- Selected Tests: 3 tests from Core and DataTracker projects
-+- Change Set: Modified NUnitTestDiscovery.cs and TestAnalyzer.cs (8 methods changed)
-+- Git Command: `diff HEAD~1`
-+
-+**CLI Output Summary**:
-+- Test1 Coverage: 75% (6/8 changed methods)
-+- Test2 Coverage: 25% (2/8 changed methods)  
-+- Test3 Coverage: 0% (0/8 changed methods)
-+- Overall Coverage: 87.5% (7/8 changed methods covered by at least one test)
-+
-+**Manual Verification**:
-+
-+‚úÖ **Test1: NUnitTestDiscoveryTests.DiscoverTestsAsync_ValidAssembly**
-+   - Claimed Coverage: 75% (6/8 methods)
-+   - Manual Trace: Calls NUnitTestDiscovery.DiscoverTestsAsync ‚Üí LoadAssembly ‚Üí ProcessTypes ‚Üí ExtractAttributes
-+   - Actually Covers: NUnitTestDiscovery.DiscoverTestsAsync, LoadAssembly, ProcessTypes, ExtractAttributes, ValidateTest, FormatResults (6/8) ‚úÖ
-+   - Coverage calculation: Correct
-+
-+‚úÖ **Test2: TestAnalyzerTests.AnalyzeFullSolution**  
-+   - Claimed Coverage: 25% (2/8 methods)
-+   - Manual Trace: Calls TestAnalyzer.AnalyzeAssembly ‚Üí NUnitTestDiscovery.DiscoverTestsAsync ‚Üí LoadAssembly
-+   - Actually Covers: AnalyzeAssembly, DiscoverTestsAsync (2/8) ‚úÖ
-+   - Coverage calculation: Correct
-+
-+‚ö†Ô∏è **Test3: DataTrackerTests.SomeUnrelatedTest**
-+   - Claimed Coverage: 0% (0/8 methods)
-+   - Manual Trace: Only exercises database tracking functionality
-+   - Actually Covers: None of the changed methods ‚úÖ
-+   - Coverage calculation: Correct (true negative)
-+
-+**Uncovered Changes Verification**:
-+‚úÖ **TestAnalyzer.ValidateConfiguration** - Correctly identified as uncovered
-+   - No selected tests call this method
-+   - Manually confirmed by searching test codebase
-+
-+‚ùå **Missing Coverage Detection**:
-+   - Found integration test `FullPipelineTests.CompleteAnalysis` that exercises ValidateConfiguration
-+   - This test wasn't in the selected set but would provide coverage
-+   - CLI correctly reported method as uncovered for the selected tests
-+
-+**Overall Accuracy**: 100% - All coverage calculations verified as correct
-+**Coverage Gap Analysis**: 1/8 methods uncovered by selected tests (12.5% gap)
-+
-+**Recommendations**: 
-+- Coverage analysis is mathematically accurate
-+- Consider expanding test selection to include integration tests for better coverage
-+- The uncovered method has tests available but weren't in the analyzed set
-+```
-+
-+### Additional Verification Scenarios
-+
-+#### Scenario A: High Coverage Test Set
-+Select tests known to exercise broad functionality:
-+- Integration tests
-+- End-to-end workflow tests  
-+- Tests that call multiple components
-+
-+#### Scenario B: Low Coverage Test Set
-+Select very focused unit tests:
-+- Tests that only exercise one method
-+- Isolated component tests
-+- Mock-heavy tests with limited real code execution
-+
-+#### Scenario C: Mixed Framework Changes
-+Create changes spanning multiple projects:
-+- Core library changes
-+- CLI command changes
-+- Test framework changes
-+
-+## Usage Instructions for Claude
-+
-+When running this command:
-+1. **Be methodical** - actually trace through test execution paths
-+2. **Verify math** - check that coverage percentages are calculated correctly
-+3. **Look for edge cases** - tests that might have unexpected coverage patterns
-+4. **Consider test types** - unit vs integration tests may have different coverage patterns
-+5. **Cross-reference** - use grep/search to validate coverage claims
-+6. **Report thoroughly** - document both correct results and any discrepancies found
-+
-+This testing ensures the analyze-coverage command accurately maps test execution to code changes, which is critical for intelligent test selection and impact analysis.
-\ No newline at end of file
-diff --git a/.claude/commands/test-and-commit.md b/.claude/commands/test-and-commit.md
-new file mode 100644
-index 0000000..9db3c91
---- /dev/null
-+++ b/.claude/commands/test-and-commit.md
-@@ -0,0 +1,39 @@
-+# Test and Commit
-+
-+Run all non-E2E tests, fix any issues found, and commit/push if all tests pass.
-+
-+## Command
-+
-+```bash
-+# Run all tests except E2E tests
-+dotnet test --filter "Category!=E2E" --verbosity normal
-+
-+# If tests fail, Claude will analyze and fix the issues
-+# If all tests pass, commit and push changes
-+if [ $? -eq 0 ]; then
-+  echo "All tests passed! Committing and pushing changes..."
-+  git add .
-+  git commit -m "$(cat <<'EOF'
-+Fix test issues and update codebase
-+
-+All non-E2E tests are now passing.
-+
-+ü§ñ Generated with [Claude Code](https://claude.ai/code)
-+
-+Co-Authored-By: Claude <noreply@anthropic.com>
-+EOF
-+)"
-+  git push
-+else
-+  echo "Tests failed. Claude will analyze and fix the issues."
-+fi
-+```
-+
-+## Usage
-+
-+Run this command when you want to:
-+1. Execute all tests except E2E tests
-+2. Have Claude automatically fix any test failures
-+3. Commit and push changes if all tests pass
-+
-+This command ensures your codebase maintains test quality while automating the commit process for successful test runs.
-\ No newline at end of file
-diff --git a/.claude/commands/test-find-tests.md b/.claude/commands/test-find-tests.md
-new file mode 100644
-index 0000000..89bb827
---- /dev/null
-+++ b/.claude/commands/test-find-tests.md
-@@ -0,0 +1,103 @@
-+# Test Find-Tests Command
-+
-+Instructions for Claude to test the find-tests command by selecting a random method and verifying the output accuracy.
-+
-+## Testing Protocol
-+
-+### Step 1: Select a Random Method
-+1. Use `find` or `grep` to discover methods in the src/ directory
-+2. Pick a method from a Core, Categorizer, DataTracker, ImpactAnalyzer, or SelectionEngine class
-+3. Choose a method that's likely to be tested (public methods, important functionality)
-+
-+### Step 2: Run the Find-Tests Command
-+```bash
-+dotnet run --project src/TestIntelligence.CLI find-tests \
-+  --method "FullNamespace.ClassName.MethodName" \
-+  --solution TestIntelligence.sln \
-+  --format json \
-+  --output find-tests-result.json \
-+  --verbose
-+```
-+
-+### Step 3: Manual Verification Process
-+1. **Read the Output**: Examine the JSON results for:
-+   - List of test methods that allegedly exercise the target method
-+   - Confidence scores for each test
-+   - Call path depth information
-+
-+2. **Code Analysis**: For each test found:
-+   - Read the test method source code
-+   - Trace through the test execution path
-+   - Verify the test actually calls (directly or indirectly) the target method
-+   - Check if the confidence score seems reasonable based on call depth
-+
-+3. **Completeness Check**: 
-+   - Search the test codebase for the target method name
-+   - Look for any tests that should have been found but weren't
-+   - Verify no false positives (tests that don't actually exercise the method)
-+
-+4. **Report Results**:
-+   - Summarize accuracy: "X out of Y tests correctly identified"
-+   - Note any false positives or missed tests
-+   - Comment on confidence score appropriateness
-+   - Highlight any patterns or issues discovered
-+
-+### Step 4: Sample Commands to Help with Verification
-+
-+```bash
-+# Search for direct method calls in tests
-+grep -r "MethodName" tests/ --include="*.cs"
-+
-+# Search for class usage in tests
-+grep -r "ClassName" tests/ --include="*.cs"
-+
-+# Look at specific test file
-+cat tests/path/to/TestClass.cs
-+```
-+
-+### Example Verification Report Format
-+
-+```
-+## Find-Tests Verification Report
-+
-+**Target Method**: TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync
-+
-+**CLI Output Summary**:
-+- Found: 5 tests
-+- Confidence scores: High(2), Medium(2), Low(1)
-+
-+**Manual Verification**:
-+‚úÖ TestIntelligence.Core.Tests.Discovery.NUnitTestDiscoveryTests.DiscoverTestsAsync_ValidAssembly_ReturnsTests
-+   - Directly calls target method
-+   - Confidence: High (appropriate)
-+
-+‚úÖ TestIntelligence.Core.Tests.TestAnalyzerTests.AnalyzeAssembly_WithNUnitTests_IncludesNUnitTests  
-+   - Calls TestAnalyzer.AnalyzeAssembly which calls target method
-+   - Confidence: Medium (appropriate for 1-hop call)
-+
-+‚ùå TestIntelligence.SelectionEngine.Tests.SomeUnrelatedTest
-+   - False positive - doesn't actually call target method
-+   - Issue: Possible name collision or incorrect call graph
-+
-+**Missing Tests**:
-+- TestIntelligence.Core.Tests.Integration.FullAnalysisTests.CompleteAnalysis
-+  - This test exercises the full pipeline including the target method
-+  - Should have been found with Low confidence
-+
-+**Overall Accuracy**: 4/5 correct (80%)
-+**Recommendations**: 
-+- Investigate false positive detection
-+- Review call graph completeness for integration tests
-+```
-+
-+## Usage Instructions for Claude
-+
-+When running this command:
-+1. Be thorough in your verification - actually read the test code
-+2. Don't just trust the CLI output - verify by examining source code
-+3. Look for both false positives and false negatives
-+4. Consider the appropriateness of confidence scores
-+5. Report your findings in a clear, structured format
-+6. If you find issues, suggest potential causes or improvements
-+
-+This testing helps ensure the find-tests command is working accurately and can be trusted for real-world usage.
-\ No newline at end of file
-diff --git a/.claude/commands/test-select.md b/.claude/commands/test-select.md
-new file mode 100644
-index 0000000..dcb866c
---- /dev/null
-+++ b/.claude/commands/test-select.md
-@@ -0,0 +1,278 @@
-+# Test Select Command
-+
-+Instructions for Claude to test the select command by creating code changes and verifying intelligent test selection accuracy across different confidence levels.
-+
-+## Testing Protocol
-+
-+### Step 1: Create Test Scenarios
-+
-+#### Scenario A: Single File Change (Core Component)
-+```bash
-+# Make a targeted change to a core component
-+cp src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs.backup
-+echo "        // Test change for select command validation" >> src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
-+```
-+
-+#### Scenario B: Multi-File Change (Cross-Component)
-+```bash
-+# Make changes across multiple components
-+echo "        // Cross-component change test" >> src/TestIntelligence.Core/TestAnalyzer.cs
-+echo "        // Related CLI change" >> src/TestIntelligence.CLI/Commands/AnalyzeCommand.cs
-+```
-+
-+#### Scenario C: Interface/Contract Change
-+```bash
-+# Modify an interface or base class that affects multiple implementations
-+echo "        // Interface change affecting multiple implementations" >> src/TestIntelligence.Core/Interfaces/ITestDiscovery.cs
-+```
-+
-+### Step 2: Test Different Confidence Levels
-+
-+#### 2.1 Fast Confidence (30 sec, 70% confidence)
-+```bash
-+dotnet run --project src/TestIntelligence.CLI select \
-+  --path TestIntelligence.sln \
-+  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" \
-+  --confidence Fast \
-+  --max-tests 20 \
-+  --output select-fast.json \
-+  --verbose
-+```
-+
-+#### 2.2 Medium Confidence (5 min, 85% confidence)  
-+```bash
-+dotnet run --project src/TestIntelligence.CLI select \
-+  --path TestIntelligence.sln \
-+  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" \
-+  --confidence Medium \
-+  --max-tests 50 \
-+  --output select-medium.json \
-+  --verbose
-+```
-+
-+#### 2.3 High Confidence (15 min, 95% confidence)
-+```bash
-+dotnet run --project src/TestIntelligence.CLI select \
-+  --path TestIntelligence.sln \
-+  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" \
-+  --confidence High \
-+  --max-tests 100 \
-+  --output select-high.json \
-+  --verbose
-+```
-+
-+#### 2.4 Full Confidence (Complete suite, 100% confidence)
-+```bash
-+dotnet run --project src/TestIntelligence.CLI select \
-+  --path TestIntelligence.sln \
-+  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" \
-+  --confidence Full \
-+  --output select-full.json \
-+  --verbose
-+```
-+
-+### Step 3: Manual Verification Process
-+
-+#### 3.1 Analyze Selection Results
-+For each confidence level, examine:
-+1. **Number of tests selected**
-+2. **Test categories included** (Unit, Integration, Database, API, UI)
-+3. **Confidence scores** for each selected test
-+4. **Execution time estimates**
-+5. **Tests organized by priority/relevance**
-+
-+#### 3.2 Validate Test Selection Logic
-+
-+**Direct Impact Tests (Should be in Fast)**:
-+```bash
-+# Find tests that directly test the changed class
-+grep -r "NUnitTestDiscovery" tests/ --include="*.cs" -l
-+# These should appear in Fast confidence with high scores
-+```
-+
-+**Indirect Impact Tests (Should be in Medium)**:
-+```bash
-+# Find tests that use classes that depend on the changed class
-+grep -r "TestAnalyzer\|Discovery" tests/ --include="*.cs" -l
-+# These should appear in Medium confidence with medium scores
-+```
-+
-+**Integration Tests (Should be in High)**:
-+```bash
-+# Find integration tests that exercise the full pipeline
-+grep -r "Integration\|EndToEnd\|FullPipeline" tests/ --include="*.cs" -l
-+# These should appear in High confidence with lower scores
-+```
-+
-+#### 3.3 Confidence Level Validation
-+
-+Verify that each confidence level follows the expected pattern:
-+- **Fast ‚äÇ Medium ‚äÇ High ‚äÇ Full** (each level includes previous levels)
-+- **Decreasing relevance scores** as confidence level increases
-+- **Appropriate test count limits** respected
-+- **Time estimates** align with confidence level targets
-+
-+### Step 4: Cross-Reference with Other Commands
-+
-+#### 4.1 Verify Against Find-Tests
-+```bash
-+# For each selected test, verify it actually relates to the changed code
-+dotnet run --project src/TestIntelligence.CLI find-tests \
-+  --method "TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync" \
-+  --solution TestIntelligence.sln \
-+  --output find-tests-cross-check.json
-+```
-+
-+#### 4.2 Verify Against Coverage Analysis
-+```bash
-+# Check if selected tests actually provide good coverage of changes
-+dotnet run --project src/TestIntelligence.CLI analyze-coverage \
-+  --solution TestIntelligence.sln \
-+  --tests $(jq -r '.selectedTests[].testName' select-medium.json | tr '\n' ' ') \
-+  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" \
-+  --output coverage-cross-check.json
-+```
-+
-+### Step 5: Sample Verification Report Format
-+
-+```
-+## Select Command Verification Report
-+
-+**Test Scenario**: Modified NUnitTestDiscovery.cs (single method change)
-+**Change Type**: Core component modification affecting test discovery logic
-+
-+### Confidence Level Analysis
-+
-+#### Fast Confidence (Target: 30 sec, 70% confidence)
-+- **Selected**: 8 tests
-+- **Time Estimate**: 25 seconds ‚úÖ
-+- **Categories**: Unit (6), Integration (2)
-+- **Top Tests**:
-+  ‚úÖ NUnitTestDiscoveryTests.DiscoverTestsAsync_ValidAssembly (Score: 0.95)
-+  ‚úÖ NUnitTestDiscoveryTests.DiscoverTestsAsync_EmptyAssembly (Score: 0.92)  
-+  ‚úÖ TestAnalyzerTests.AnalyzeAssembly_WithNUnitTests (Score: 0.78)
-+
-+#### Medium Confidence (Target: 5 min, 85% confidence)  
-+- **Selected**: 23 tests (includes all Fast + 15 more) ‚úÖ
-+- **Time Estimate**: 4.2 minutes ‚úÖ
-+- **Categories**: Unit (15), Integration (6), Database (2)
-+- **Additional Tests**:
-+  ‚úÖ CoreIntegrationTests.FullDiscoveryPipeline (Score: 0.65)
-+  ‚úÖ MultiFrameworkTests.NUnitAndXUnit (Score: 0.58)
-+
-+#### High Confidence (Target: 15 min, 95% confidence)
-+- **Selected**: 47 tests (includes all Medium + 24 more) ‚úÖ  
-+- **Time Estimate**: 12.8 minutes ‚úÖ
-+- **Categories**: Unit (25), Integration (15), Database (4), API (3)
-+- **Additional Tests**:
-+  ‚úÖ E2ETests.CompleteAnalysisWorkflow (Score: 0.35)
-+  ‚ö†Ô∏è UnrelatedUITests.SomeUITest (Score: 0.12) - Questionable relevance
-+
-+#### Full Confidence
-+- **Selected**: All 215 tests ‚úÖ
-+- **Includes**: Every test in the solution
-+
-+### Manual Verification Results
-+
-+#### Direct Impact Validation ‚úÖ
-+**Expected**: Tests that directly call NUnitTestDiscovery methods
-+- Found 6 direct tests in TestIntelligence.Core.Tests
-+- All 6 appeared in Fast confidence with scores > 0.8 ‚úÖ
-+- Scores appropriately reflect call directness ‚úÖ
-+
-+#### Indirect Impact Validation ‚úÖ  
-+**Expected**: Tests that call TestAnalyzer which uses NUnitTestDiscovery
-+- Found 8 indirect tests across Core and CLI test projects
-+- 7/8 appeared in Medium confidence ‚úÖ
-+- 1 missing test: CLIIntegrationTests.AnalyzeCommand_WithNUnit ‚ùå
-+- Scores appropriately lower (0.5-0.8 range) ‚úÖ
-+
-+#### Integration Test Validation ‚ö†Ô∏è
-+**Expected**: End-to-end tests that exercise full discovery pipeline  
-+- Found 12 integration tests
-+- 10/12 appeared in High confidence ‚úÖ
-+- 2 missing: PerformanceTests.LargeSolutionAnalysis, StressTests.ConcurrentDiscovery ‚ùå
-+- Some questionable inclusions with very low relevance scores
-+
-+### Cross-Reference Validation
-+
-+#### Find-Tests Cross-Check ‚úÖ
-+- Selected tests from Fast confidence all verified via find-tests command
-+- No false positives detected in direct impact tests
-+- Confidence scores align between select and find-tests commands
-+
-+#### Coverage Analysis Cross-Check ‚ö†Ô∏è
-+- Medium confidence tests provide 78% coverage of changed code
-+- Expected: ~85% based on confidence level target
-+- Gap: Some edge cases in error handling not covered by selected tests
-+- Recommendation: Include additional error handling tests
-+
-+### Selection Logic Assessment
-+
-+**Strengths**:
-+- ‚úÖ Confidence levels properly nested (Fast ‚äÇ Medium ‚äÇ High ‚äÇ Full)
-+- ‚úÖ Time estimates realistic and within targets
-+- ‚úÖ Direct impact tests correctly prioritized
-+- ‚úÖ Test categories appropriately distributed
-+- ‚úÖ Relevance scores generally accurate
-+
-+**Issues Found**:
-+- ‚ùå 2 high-relevance tests missed in Medium confidence
-+- ‚ùå Some very low relevance tests included in High confidence  
-+- ‚ùå Coverage gap vs confidence level expectations
-+
-+**Overall Accuracy**: 85% - Good test selection with minor gaps
-+**Recommendation**: 
-+- Review inclusion threshold for High confidence
-+- Investigate why 2 relevant tests were missed
-+- Consider adjusting relevance scoring for integration tests
-+```
-+
-+### Advanced Test Scenarios
-+
-+#### Scenario D: Configuration Change Impact
-+```bash
-+# Test with configuration/settings changes that might affect many components
-+echo "    // Configuration change" >> src/TestIntelligence.Core/Configuration/AnalysisSettings.cs
-+```
-+
-+#### Scenario E: Multiple File Changes
-+```bash  
-+# Test selection with multiple related changes
-+dotnet run --project src/TestIntelligence.CLI select \
-+  --path TestIntelligence.sln \
-+  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" "src/TestIntelligence.Core/TestAnalyzer.cs" \
-+  --confidence Medium \
-+  --output select-multifile.json
-+```
-+
-+#### Scenario F: Max Tests Constraint
-+```bash
-+# Test that max-tests parameter is respected
-+dotnet run --project src/TestIntelligence.CLI select \
-+  --path TestIntelligence.sln \
-+  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" \
-+  --confidence High \
-+  --max-tests 10 \
-+  --output select-constrained.json
-+```
-+
-+### Cleanup
-+```bash
-+# Restore original files after testing
-+mv src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs.backup src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
-+git checkout -- src/TestIntelligence.Core/TestAnalyzer.cs src/TestIntelligence.CLI/Commands/AnalyzeCommand.cs
-+```
-+
-+## Usage Instructions for Claude
-+
-+When running this command:
-+1. **Test all confidence levels** - verify the nested relationship and appropriateness
-+2. **Validate time estimates** - check if they align with confidence level targets  
-+3. **Cross-reference results** - use find-tests and analyze-coverage to verify selections
-+4. **Check edge cases** - test with multiple files, constraints, and different change types
-+5. **Assess relevance scoring** - ensure tests are ranked appropriately by impact likelihood
-+6. **Verify completeness** - look for missing tests that should be included
-+7. **Report systematically** - document accuracy, gaps, and recommendations
-+
-+This testing ensures the select command provides intelligent, accurate test selection that balances coverage with execution efficiency across different confidence levels.
-\ No newline at end of file
-diff --git a/Directory.Build.props b/Directory.Build.props
-index 14da534..fe3608c 100644
---- a/Directory.Build.props
-+++ b/Directory.Build.props
-@@ -10,7 +10,7 @@
-     <LangVersion>latest</LangVersion>
-     <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
-     <WarningsAsErrors />
--    <WarningsNotAsErrors>NU1605;NU1701</WarningsNotAsErrors>
-+    <WarningsNotAsErrors>NU1605;NU1701;MSB3277</WarningsNotAsErrors>
-     
-     <!-- Common package metadata -->
-     <Authors>TestIntelligence Contributors</Authors>
-diff --git a/src/TestIntelligence.CLI/Commands/BaseCommandHandler.cs b/src/TestIntelligence.CLI/Commands/BaseCommandHandler.cs
-index 3118751..5892681 100644
---- a/src/TestIntelligence.CLI/Commands/BaseCommandHandler.cs
-+++ b/src/TestIntelligence.CLI/Commands/BaseCommandHandler.cs
-@@ -35,28 +35,113 @@ namespace TestIntelligence.CLI.Commands
-             catch (OperationCanceledException)
-             {
-                 Logger.LogInformation("Command execution was cancelled");
--                return 1;
-+                Console.Error.WriteLine("Operation was cancelled by user.");
-+                return 130; // Standard exit code for cancelled operations
-             }
-             catch (ArgumentException ex)
-             {
-                 Logger.LogError(ex, "Invalid arguments provided to command");
--                Console.Error.WriteLine($"Error: {ex.Message}");
-+                Console.Error.WriteLine($"‚ùå Invalid argument: {ex.Message}");
-+                PrintUsageHint(context);
-                 return 1;
-             }
-+            catch (FileNotFoundException ex)
-+            {
-+                Logger.LogError(ex, "Required file not found");
-+                Console.Error.WriteLine($"‚ùå File not found: {ex.FileName ?? ex.Message}");
-+                Console.Error.WriteLine("Please verify that the file path is correct and accessible.");
-+                return 2;
-+            }
-+            catch (DirectoryNotFoundException ex)
-+            {
-+                Logger.LogError(ex, "Required directory not found");
-+                Console.Error.WriteLine($"‚ùå Directory not found: {ex.Message}");
-+                Console.Error.WriteLine("Please verify that the directory path is correct and accessible.");
-+                return 2;
-+            }
-+            catch (UnauthorizedAccessException ex)
-+            {
-+                Logger.LogError(ex, "Access denied to file or directory");
-+                Console.Error.WriteLine($"‚ùå Access denied: {ex.Message}");
-+                Console.Error.WriteLine("Please check file/directory permissions or run with appropriate privileges.");
-+                return 13; // Standard exit code for permission denied
-+            }
-+            catch (TimeoutException ex)
-+            {
-+                Logger.LogError(ex, "Operation timed out");
-+                Console.Error.WriteLine($"‚ùå Operation timed out: {ex.Message}");
-+                Console.Error.WriteLine("The operation took longer than expected. Try reducing the scope or running again.");
-+                return 124; // Standard exit code for timeout
-+            }
-+            catch (System.IO.FileLoadException ex) when (ex.Message.Contains("Microsoft.Bcl.AsyncInterfaces"))
-+            {
-+                Logger.LogError(ex, "Assembly loading conflict detected");
-+                Console.Error.WriteLine("‚ùå Assembly conflict detected:");
-+                Console.Error.WriteLine($"   {ex.Message}");
-+                Console.Error.WriteLine();
-+                Console.Error.WriteLine("üí° This is usually caused by conflicting package versions. Try:");
-+                Console.Error.WriteLine("   ‚Ä¢ Clearing NuGet cache: dotnet nuget locals all --clear");
-+                Console.Error.WriteLine("   ‚Ä¢ Rebuilding the solution: dotnet clean && dotnet build");
-+                Console.Error.WriteLine("   ‚Ä¢ Updating packages to consistent versions");
-+                return 125; // Custom exit code for assembly conflicts
-+            }
-+            catch (System.Reflection.ReflectionTypeLoadException ex)
-+            {
-+                Logger.LogError(ex, "Failed to load types from assembly");
-+                Console.Error.WriteLine("‚ùå Failed to load assembly types:");
-+                if (ex.LoaderExceptions != null)
-+                {
-+                    foreach (var loaderEx in ex.LoaderExceptions.Take(3))
-+                    {
-+                        Console.Error.WriteLine($"   ‚Ä¢ {loaderEx?.Message}");
-+                    }
-+                    if (ex.LoaderExceptions.Length > 3)
-+                    {
-+                        Console.Error.WriteLine($"   ... and {ex.LoaderExceptions.Length - 3} more errors");
-+                    }
-+                }
-+                Console.Error.WriteLine();
-+                Console.Error.WriteLine("üí° This usually indicates missing dependencies or version mismatches.");
-+                Console.Error.WriteLine("   Check that all required packages are installed and compatible.");
-+                return 126; // Custom exit code for type loading failures
-+            }
-+            catch (OutOfMemoryException ex)
-+            {
-+                Logger.LogError(ex, "Out of memory during command execution");
-+                Console.Error.WriteLine("‚ùå Insufficient memory to complete the operation.");
-+                Console.Error.WriteLine("üí° Try reducing the scope (e.g., analyze fewer files) or increase available memory.");
-+                return 127; // Custom exit code for memory issues
-+            }
-             catch (Exception ex)
-             {
-                 Logger.LogError(ex, "Unexpected error during command execution");
--                Console.Error.WriteLine($"Error: {ex.Message}");
-+                Console.Error.WriteLine($"‚ùå Unexpected error: {ex.Message}");
-                 
-                 if (Logger.IsEnabled(LogLevel.Debug))
-                 {
-                     Console.Error.WriteLine($"Stack trace: {ex.StackTrace}");
-                 }
-+                else
-+                {
-+                    Console.Error.WriteLine("Use --verbose for detailed error information.");
-+                }
-+                
-+                Console.Error.WriteLine();
-+                Console.Error.WriteLine("üí° If this error persists, please report it at:");
-+                Console.Error.WriteLine("   https://github.com/TestIntelligence/TestIntelligence/issues");
-                 
-                 return 1;
-             }
-         }
- 
-+        /// <summary>
-+        /// Prints usage hint for the current command.
-+        /// </summary>
-+        protected virtual void PrintUsageHint(CommandContext context)
-+        {
-+            Console.Error.WriteLine("üí° Use --help to see available options and usage examples.");
-+        }
-+
-         /// <summary>
-         /// Executes the command-specific logic. Override this in derived classes.
-         /// </summary>
-diff --git a/src/TestIntelligence.CLI/Commands/FindTestsCommandHandler.cs b/src/TestIntelligence.CLI/Commands/FindTestsCommandHandler.cs
-index 615231e..3ba1564 100644
---- a/src/TestIntelligence.CLI/Commands/FindTestsCommandHandler.cs
-+++ b/src/TestIntelligence.CLI/Commands/FindTestsCommandHandler.cs
-@@ -1,4 +1,5 @@
- using System;
-+using System.Collections.Generic;
- using System.IO;
- using System.Linq;
- using System.Text;
-@@ -7,6 +8,7 @@ using System.Threading.Tasks;
- using Microsoft.Extensions.Logging;
- using TestIntelligence.CLI.Services;
- using TestIntelligence.Core.Services;
-+using TestIntelligence.Core.Models;
- 
- namespace TestIntelligence.CLI.Commands;
- 
-@@ -32,27 +34,61 @@ public class FindTestsCommandHandler : BaseCommandHandler
-         var format = context.GetParameter<string>("format") ?? "text";
-         var verbose = context.GetParameter<bool>("verbose");
- 
-+        // Additional validation
-+        ValidateInputs(method!, solution!, output, format);
-+
-         Logger.LogInformation("Finding tests that exercise method: {Method} in solution: {Solution}", method, solution);
-         
-         // Get services from DI
-         var testCoverageAnalyzer = context.GetService<ITestCoverageAnalyzer>();
-         var outputFormatter = context.GetService<IOutputFormatter>();
-         
-+        if (testCoverageAnalyzer == null)
-+        {
-+            throw new InvalidOperationException("Test coverage analyzer service is not available. Please check the application configuration.");
-+        }
-+        
-+        if (outputFormatter == null)
-+        {
-+            throw new InvalidOperationException("Output formatter service is not available. Please check the application configuration.");
-+        }
-+        
-         Console.WriteLine($"Finding tests that exercise method: {method}");
-         Console.WriteLine($"Solution path: {solution}");
-         Console.WriteLine();
- 
--        var tests = await testCoverageAnalyzer.FindTestsExercisingMethodAsync(method!, solution!);
--        
--        if (!tests.Any())
-+        IReadOnlyList<TestCoverageInfo> tests;
-+        try
-         {
--            Console.WriteLine("No tests found that exercise this method.");
-+            tests = await testCoverageAnalyzer.FindTestsExercisingMethodAsync(method!, solution!, cancellationToken);
-+            
-+            if (tests == null || !tests.Any())
-+            {
-+                Console.WriteLine("No tests found that exercise this method.");
-+                Console.WriteLine();
-+                Console.WriteLine("üí° This could mean:");
-+                Console.WriteLine("   ‚Ä¢ The method name/signature is incorrect");
-+                Console.WriteLine("   ‚Ä¢ No tests actually exercise this method");
-+                Console.WriteLine("   ‚Ä¢ The method is not public or accessible");
-+                Console.WriteLine("   ‚Ä¢ There are compilation errors preventing analysis");
-+                return 0;
-+            }
-+
-+            Console.WriteLine($"Found {tests.Count} test(s) exercising this method:");
-+            Console.WriteLine();
-+        }
-+        catch (ArgumentException)
-+        {
-+            // Re-throw argument exceptions to be handled by base class
-+            throw;
-+        }
-+        catch (Exception ex) when (ex.Message.Contains("No test methods found"))
-+        {
-+            Console.WriteLine("No test methods found in the solution.");
-+            Console.WriteLine("üí° Make sure the solution builds successfully and contains test projects.");
-             return 0;
-         }
- 
--        Console.WriteLine($"Found {tests.Count} test(s) exercising this method:");
--        Console.WriteLine();
--
-         if (format == "json")
-         {
-             var json = outputFormatter.FormatAsJson(tests);
-@@ -100,4 +136,45 @@ public class FindTestsCommandHandler : BaseCommandHandler
-         
-         return 0;
-     }
-+
-+    /// <summary>
-+    /// Validates the input parameters for the find-tests command.
-+    /// </summary>
-+    private void ValidateInputs(string method, string solution, string? output, string format)
-+    {
-+        // Validate solution file exists
-+        if (!File.Exists(solution))
-+        {
-+            throw new FileNotFoundException($"Solution file not found: {solution}");
-+        }
-+
-+        // Validate method format (basic validation)
-+        if (!method.Contains('.'))
-+        {
-+            throw new ArgumentException($"Method parameter should be in format 'Namespace.Class.Method', got: {method}");
-+        }
-+
-+        // Validate output format
-+        if (!string.Equals(format, "json", StringComparison.OrdinalIgnoreCase) && 
-+            !string.Equals(format, "text", StringComparison.OrdinalIgnoreCase))
-+        {
-+            throw new ArgumentException($"Format must be 'json' or 'text', got: {format}");
-+        }
-+
-+        // Validate output path if provided
-+        if (!string.IsNullOrWhiteSpace(output))
-+        {
-+            var outputDir = Path.GetDirectoryName(Path.GetFullPath(output));
-+            if (!string.IsNullOrEmpty(outputDir) && !Directory.Exists(outputDir))
-+            {
-+                throw new DirectoryNotFoundException($"Output directory does not exist: {outputDir}");
-+            }
-+        }
-+    }
-+
-+    protected override void PrintUsageHint(CommandContext context)
-+    {
-+        Console.Error.WriteLine("üí° Usage: find-tests --method \"Namespace.Class.Method\" --solution \"path/to/solution.sln\"");
-+        Console.Error.WriteLine("   Example: find-tests --method \"MyApp.Services.UserService.GetUser\" --solution \"MyApp.sln\"");
-+    }
- }
-\ No newline at end of file
-diff --git a/src/TestIntelligence.CLI/TestIntelligence.CLI.csproj b/src/TestIntelligence.CLI/TestIntelligence.CLI.csproj
-index c25bbd3..259c88d 100644
---- a/src/TestIntelligence.CLI/TestIntelligence.CLI.csproj
-+++ b/src/TestIntelligence.CLI/TestIntelligence.CLI.csproj
-@@ -27,6 +27,8 @@
-     <PackageReference Include="Microsoft.Extensions.Logging" Version="8.0.0" />
-     <PackageReference Include="Microsoft.Extensions.Logging.Console" Version="8.0.0" />
-     <PackageReference Include="Microsoft.Build.Locator" Version="1.6.10" />
-+    <!-- Explicit reference to resolve conflicts -->
-+    <PackageReference Include="Microsoft.Bcl.AsyncInterfaces" Version="8.0.0" />
-   </ItemGroup>
- 
-   <ItemGroup>
-diff --git a/src/TestIntelligence.Core/Models/TestCoverageInfo.cs b/src/TestIntelligence.Core/Models/TestCoverageInfo.cs
-index a7b865a..0f50511 100644
---- a/src/TestIntelligence.Core/Models/TestCoverageInfo.cs
-+++ b/src/TestIntelligence.Core/Models/TestCoverageInfo.cs
-@@ -192,10 +192,15 @@ namespace TestIntelligence.Core.Models
-             if (fullMethodId.Equals(pattern, StringComparison.OrdinalIgnoreCase))
-                 return true;
- 
--            // Extract method name without parameters from full ID
-+            // Remove global:: prefix if present for comparison
-+            var normalizedMethodId = fullMethodId.StartsWith("global::", StringComparison.OrdinalIgnoreCase) 
-+                ? fullMethodId.Substring(8) // Remove "global::" prefix
-+                : fullMethodId;
-+
-+            // Extract method name without parameters from normalized ID
-             // Format: Namespace.Class.Method(params)
--            var parenIndex = fullMethodId.IndexOf('(');
--            var methodWithoutParams = parenIndex > 0 ? fullMethodId.Substring(0, parenIndex) : fullMethodId;
-+            var parenIndex = normalizedMethodId.IndexOf('(');
-+            var methodWithoutParams = parenIndex > 0 ? normalizedMethodId.Substring(0, parenIndex) : normalizedMethodId;
- 
-             // Check if pattern matches the method without parameters
-             if (methodWithoutParams.Equals(pattern, StringComparison.OrdinalIgnoreCase))
-diff --git a/src/TestIntelligence.Core/TestIntelligence.Core.csproj b/src/TestIntelligence.Core/TestIntelligence.Core.csproj
-index 1cbbd22..3c05933 100644
---- a/src/TestIntelligence.Core/TestIntelligence.Core.csproj
-+++ b/src/TestIntelligence.Core/TestIntelligence.Core.csproj
-@@ -23,7 +23,7 @@
-     <PackageReference Include="System.Reflection.Metadata" Version="8.0.0" />
-     <PackageReference Include="System.Runtime.Loader" Version="4.3.0" />
-     <PackageReference Include="System.Reflection.MetadataLoadContext" Version="8.0.0" />
--    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="6.0.4" />
-+    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="8.0.0" />
-     <PackageReference Include="System.Text.Json" Version="8.0.5" />
-   </ItemGroup>
- 
-diff --git a/src/TestIntelligence.DataTracker/TestIntelligence.DataTracker.csproj b/src/TestIntelligence.DataTracker/TestIntelligence.DataTracker.csproj
-index 5440411..dfbdb37 100644
---- a/src/TestIntelligence.DataTracker/TestIntelligence.DataTracker.csproj
-+++ b/src/TestIntelligence.DataTracker/TestIntelligence.DataTracker.csproj
-@@ -19,7 +19,7 @@
-   </PropertyGroup>
- 
-   <ItemGroup>
--    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="6.0.4" />
-+    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="8.0.0" />
-     <!-- Entity Framework packages for database pattern detection -->
-     <PackageReference Include="Microsoft.EntityFrameworkCore" Version="3.1.32" />
-     <PackageReference Include="EntityFramework" Version="6.4.4" />
-diff --git a/src/TestIntelligence.ImpactAnalyzer/Analysis/LazyWorkspaceBuilder.cs b/src/TestIntelligence.ImpactAnalyzer/Analysis/LazyWorkspaceBuilder.cs
-index d91c774..40a3d3c 100644
---- a/src/TestIntelligence.ImpactAnalyzer/Analysis/LazyWorkspaceBuilder.cs
-+++ b/src/TestIntelligence.ImpactAnalyzer/Analysis/LazyWorkspaceBuilder.cs
-@@ -138,23 +138,50 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
-         {
-             return await _projectCache.GetOrAdd(projectPath, async path =>
-             {
-+                CancellationTokenSource? timeoutCts = null;
-+                CancellationTokenSource? combinedCts = null;
-+                
-                 try
-                 {
-                     _logger.LogDebug("Loading project on-demand: {ProjectPath}", path);
-                     var startTime = DateTime.UtcNow;
- 
--                    var project = await _workspace.OpenProjectAsync(path);
-+                    // Add timeout to prevent hanging on project loading
-+                    timeoutCts = new CancellationTokenSource(TimeSpan.FromSeconds(15));
-+                    combinedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, timeoutCts.Token);
-+
-+                    var projectTask = _workspace.OpenProjectAsync(path);
-+                    var timeoutTask = Task.Delay(TimeSpan.FromSeconds(15), combinedCts.Token);
-+                    
-+                    var completedTask = await Task.WhenAny(projectTask, timeoutTask);
-+                    if (completedTask == timeoutTask)
-+                    {
-+                        _logger.LogWarning("Project loading timed out after 15 seconds: {ProjectPath}", path);
-+                        return null;
-+                    }
-+                    
-+                    var project = await projectTask;
-                     
-                     var elapsed = DateTime.UtcNow - startTime;
-                     _logger.LogDebug("Project loaded in {ElapsedMs}ms: {ProjectName}", elapsed.TotalMilliseconds, project.Name);
- 
-                     return project;
-                 }
-+                catch (OperationCanceledException) when (timeoutCts?.Token.IsCancellationRequested == true)
-+                {
-+                    _logger.LogWarning("Project loading timed out after 15 seconds: {ProjectPath}", path);
-+                    return null;
-+                }
-                 catch (Exception ex)
-                 {
-                     _logger.LogError(ex, "Failed to load project: {ProjectPath}", path);
-                     return null;
-                 }
-+                finally
-+                {
-+                    timeoutCts?.Dispose();
-+                    combinedCts?.Dispose();
-+                }
-             });
-         }
- 
-@@ -291,8 +318,32 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
-         {
-             _logger.LogDebug("Loading solution metadata: {SolutionPath}", solutionPath);
-             
--            // Load solution directly - we'll manage project loading separately
--            _solution = await _workspace.OpenSolutionAsync(solutionPath);
-+            // Load solution directly with timeout to prevent hanging
-+            using var timeoutCts = new CancellationTokenSource(TimeSpan.FromSeconds(30));
-+            using var combinedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, timeoutCts.Token);
-+            
-+            try
-+            {
-+                var solutionTask = _workspace.OpenSolutionAsync(solutionPath);
-+                var timeoutTask = Task.Delay(TimeSpan.FromSeconds(30), combinedCts.Token);
-+                
-+                var completedTask = await Task.WhenAny(solutionTask, timeoutTask);
-+                if (completedTask == timeoutTask)
-+                {
-+                    _logger.LogWarning("Solution loading timed out after 30 seconds, falling back to manual solution parsing");
-+                    await InitializeFromSolutionManuallyAsync(solutionPath, cancellationToken);
-+                    return;
-+                }
-+                
-+                _solution = await solutionTask;
-+            }
-+            catch (OperationCanceledException) when (timeoutCts.Token.IsCancellationRequested)
-+            {
-+                _logger.LogWarning("Solution loading timed out after 30 seconds, falling back to manual solution parsing");
-+                await InitializeFromSolutionManuallyAsync(solutionPath, cancellationToken);
-+                return;
-+            }
-+            
-             var solutionInfo = _solution;
- 
-             // Build file-to-project mapping from solution
-@@ -336,6 +387,70 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
-             }
-         }
- 
-+        /// <summary>
-+        /// Manual solution parsing fallback when MSBuild workspace fails
-+        /// </summary>
-+        private async Task InitializeFromSolutionManuallyAsync(string solutionPath, CancellationToken cancellationToken)
-+        {
-+            try
-+            {
-+                _logger.LogInformation("Using manual solution parsing for: {SolutionPath}", solutionPath);
-+                
-+                // Parse solution file manually to get project paths
-+                var solutionDir = Path.GetDirectoryName(solutionPath)!;
-+                var solutionLines = await File.ReadAllLinesAsync(solutionPath, cancellationToken);
-+                
-+                var projectPaths = new List<string>();
-+                foreach (var line in solutionLines)
-+                {
-+                    // Look for project lines: Project("{...}") = "ProjectName", "RelativePath", "{...}"
-+                    if (line.StartsWith("Project(") && line.Contains(".csproj"))
-+                    {
-+                        var parts = line.Split(',');
-+                        if (parts.Length >= 2)
-+                        {
-+                            var relativePath = parts[1].Trim().Trim('"');
-+                            var fullPath = Path.GetFullPath(Path.Combine(solutionDir, relativePath));
-+                            if (File.Exists(fullPath))
-+                            {
-+                                projectPaths.Add(fullPath);
-+                            }
-+                        }
-+                    }
-+                }
-+                
-+                _logger.LogInformation("Found {ProjectCount} projects via manual parsing", projectPaths.Count);
-+                
-+                // Build file-to-project mapping using file system scanning
-+                foreach (var projectPath in projectPaths)
-+                {
-+                    try
-+                    {
-+                        var projectDir = Path.GetDirectoryName(projectPath)!;
-+                        var csFiles = Directory.GetFiles(projectDir, "*.cs", SearchOption.AllDirectories)
-+                            .Where(f => !f.Contains("bin") && !f.Contains("obj") && !f.Contains("packages"));
-+                        
-+                        foreach (var file in csFiles)
-+                        {
-+                            _fileToProjectMap[file] = projectPath;
-+                        }
-+                    }
-+                    catch (Exception ex)
-+                    {
-+                        _logger.LogDebug(ex, "Failed to scan project directory: {ProjectPath}", projectPath);
-+                    }
-+                }
-+                
-+                _logger.LogInformation("Manual solution parsing completed: {ProjectCount} projects, {FileCount} file mappings", 
-+                    projectPaths.Count, _fileToProjectMap.Count);
-+            }
-+            catch (Exception ex)
-+            {
-+                _logger.LogError(ex, "Manual solution parsing failed for: {SolutionPath}", solutionPath);
-+                throw;
-+            }
-+        }
-+
-         private void OnWorkspaceFailed(object? sender, WorkspaceDiagnosticEventArgs e)
-         {
-             _logger.LogDebug("Workspace diagnostic: {Kind} - {Message}", e.Diagnostic.Kind, e.Diagnostic.Message);
-diff --git a/src/TestIntelligence.ImpactAnalyzer/Analysis/RoslynAnalyzer.cs b/src/TestIntelligence.ImpactAnalyzer/Analysis/RoslynAnalyzer.cs
-index 9648e81..9a182a8 100644
---- a/src/TestIntelligence.ImpactAnalyzer/Analysis/RoslynAnalyzer.cs
-+++ b/src/TestIntelligence.ImpactAnalyzer/Analysis/RoslynAnalyzer.cs
-@@ -62,7 +62,9 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
-                 // Initialize lazy workspace for much better performance
-                 await InitializeLazyWorkspaceAsync(solutionFile, cancellationToken).ConfigureAwait(false);
- 
--                if (_incrementalCallGraphBuilder != null)
-+                // TEMPORARY FIX: Disable incremental call graph builder due to placeholder implementation
-+                // The GetMethodIdsFromFile method returns empty lists, causing 0 methods to be analyzed
-+                if (false && _incrementalCallGraphBuilder != null)
-                 {
-                     _logger.LogInformation("Using high-performance incremental call graph builder");
-                     // For full solution analysis, we still need to analyze all files, but incrementally
-@@ -71,6 +73,7 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
-                 }
-                 
-                 // Fallback to legacy full analysis
-+                _logger.LogInformation("Using legacy call graph builder (incremental builder temporarily disabled)");
-                 await InitializeWorkspaceAsync(solutionFile, cancellationToken).ConfigureAwait(false);
- 
-                 if (_callGraphBuilder == null)
-diff --git a/src/TestIntelligence.ImpactAnalyzer/Analysis/SolutionWorkspaceBuilder.cs b/src/TestIntelligence.ImpactAnalyzer/Analysis/SolutionWorkspaceBuilder.cs
-index eb69959..b30e8e6 100644
---- a/src/TestIntelligence.ImpactAnalyzer/Analysis/SolutionWorkspaceBuilder.cs
-+++ b/src/TestIntelligence.ImpactAnalyzer/Analysis/SolutionWorkspaceBuilder.cs
-@@ -168,24 +168,37 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
-             try
-             {
-                 _logger.LogDebug("Loading solution using MSBuild workspace: {SolutionPath}", solutionPath);
--                var solution = await workspace.OpenSolutionAsync(solutionPath, cancellationToken: cancellationToken);
-                 
--                _logger.LogInformation("Solution loaded with {ProjectCount} projects", solution.Projects.Count());
-+                // Apply timeout to prevent hanging - MSBuild operations can hang indefinitely
-+                using var timeoutCts = new CancellationTokenSource(TimeSpan.FromMinutes(2)); // 2 minute timeout for solution loading
-+                using var combinedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, timeoutCts.Token);
-                 
--                // Log any diagnostics
--                foreach (var diagnostic in workspace.Diagnostics)
-+                try
-                 {
--                    if (diagnostic.Kind == WorkspaceDiagnosticKind.Failure)
--                    {
--                        _logger.LogWarning("Workspace diagnostic: {Message}", diagnostic.Message);
--                    }
--                    else
-+                    var solution = await workspace.OpenSolutionAsync(solutionPath, cancellationToken: combinedCts.Token);
-+                    
-+                    _logger.LogInformation("Solution loaded with {ProjectCount} projects", solution.Projects.Count());
-+                    
-+                    // Log any diagnostics
-+                    foreach (var diagnostic in workspace.Diagnostics)
-                     {
--                        _logger.LogDebug("Workspace diagnostic: {Message}", diagnostic.Message);
-+                        if (diagnostic.Kind == WorkspaceDiagnosticKind.Failure)
-+                        {
-+                            _logger.LogWarning("Workspace diagnostic: {Message}", diagnostic.Message);
-+                        }
-+                        else
-+                        {
-+                            _logger.LogDebug("Workspace diagnostic: {Message}", diagnostic.Message);
-+                        }
-                     }
-+                    
-+                    return solution;
-+                }
-+                catch (OperationCanceledException) when (timeoutCts.Token.IsCancellationRequested)
-+                {
-+                    _logger.LogError("Solution loading timed out after 2 minutes: {SolutionPath}", solutionPath);
-+                    throw new TimeoutException($"Solution loading timed out after 2 minutes. This may indicate MSBuild version conflicts or complex solution structure: {solutionPath}");
-                 }
--                
--                return solution;
-             }
-             catch (Exception ex)
-             {
-diff --git a/src/TestIntelligence.ImpactAnalyzer/Analysis/SymbolIndex.cs b/src/TestIntelligence.ImpactAnalyzer/Analysis/SymbolIndex.cs
-index aa9727c..12a61fa 100644
---- a/src/TestIntelligence.ImpactAnalyzer/Analysis/SymbolIndex.cs
-+++ b/src/TestIntelligence.ImpactAnalyzer/Analysis/SymbolIndex.cs
-@@ -283,12 +283,13 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
-                     var solutionContent = File.ReadAllText(solutionPath);
-                     
-                     // Simple regex to find project references in solution file
--                    var projectPattern = new Regex(@"Project\(.+\)\s*=\s*"".+"",\s*""([^""]+\.(?:cs|vb|fs)proj)""", RegexOptions.Compiled);
-+                    var projectPattern = new Regex(@"Project\(.+\)\s*=\s*"".+"",\s*""([^""]+\.(?:csproj|vbproj|fsproj))""", RegexOptions.Compiled);
-                     var matches = projectPattern.Matches(solutionContent);
-                     
-                     foreach (Match match in matches)
-                     {
--                        var projectPath = Path.Combine(solutionDir, match.Groups[1].Value);
-+                        var relativePath = match.Groups[1].Value.Replace('\\', Path.DirectorySeparatorChar);
-+                        var projectPath = Path.Combine(solutionDir, relativePath);
-                         if (File.Exists(projectPath))
-                         {
-                             var projectFiles = await GetSourceFilesFromProjectAsync(projectPath, cancellationToken);
-diff --git a/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs b/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs
-index b96e163..d7f075c 100644
---- a/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs
-+++ b/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs
-@@ -85,14 +85,39 @@ namespace TestIntelligence.ImpactAnalyzer.Services
-                 // Try to build call graph with MSBuild workspace first, fallback to assembly analysis
-                 try 
-                 {
-+                    // Apply timeout to prevent hanging during call graph building
-+                    using var timeoutCts = new CancellationTokenSource(TimeSpan.FromMinutes(3)); // 3 minute timeout
-+                    using var combinedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, timeoutCts.Token);
-+                    
-                     // Build the complete call graph using the solution path
-                     // The Roslyn analyzer will handle finding source files and prefer MSBuild workspace if .sln is provided
--                    callGraph = await _roslynAnalyzer.BuildCallGraphAsync(new[] { solutionPath }, cancellationToken);
-+                    callGraph = await _roslynAnalyzer.BuildCallGraphAsync(new[] { solutionPath }, combinedCts.Token);
-                     
-                     // Cache the result
-                     _cachedCallGraph = callGraph;
-                     _cachedSolutionPath = solutionPath;
-                 }
-+                catch (TimeoutException ex)
-+                {
-+                    _logger.LogWarning(ex, "Call graph building timed out after 3 minutes, falling back to assembly-based analysis");
-+                    
-+                    // Fallback: Try to analyze compiled assemblies instead
-+                    var assemblyPaths = FindTestAssembliesInSolution(solutionPath);
-+                    if (assemblyPaths.Any())
-+                    {
-+                        _logger.LogInformation("Found {AssemblyCount} test assemblies for fallback analysis", assemblyPaths.Count);
-+                        callGraph = await _roslynAnalyzer.BuildCallGraphAsync(assemblyPaths.ToArray(), cancellationToken);
-+                        
-+                        // Cache the result
-+                        _cachedCallGraph = callGraph;
-+                        _cachedSolutionPath = solutionPath;
-+                    }
-+                    else
-+                    {
-+                        _logger.LogWarning("No assemblies found for fallback analysis");
-+                        return new TestCoverageMap(new Dictionary<string, List<TestCoverageInfo>>(), DateTime.UtcNow, solutionPath);
-+                    }
-+                }
-                 catch (InvalidOperationException ex) when (ex.Message.Contains("System.CodeDom") || ex.Message.Contains("MSBuild workspace"))
-                 {
-                     _logger.LogWarning(ex, "MSBuild workspace failed, falling back to assembly-based analysis");
-@@ -536,6 +561,16 @@ namespace TestIntelligence.ImpactAnalyzer.Services
- 
-             var testMethods = _testClassifier.GetTestMethods(allMethods);
-             _logger.LogInformation("Found {TestMethodCount} test methods for streaming analysis", testMethods.Count);
-+            
-+            // Find actual method IDs that match the user's pattern
-+            var targetMethodIds = FindMatchingMethodIds(methodId, allMethods);
-+            _logger.LogDebug("Found {Count} target method IDs matching pattern: {Pattern}", targetMethodIds.Count, methodId);
-+            
-+            if (targetMethodIds.Count == 0)
-+            {
-+                _logger.LogWarning("No methods found matching pattern: {MethodId}", methodId);
-+                yield break;
-+            }
- 
-             // Process test methods and yield results as we find them
-             foreach (var testMethod in testMethods)
-@@ -545,10 +580,23 @@ namespace TestIntelligence.ImpactAnalyzer.Services
-                 TestCoverageInfo? result = null;
-                 try
-                 {
--                    var callPath = FindCallPath(testMethod.Id, methodId, callGraph);
--                    if (callPath != null && callPath.Any())
-+                    // Try to find call paths to any of the matching target methods
-+                    string[]? callPath = null;
-+                    string? matchedTargetMethodId = null;
-+                    
-+                    foreach (var targetId in targetMethodIds)
-                     {
--                        var confidence = CalculateConfidence(callPath, testMethod, callGraph.GetMethodInfo(methodId)!);
-+                        callPath = FindCallPath(testMethod.Id, targetId, callGraph);
-+                        if (callPath != null && callPath.Any())
-+                        {
-+                            matchedTargetMethodId = targetId;
-+                            break;
-+                        }
-+                    }
-+                    if (callPath != null && callPath.Any() && matchedTargetMethodId != null)
-+                    {
-+                        var targetMethodInfo = callGraph.GetMethodInfo(matchedTargetMethodId)!;
-+                        var confidence = CalculateConfidence(callPath, testMethod, targetMethodInfo);
-                         var testType = _testClassifier.ClassifyTestType(testMethod);
- 
-                         result = new TestCoverageInfo(
-@@ -616,5 +664,63 @@ namespace TestIntelligence.ImpactAnalyzer.Services
-             _pathCache.Clear();
-             _logger.LogDebug("Cleared all caches");
-         }
-+
-+        /// <summary>
-+        /// Find all method IDs in the call graph that match the given pattern.
-+        /// Handles global:: prefix and parameter variations.
-+        /// </summary>
-+        private List<string> FindMatchingMethodIds(string pattern, IReadOnlyList<MethodInfo> allMethods)
-+        {
-+            var matchingIds = new List<string>();
-+            
-+            foreach (var method in allMethods)
-+            {
-+                if (IsMethodPatternMatch(method.Id, pattern))
-+                {
-+                    matchingIds.Add(method.Id);
-+                }
-+            }
-+            
-+            return matchingIds;
-+        }
-+
-+        /// <summary>
-+        /// Determines if a method ID matches the given pattern.
-+        /// Supports pattern matching like the TestCoverageMap.IsMethodMatch method.
-+        /// </summary>
-+        private static bool IsMethodPatternMatch(string fullMethodId, string pattern)
-+        {
-+            if (string.IsNullOrEmpty(fullMethodId) || string.IsNullOrEmpty(pattern))
-+                return false;
-+
-+            // Exact match
-+            if (fullMethodId.Equals(pattern, StringComparison.OrdinalIgnoreCase))
-+                return true;
-+
-+            // Remove global:: prefix if present for comparison
-+            var normalizedMethodId = fullMethodId.StartsWith("global::", StringComparison.OrdinalIgnoreCase) 
-+                ? fullMethodId.Substring(8) // Remove "global::" prefix
-+                : fullMethodId;
-+
-+            // Extract method name without parameters from normalized ID
-+            // Format: Namespace.Class.Method(params)
-+            var parenIndex = normalizedMethodId.IndexOf('(');
-+            var methodWithoutParams = parenIndex > 0 ? normalizedMethodId.Substring(0, parenIndex) : normalizedMethodId;
-+
-+            // Check if pattern matches the method without parameters
-+            if (methodWithoutParams.Equals(pattern, StringComparison.OrdinalIgnoreCase))
-+                return true;
-+
-+            // Check if pattern is just the method name (last part after final dot)
-+            var lastDotIndex = methodWithoutParams.LastIndexOf('.');
-+            if (lastDotIndex >= 0 && lastDotIndex < methodWithoutParams.Length - 1)
-+            {
-+                var methodNameOnly = methodWithoutParams.Substring(lastDotIndex + 1);
-+                if (methodNameOnly.Equals(pattern, StringComparison.OrdinalIgnoreCase))
-+                    return true;
-+            }
-+
-+            return false;
-+        }
-     }
- }
-\ No newline at end of file
-diff --git a/src/TestIntelligence.ImpactAnalyzer/TestIntelligence.ImpactAnalyzer.csproj b/src/TestIntelligence.ImpactAnalyzer/TestIntelligence.ImpactAnalyzer.csproj
-index 66261c7..1cb2408 100644
---- a/src/TestIntelligence.ImpactAnalyzer/TestIntelligence.ImpactAnalyzer.csproj
-+++ b/src/TestIntelligence.ImpactAnalyzer/TestIntelligence.ImpactAnalyzer.csproj
-@@ -1,7 +1,7 @@
- <Project Sdk="Microsoft.NET.Sdk">
- 
-   <PropertyGroup>
--    <TargetFramework>netstandard2.0</TargetFramework>
-+    <TargetFramework>netstandard2.1</TargetFramework>
-     <LangVersion>latest</LangVersion>
-     <Nullable>enable</Nullable>
-     <PackageId>TestIntelligence.ImpactAnalyzer</PackageId>
-@@ -28,6 +28,8 @@
-     <!-- Other dependencies provided by Directory.Build.props: Microsoft.CodeAnalysis.CSharp, Newtonsoft.Json, System.Collections.Immutable, System.CodeDom -->
-     <PackageReference Include="System.Reflection.Metadata" Version="8.0.0" />
-     <PackageReference Include="System.Text.Json" Version="8.0.5" />
-+    <!-- Add explicit reference to fix MSBuild conflicts -->
-+    <PackageReference Include="Microsoft.Build.Framework" Version="17.9.5" ExcludeAssets="runtime" />
-   </ItemGroup>
- 
-   <ItemGroup>
-diff --git a/src/TestIntelligence.SelectionEngine/TestIntelligence.SelectionEngine.csproj b/src/TestIntelligence.SelectionEngine/TestIntelligence.SelectionEngine.csproj
-index 41ee1d0..3a1d337 100644
---- a/src/TestIntelligence.SelectionEngine/TestIntelligence.SelectionEngine.csproj
-+++ b/src/TestIntelligence.SelectionEngine/TestIntelligence.SelectionEngine.csproj
-@@ -1,7 +1,7 @@
- <Project Sdk="Microsoft.NET.Sdk">
- 
-   <PropertyGroup>
--    <TargetFramework>netstandard2.0</TargetFramework>
-+    <TargetFramework>netstandard2.1</TargetFramework>
-     <LangVersion>latest</LangVersion>
-     <Nullable>enable</Nullable>
-     <PackageId>TestIntelligence.SelectionEngine</PackageId>
-diff --git a/tests/TestIntelligence.SelectionEngine.Tests/Engine/TestSelectionEngineTests.cs b/tests/TestIntelligence.SelectionEngine.Tests/Engine/TestSelectionEngineTests.cs
-index d4d4c36..55b8911 100644
---- a/tests/TestIntelligence.SelectionEngine.Tests/Engine/TestSelectionEngineTests.cs
-+++ b/tests/TestIntelligence.SelectionEngine.Tests/Engine/TestSelectionEngineTests.cs
-@@ -205,5 +205,222 @@ namespace TestIntelligence.SelectionEngine.Tests.Engine
-         {
-             // Sample method for reflection
-         }
-+
-+        #region Integration Tests for ScoreTestsAsync
-+
-+        [Fact]
-+        public async Task ScoreTestsAsync_WithMixedTestTypes_ShouldPrioritizeBasedOnCategory()
-+        {
-+            var tests = new[]
-+            {
-+                CreateTestInfo("FastUnitTest", TestCategory.Unit, TimeSpan.FromMilliseconds(50), 0.0),
-+                CreateTestInfo("SlowIntegrationTest", TestCategory.Integration, TimeSpan.FromSeconds(2), 0.0),
-+                CreateTestInfo("DatabaseTest", TestCategory.Database, TimeSpan.FromSeconds(5), 0.0),
-+                CreateTestInfo("UITest", TestCategory.UI, TimeSpan.FromSeconds(10), 0.0)
-+            };
-+
-+            var engine = new TestSelectionEngine(_mockLogger.Object, new[] { _mockScoringAlgorithm.Object });
-+            
-+            // Configure mock to return different scores based on category
-+            _mockScoringAlgorithm.Setup(x => x.CalculateScoreAsync(It.IsAny<TestInfo>(), It.IsAny<TestScoringContext>(), It.IsAny<CancellationToken>()))
-+                .Returns<TestInfo, TestScoringContext, CancellationToken>((test, context, ct) => test.Category switch
-+                {
-+                    TestCategory.Unit => Task.FromResult(0.9), // Highest priority for unit tests
-+                    TestCategory.Integration => Task.FromResult(0.7),
-+                    TestCategory.Database => Task.FromResult(0.5),
-+                    TestCategory.UI => Task.FromResult(0.3), // Lowest priority for UI tests
-+                    _ => Task.FromResult(0.1)
-+                });
-+
-+            var scoredTests = await engine.ScoreTestsAsync(tests);
-+
-+            scoredTests.Should().HaveCount(4);
-+            scoredTests[0].TestMethod.GetDisplayName().Should().Contain("FastUnitTest");
-+            scoredTests[1].TestMethod.GetDisplayName().Should().Contain("SlowIntegrationTest");
-+            scoredTests[2].TestMethod.GetDisplayName().Should().Contain("DatabaseTest");
-+            scoredTests[3].TestMethod.GetDisplayName().Should().Contain("UITest");
-+        }
-+
-+        [Fact]
-+        public async Task ScoreTestsAsync_WithCodeChanges_ShouldBoostRelatedTests()
-+        {
-+            var changes = CreateCodeChangeSet();
-+            var tests = new[]
-+            {
-+                CreateTestInfo("UnrelatedTest", TestCategory.Unit, TimeSpan.FromMilliseconds(100)),
-+                CreateTestInfo("RelatedTest_MyMethod", TestCategory.Unit, TimeSpan.FromMilliseconds(100)),
-+                CreateTestInfo("RelatedTest_MyClass", TestCategory.Integration, TimeSpan.FromMilliseconds(500))
-+            };
-+
-+            var engine = new TestSelectionEngine(_mockLogger.Object, new[] { _mockScoringAlgorithm.Object });
-+            
-+            // Configure mock to boost scores for related tests
-+            _mockScoringAlgorithm.Setup(x => x.CalculateScoreAsync(It.IsAny<TestInfo>(), It.IsAny<TestScoringContext>(), It.IsAny<CancellationToken>()))
-+                .Returns<TestInfo, TestScoringContext, CancellationToken>((test, context, ct) =>
-+                {
-+                    if (test.TestMethod.GetDisplayName().Contains("Related"))
-+                        return Task.FromResult(0.9); // High score for related tests
-+                    return Task.FromResult(0.3); // Lower score for unrelated tests
-+                });
-+
-+            var scoredTests = await engine.ScoreTestsAsync(tests, changes);
-+
-+            scoredTests.Should().HaveCount(3);
-+            // Related tests should be scored higher and appear first
-+            scoredTests.Take(2).All(t => t.TestMethod.GetDisplayName().Contains("Related")).Should().BeTrue();
-+            scoredTests.Last().TestMethod.GetDisplayName().Should().Contain("UnrelatedTest");
-+        }
-+
-+        [Fact]
-+        public async Task ScoreTestsAsync_WithExecutionHistoryContext_ShouldConsiderReliability()
-+        {
-+            var tests = new[]
-+            {
-+                CreateTestInfo("FlakeyTest", TestCategory.Unit, TimeSpan.FromMilliseconds(100)),
-+                CreateTestInfo("ReliableTest", TestCategory.Unit, TimeSpan.FromMilliseconds(150)),
-+                CreateTestInfo("NewTest", TestCategory.Unit, TimeSpan.FromMilliseconds(80))
-+            };
-+
-+            // Simulate execution history for the tests
-+            var flakeyTest = tests[0];
-+            foreach(var result in new[]
-+            {
-+                new TestExecutionResult(false, TimeSpan.FromMilliseconds(100), DateTimeOffset.UtcNow.AddDays(-1)), // Failed
-+                new TestExecutionResult(true, TimeSpan.FromMilliseconds(95), DateTimeOffset.UtcNow.AddHours(-12)), // Passed
-+                new TestExecutionResult(false, TimeSpan.FromMilliseconds(110), DateTimeOffset.UtcNow.AddHours(-6)) // Failed
-+            }) { flakeyTest.ExecutionHistory.Add(result); }
-+
-+            var reliableTest = tests[1];
-+            foreach(var result in new[]
-+            {
-+                new TestExecutionResult(true, TimeSpan.FromMilliseconds(150), DateTimeOffset.UtcNow.AddDays(-1)), // Passed
-+                new TestExecutionResult(true, TimeSpan.FromMilliseconds(145), DateTimeOffset.UtcNow.AddHours(-12)), // Passed
-+                new TestExecutionResult(true, TimeSpan.FromMilliseconds(155), DateTimeOffset.UtcNow.AddHours(-6)) // Passed
-+            }) { reliableTest.ExecutionHistory.Add(result); }
-+
-+            var engine = new TestSelectionEngine(_mockLogger.Object, new[] { _mockScoringAlgorithm.Object });
-+            
-+            // Configure mock to factor in reliability
-+            _mockScoringAlgorithm.Setup(x => x.CalculateScoreAsync(It.IsAny<TestInfo>(), It.IsAny<TestScoringContext>(), It.IsAny<CancellationToken>()))
-+                .Returns<TestInfo, TestScoringContext, CancellationToken>((test, context, ct) =>
-+                {
-+                    if (test.TestMethod.GetDisplayName().Contains("Reliable"))
-+                        return Task.FromResult(0.9); // High score for reliable tests
-+                    if (test.TestMethod.GetDisplayName().Contains("Flakey"))
-+                        return Task.FromResult(0.4); // Lower score for flakey tests
-+                    return Task.FromResult(0.7); // Medium score for new tests
-+                });
-+
-+            var scoredTests = await engine.ScoreTestsAsync(tests);
-+
-+            scoredTests.Should().HaveCount(3);
-+            scoredTests[0].TestMethod.GetDisplayName().Should().Contain("ReliableTest");
-+            scoredTests[1].TestMethod.GetDisplayName().Should().Contain("NewTest");
-+            scoredTests[2].TestMethod.GetDisplayName().Should().Contain("FlakeyTest");
-+        }
-+
-+        [Fact]
-+        public async Task ScoreTestsAsync_WithLargeTestSuite_ShouldHandlePerformantly()
-+        {
-+            // Create a large number of tests to verify performance
-+            var tests = Enumerable.Range(1, 1000)
-+                .Select(i => CreateTestInfo($"Test_{i:D4}", 
-+                    (TestCategory)(i % 4), // Distribute across categories
-+                    TimeSpan.FromMilliseconds(50 + (i % 200)), // Vary execution times
-+                    0.0))
-+                .ToArray();
-+
-+            var engine = new TestSelectionEngine(_mockLogger.Object, new[] { _mockScoringAlgorithm.Object });
-+            
-+            _mockScoringAlgorithm.Setup(x => x.CalculateScoreAsync(It.IsAny<TestInfo>(), It.IsAny<TestScoringContext>(), It.IsAny<CancellationToken>()))
-+                .Returns<TestInfo, TestScoringContext, CancellationToken>((test, context, ct) =>
-+                {
-+                    // Simulate varying scoring based on test name hash
-+                    var hash = test.TestMethod.GetDisplayName().GetHashCode();
-+                    var score = (Math.Abs(hash) % 100) / 100.0; // Score between 0.0 and 1.0
-+                    return Task.FromResult(score);
-+                });
-+
-+            var stopwatch = System.Diagnostics.Stopwatch.StartNew();
-+            var scoredTests = await engine.ScoreTestsAsync(tests);
-+            stopwatch.Stop();
-+
-+            scoredTests.Should().HaveCount(1000);
-+            scoredTests.Should().BeInDescendingOrder(t => t.SelectionScore);
-+            
-+            // Performance assertion - should complete within reasonable time
-+            stopwatch.ElapsedMilliseconds.Should().BeLessThan(5000, "scoring 1000 tests should complete within 5 seconds");
-+            
-+            // Verify all tests have been scored
-+            scoredTests.All(t => t.SelectionScore > 0).Should().BeTrue();
-+        }
-+
-+        [Theory]
-+        [InlineData(ConfidenceLevel.Fast)]
-+        [InlineData(ConfidenceLevel.Medium)]
-+        [InlineData(ConfidenceLevel.High)]
-+        [InlineData(ConfidenceLevel.Full)]
-+        public async Task ScoreTestsAsync_WithDifferentConfidenceLevels_ShouldAdjustScoring(ConfidenceLevel confidence)
-+        {
-+            var tests = new[]
-+            {
-+                CreateTestInfo("UnitTest", TestCategory.Unit, TimeSpan.FromMilliseconds(50)),
-+                CreateTestInfo("IntegrationTest", TestCategory.Integration, TimeSpan.FromSeconds(1)),
-+                CreateTestInfo("E2ETest", TestCategory.UI, TimeSpan.FromSeconds(10))
-+            };
-+
-+            var changes = CreateCodeChangeSet();
-+            var engine = new TestSelectionEngine(_mockLogger.Object, new[] { _mockScoringAlgorithm.Object });
-+            
-+            // Configure scoring based on confidence level
-+            _mockScoringAlgorithm.Setup(x => x.CalculateScoreAsync(It.IsAny<TestInfo>(), It.IsAny<TestScoringContext>(), It.IsAny<CancellationToken>()))
-+                .Returns<TestInfo, TestScoringContext, CancellationToken>((test, context, ct) =>
-+                {
-+                    var baseScore = test.Category switch
-+                    {
-+                        TestCategory.Unit => 0.8,
-+                        TestCategory.Integration => 0.6,
-+                        TestCategory.UI => 0.4,
-+                        _ => 0.2
-+                    };
-+
-+                    // Boost score based on confidence level
-+                    var confidenceMultiplier = context.ConfidenceLevel switch
-+                    {
-+                        ConfidenceLevel.Fast => test.Category == TestCategory.Unit ? 1.2 : 0.8,
-+                        ConfidenceLevel.Medium => test.Category <= TestCategory.Integration ? 1.1 : 0.9,
-+                        ConfidenceLevel.High => 1.0,
-+                        ConfidenceLevel.Full => 1.0,
-+                        _ => 1.0
-+                    };
-+
-+                    return Task.FromResult(baseScore * confidenceMultiplier);
-+                });
-+
-+            var scoredTests = await engine.ScoreTestsAsync(tests, changes);
-+
-+            scoredTests.Should().HaveCount(3);
-+            scoredTests.Should().BeInDescendingOrder(t => t.SelectionScore);
-+            
-+            // Verify confidence-specific behavior
-+            switch (confidence)
-+            {
-+                case ConfidenceLevel.Fast:
-+                    // Should prioritize unit tests
-+                    scoredTests[0].Category.Should().Be(TestCategory.Unit);
-+                    break;
-+                case ConfidenceLevel.Medium:
-+                    // Should include unit and integration tests with good scores
-+                    scoredTests.Take(2).All(t => t.Category <= TestCategory.Integration).Should().BeTrue();
-+                    break;
-+                case ConfidenceLevel.High:
-+                case ConfidenceLevel.Full:
-+                    // Should include all test types
-+                    scoredTests.Should().Contain(t => t.Category == TestCategory.UI);
-+                    break;
-+            }
-+        }
-+
-+        #endregion
-     }
- }
-\ No newline at end of file
diff --git a/src/TestIntelligence.API/Controllers/TestSelectionController.cs b/src/TestIntelligence.API/Controllers/TestSelectionController.cs
index 8cd744b..872a80e 100644
--- a/src/TestIntelligence.API/Controllers/TestSelectionController.cs
+++ b/src/TestIntelligence.API/Controllers/TestSelectionController.cs
@@ -50,23 +50,24 @@ public class TestSelectionController : ControllerBase
 
             TestExecutionPlan plan;
             
+            var options = new TestSelectionOptions
+            {
+                MaxTestCount = request.MaxTests,
+                MaxExecutionTime = request.MaxExecutionTime,
+                ExcludedCategories = request.ExcludedCategories?.ToHashSet(),
+                IncludedCategories = request.IncludedCategories?.ToHashSet()
+            };
+
             if (request.CodeChanges != null && request.CodeChanges.Changes.Any())
             {
                 plan = await _selectionEngine.GetOptimalTestPlanAsync(
                     request.CodeChanges, 
                     request.ConfidenceLevel, 
+                    options,
                     cancellationToken).ConfigureAwait(false);
             }
             else
             {
-                var options = new TestSelectionOptions
-                {
-                    MaxTestCount = request.MaxTests,
-                    MaxExecutionTime = request.MaxExecutionTime,
-                    ExcludedCategories = request.ExcludedCategories?.ToHashSet(),
-                    IncludedCategories = request.IncludedCategories?.ToHashSet()
-                };
-                
                 plan = await _selectionEngine.GetTestPlanAsync(
                     request.ConfidenceLevel, 
                     options, 
@@ -102,6 +103,7 @@ public class TestSelectionController : ControllerBase
             var testPlan = await _selectionEngine.GetOptimalTestPlanAsync(
                 impactResult.CodeChanges,
                 request.ConfidenceLevel,
+                null,
                 cancellationToken).ConfigureAwait(false);
 
             var result = new DiffAnalysisResult
diff --git a/src/TestIntelligence.CLI/Commands/CommandFactory.cs b/src/TestIntelligence.CLI/Commands/CommandFactory.cs
index 40d3cd4..f18d4ba 100644
--- a/src/TestIntelligence.CLI/Commands/CommandFactory.cs
+++ b/src/TestIntelligence.CLI/Commands/CommandFactory.cs
@@ -122,7 +122,7 @@ namespace TestIntelligence.CLI.Commands
                 context.SetParameter("changes", changes);
                 context.SetParameter("confidence", confidence);
                 context.SetParameter("output", output);
-                context.SetParameter("maxTests", maxTests.HasValue ? (object)maxTests.Value : 0);
+                context.SetParameter("maxTests", maxTests.HasValue ? (object)maxTests.Value : (object)DBNull.Value);
                 context.SetParameter("maxTime", maxTime ?? string.Empty);
                 
                 var exitCode = await handler.ExecuteAsync(context);
diff --git a/src/TestIntelligence.CLI/Commands/SelectCommandHandler.cs b/src/TestIntelligence.CLI/Commands/SelectCommandHandler.cs
index 482503e..6b1c897 100644
--- a/src/TestIntelligence.CLI/Commands/SelectCommandHandler.cs
+++ b/src/TestIntelligence.CLI/Commands/SelectCommandHandler.cs
@@ -26,7 +26,8 @@ namespace TestIntelligence.CLI.Commands
             var changes = context.GetParameter<string[]>("changes") ?? Array.Empty<string>();
             var confidence = context.GetParameter<string>("confidence") ?? "Medium";
             var output = context.GetParameter<string>("output");
-            var maxTests = context.GetParameter<int?>("maxTests");
+            var maxTestsParam = context.GetParameter<object>("maxTests");
+            var maxTests = maxTestsParam is int intValue ? intValue : (int?)null;
             var maxTime = context.GetParameter<string>("maxTime");
 
             Logger.LogInformation("Selecting tests for path: {Path}", path);
diff --git a/src/TestIntelligence.CLI/Services/CoverageAnalysisService.cs b/src/TestIntelligence.CLI/Services/CoverageAnalysisService.cs
index c6236d2..20e1337 100644
--- a/src/TestIntelligence.CLI/Services/CoverageAnalysisService.cs
+++ b/src/TestIntelligence.CLI/Services/CoverageAnalysisService.cs
@@ -67,13 +67,10 @@ namespace TestIntelligence.CLI.Services
                 Console.WriteLine($"Solution: {solutionPath}");
                 Console.WriteLine($"Tests to analyze: {testIds.Count}");
                 
-                if (verbose)
+                Console.WriteLine("Test methods:");
+                foreach (var testId in testIds)
                 {
-                    Console.WriteLine("Test methods:");
-                    foreach (var testId in testIds)
-                    {
-                        Console.WriteLine($"  ‚Ä¢ {testId}");
-                    }
+                    Console.WriteLine($"  ‚Ä¢ {testId}");
                 }
                 
                 Console.WriteLine();
diff --git a/src/TestIntelligence.CLI/Services/SelectionService.cs b/src/TestIntelligence.CLI/Services/SelectionService.cs
index ee04395..771d18a 100644
--- a/src/TestIntelligence.CLI/Services/SelectionService.cs
+++ b/src/TestIntelligence.CLI/Services/SelectionService.cs
@@ -1,6 +1,8 @@
 using Microsoft.Extensions.Logging;
+using Microsoft.Extensions.Logging.Abstractions;
 using TestIntelligence.CLI.Models;
 using TestIntelligence.ImpactAnalyzer.Models;
+using TestIntelligence.SelectionEngine.Engine;
 using TestIntelligence.SelectionEngine.Interfaces;
 using TestIntelligence.SelectionEngine.Models;
 
@@ -12,16 +14,13 @@ namespace TestIntelligence.CLI.Services;
 public class SelectionService : ISelectionService
 {
     private readonly ILogger<SelectionService> _logger;
-    private readonly ITestSelectionEngine _selectionEngine;
     private readonly IOutputFormatter _outputFormatter;
 
     public SelectionService(
         ILogger<SelectionService> logger,
-        ITestSelectionEngine selectionEngine,
         IOutputFormatter outputFormatter)
     {
         _logger = logger ?? throw new ArgumentNullException(nameof(logger));
-        _selectionEngine = selectionEngine ?? throw new ArgumentNullException(nameof(selectionEngine));
         _outputFormatter = outputFormatter ?? throw new ArgumentNullException(nameof(outputFormatter));
     }
 
@@ -35,17 +34,20 @@ public class SelectionService : ISelectionService
 
             var confidenceLevel = ParseConfidenceLevel(confidence);
             var options = CreateSelectionOptions(maxTests, maxTime);
+
+            // Create a TestSelectionEngine instance with the solution path
+            var selectionEngine = new TestSelectionEngine(_logger as ILogger<TestSelectionEngine> ?? NullLogger<TestSelectionEngine>.Instance, solutionPath: path);
             
             TestExecutionPlan executionPlan;
 
             if (changes.Length > 0)
             {
                 var codeChangeSet = CreateCodeChangeSet(changes);
-                executionPlan = await _selectionEngine.GetOptimalTestPlanAsync(codeChangeSet, confidenceLevel);
+                executionPlan = await selectionEngine.GetOptimalTestPlanAsync(codeChangeSet, confidenceLevel, options);
             }
             else
             {
-                executionPlan = await _selectionEngine.GetTestPlanAsync(confidenceLevel, options);
+                executionPlan = await selectionEngine.GetTestPlanAsync(confidenceLevel, options);
             }
 
             var selectionResult = ConvertToSelectionResult(executionPlan, path, changes, confidence);
@@ -80,12 +82,43 @@ public class SelectionService : ISelectionService
 
         if (maxTests.HasValue)
         {
+            if (maxTests.Value <= 0)
+            {
+                throw new ArgumentException($"Max tests must be a positive number, but got: {maxTests.Value}", nameof(maxTests));
+            }
+            
+            if (maxTests.Value > 50000)
+            {
+                _logger.LogWarning("Very large max-tests value ({MaxTests}) specified, this may impact performance", maxTests.Value);
+            }
+            
             options.MaxTestCount = maxTests.Value;
+            _logger.LogInformation("Limiting selection to {MaxTests} tests", maxTests.Value);
         }
 
         if (!string.IsNullOrEmpty(maxTime))
         {
-            options.MaxExecutionTime = ParseTimeSpan(maxTime);
+            try
+            {
+                var timeSpan = ParseTimeSpan(maxTime);
+                
+                if (timeSpan <= TimeSpan.Zero)
+                {
+                    throw new ArgumentException($"Max time must be positive, but got: {maxTime}", nameof(maxTime));
+                }
+                
+                if (timeSpan > TimeSpan.FromHours(24))
+                {
+                    _logger.LogWarning("Very large max-time value ({MaxTime}) specified", maxTime);
+                }
+                
+                options.MaxExecutionTime = timeSpan;
+                _logger.LogInformation("Limiting execution time to {MaxTime}", timeSpan);
+            }
+            catch (Exception ex) when (!(ex is ArgumentException))
+            {
+                throw new ArgumentException($"Invalid time format: {maxTime}. Use formats like '30s', '5m', '1h'", nameof(maxTime), ex);
+            }
         }
 
         return options;
@@ -93,33 +126,50 @@ public class SelectionService : ISelectionService
 
     private TimeSpan ParseTimeSpan(string timeString)
     {
+        if (string.IsNullOrWhiteSpace(timeString))
+        {
+            throw new ArgumentException("Time string cannot be null or empty", nameof(timeString));
+        }
+
         var time = timeString.ToLower().Trim();
         
         if (time.EndsWith("s"))
         {
-            var seconds = int.Parse(time.Substring(0, time.Length - 1));
+            var valueString = time.Substring(0, time.Length - 1);
+            if (!int.TryParse(valueString, out var seconds) || seconds < 0)
+            {
+                throw new ArgumentException($"Invalid seconds value: '{valueString}'. Must be a non-negative integer");
+            }
             return TimeSpan.FromSeconds(seconds);
         }
         
         if (time.EndsWith("m"))
         {
-            var minutes = int.Parse(time.Substring(0, time.Length - 1));
+            var valueString = time.Substring(0, time.Length - 1);
+            if (!int.TryParse(valueString, out var minutes) || minutes < 0)
+            {
+                throw new ArgumentException($"Invalid minutes value: '{valueString}'. Must be a non-negative integer");
+            }
             return TimeSpan.FromMinutes(minutes);
         }
         
         if (time.EndsWith("h"))
         {
-            var hours = int.Parse(time.Substring(0, time.Length - 1));
+            var valueString = time.Substring(0, time.Length - 1);
+            if (!int.TryParse(valueString, out var hours) || hours < 0)
+            {
+                throw new ArgumentException($"Invalid hours value: '{valueString}'. Must be a non-negative integer");
+            }
             return TimeSpan.FromHours(hours);
         }
 
         // Try to parse as seconds if no suffix
-        if (int.TryParse(time, out var totalSeconds))
+        if (int.TryParse(time, out var totalSeconds) && totalSeconds >= 0)
         {
             return TimeSpan.FromSeconds(totalSeconds);
         }
 
-        throw new ArgumentException($"Invalid time format: {timeString}. Use formats like '30s', '5m', '1h'");
+        throw new ArgumentException($"Invalid time format: '{timeString}'. Use formats like '30s', '5m', '1h', or plain seconds");
     }
 
     private CodeChangeSet CreateCodeChangeSet(string[] changes)
diff --git a/src/TestIntelligence.Core/Assembly/CrossFrameworkAssemblyLoader.cs b/src/TestIntelligence.Core/Assembly/CrossFrameworkAssemblyLoader.cs
index c025d2d..d897faa 100644
--- a/src/TestIntelligence.Core/Assembly/CrossFrameworkAssemblyLoader.cs
+++ b/src/TestIntelligence.Core/Assembly/CrossFrameworkAssemblyLoader.cs
@@ -403,4 +403,4 @@ namespace TestIntelligence.Core.Assembly
             }
         }
     }
-}
\ No newline at end of file
+}// Test change for coverage analysis
diff --git a/src/TestIntelligence.DataTracker/TestDataDependencyTracker.cs b/src/TestIntelligence.DataTracker/TestDataDependencyTracker.cs
index 9d88644..02825aa 100644
--- a/src/TestIntelligence.DataTracker/TestDataDependencyTracker.cs
+++ b/src/TestIntelligence.DataTracker/TestDataDependencyTracker.cs
@@ -412,5 +412,10 @@ namespace TestIntelligence.DataTracker
 
         public int TotalTestPairs => CanRunInParallel.Count + MustRunSequentially.Count;
         public double ParallelExecutionRatio => TotalTestPairs > 0 ? (double)CanRunInParallel.Count / TotalTestPairs : 0;
+        
+        /// <summary>
+        /// Test method to validate coverage analysis functionality.
+        /// </summary>
+        public bool HasConflicts() => MustRunSequentially.Count > 0;
     }
-}
\ No newline at end of file
+}// Coverage test modification
diff --git a/src/TestIntelligence.ImpactAnalyzer/Analysis/CallGraphBuilderV2.cs b/src/TestIntelligence.ImpactAnalyzer/Analysis/CallGraphBuilderV2.cs
index 86c0436..d1d7084 100644
--- a/src/TestIntelligence.ImpactAnalyzer/Analysis/CallGraphBuilderV2.cs
+++ b/src/TestIntelligence.ImpactAnalyzer/Analysis/CallGraphBuilderV2.cs
@@ -48,13 +48,29 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
             var callGraph = new ConcurrentDictionary<string, HashSet<string>>();
             var methodDefinitions = new ConcurrentDictionary<string, MethodInfo>();
 
-            // Process files in parallel for better performance
+            // Process files with enhanced error handling and optional parallelism
+            var concurrencyLevel = Environment.ProcessorCount; // Limit concurrency to avoid race conditions
+            var semaphore = new SemaphoreSlim(concurrencyLevel, concurrencyLevel);
+            
             var tasks = allSourceFiles.Select(async filePath =>
             {
-                await ProcessFileAsync(filePath, callGraph, methodDefinitions, cancellationToken);
+                await semaphore.WaitAsync(cancellationToken);
+                try
+                {
+                    await ProcessFileAsync(filePath, callGraph, methodDefinitions, cancellationToken);
+                }
+                catch (Exception ex)
+                {
+                    _logger.LogWarning(ex, "Failed to process file {FilePath} during call graph building", filePath);
+                }
+                finally
+                {
+                    semaphore.Release();
+                }
             });
 
             await Task.WhenAll(tasks);
+            semaphore.Dispose();
 
             // Convert concurrent collections to regular collections
             var finalCallGraph = callGraph.ToDictionary(
@@ -70,6 +86,17 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
             _logger.LogInformation("Call graph built successfully: {MethodCount} methods, {CallCount} total calls", 
                 finalMethodDefinitions.Count, finalCallGraph.Values.Sum(calls => calls.Count));
 
+            // Debug logging for specific methods we're interested in
+            foreach (var method in finalCallGraph.Keys.Where(k => k.Contains("ScoreTestsAsync")))
+            {
+                var calls = finalCallGraph[method];
+                var scoreTestsAsyncCalls = calls.Where(c => c.Contains("ScoreTestsAsync")).ToList();
+                if (scoreTestsAsyncCalls.Any())
+                {
+                    _logger.LogDebug("Method {Method} calls ScoreTestsAsync methods: {Calls}", method, string.Join(", ", scoreTestsAsyncCalls));
+                }
+            }
+
             return new MethodCallGraph(finalCallGraph, finalMethodDefinitions);
         }
 
@@ -154,6 +181,20 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
             var methodId = _symbolResolver.GetFullyQualifiedMethodName(methodSymbol);
             var isTest = IsTestMethod(methodSymbol, method);
             
+            // Debug logging for specific methods we're tracking
+            if (methodSymbol.Name.Contains("ScoreTestsAsync"))
+            {
+                _logger.LogDebug("Processing method: {MethodId} (isTest: {IsTest}) in {FilePath}", 
+                    methodId, isTest, filePath);
+                
+                // Additional console debug output for better visibility
+                if (isTest)
+                {
+                    System.Console.WriteLine($"DEBUG: Identified test method: {methodSymbol.Name}");
+                    System.Console.WriteLine($"  - Full ID: {methodId}");
+                }
+            }
+            
             var methodInfo = new MethodInfo(
                 methodId,
                 methodSymbol.Name,
@@ -183,7 +224,7 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
                 callGraph[methodId].Add(methodCall.CalledMethodId);
 
                 // Debug logging for specific methods we're interested in tracking
-                if (methodSymbol.Name == "ToString" || methodCall.CalledMethodId.Contains("ToString"))
+                if (methodSymbol.Name.Contains("ScoreTestsAsync") || methodCall.CalledMethodId.Contains("ScoreTestsAsync"))
                 {
                     _logger.LogDebug("Method {CallerMethod} calls {CalledMethod} via {CallType} at line {LineNumber}", 
                         methodId, methodCall.CalledMethodId, methodCall.CallType, methodCall.LineNumber);
diff --git a/src/TestIntelligence.ImpactAnalyzer/Analysis/EnhancedMethodCallVisitor.cs b/src/TestIntelligence.ImpactAnalyzer/Analysis/EnhancedMethodCallVisitor.cs
index 96ee417..811f87f 100644
--- a/src/TestIntelligence.ImpactAnalyzer/Analysis/EnhancedMethodCallVisitor.cs
+++ b/src/TestIntelligence.ImpactAnalyzer/Analysis/EnhancedMethodCallVisitor.cs
@@ -83,6 +83,29 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
 
                     _logger.LogTrace("Found method call: {MethodId} at line {LineNumber}", methodId, lineNumber);
                 }
+                else
+                {
+                    // Enhanced fallback: try direct semantic model resolution
+                    var fallbackSymbol = TryFallbackSymbolResolution(node);
+                    if (fallbackSymbol != null)
+                    {
+                        var methodId = _symbolResolver.GetFullyQualifiedMethodName(fallbackSymbol);
+                        var callType = DetermineCallType(node, fallbackSymbol);
+                        var lineNumber = node.GetLocation().GetLineSpan().StartLinePosition.Line + 1;
+                        var callExpression = node.ToString();
+
+                        var callInfo = new MethodCallInfo(methodId, callExpression, lineNumber, callType);
+                        _methodCalls.Add(callInfo);
+
+                        _logger.LogTrace("Found method call via fallback: {MethodId} at line {LineNumber}", methodId, lineNumber);
+                    }
+                    else
+                    {
+                        var lineNumber = node.GetLocation().GetLineSpan().StartLinePosition.Line + 1;
+                        _logger.LogDebug("Could not resolve method call '{CallExpression}' at line {LineNumber} in {FilePath}", 
+                            node.ToString(), lineNumber, _filePath);
+                    }
+                }
             }
             catch (Exception ex)
             {
@@ -325,5 +348,58 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
             return memberAccess.Parent is InvocationExpressionSyntax invocation && 
                    invocation.Expression == memberAccess;
         }
+
+        private IMethodSymbol? TryFallbackSymbolResolution(InvocationExpressionSyntax invocation)
+        {
+            try
+            {
+                // Direct semantic model approach as fallback
+                var symbolInfo = _semanticModel.GetSymbolInfo(invocation);
+                
+                // Try direct symbol first
+                if (symbolInfo.Symbol is IMethodSymbol directMethod)
+                {
+                    return directMethod;
+                }
+                
+                // Try all candidate symbols
+                foreach (var candidate in symbolInfo.CandidateSymbols.OfType<IMethodSymbol>())
+                {
+                    return candidate; // Take the first viable candidate
+                }
+                
+                // Try resolving through type information
+                if (invocation.Expression is MemberAccessExpressionSyntax memberAccess)
+                {
+                    var typeInfo = _semanticModel.GetTypeInfo(memberAccess.Expression);
+                    if (typeInfo.Type != null)
+                    {
+                        var methodName = memberAccess.Name.Identifier.ValueText;
+                        var methods = typeInfo.Type.GetMembers(methodName).OfType<IMethodSymbol>();
+                        
+                        // Try to find a matching method by parameter count
+                        var argCount = invocation.ArgumentList?.Arguments.Count ?? 0;
+                        foreach (var method in methods)
+                        {
+                            if (method.Parameters.Length == argCount || method.Parameters.Any(p => p.IsOptional))
+                            {
+                                return method;
+                            }
+                        }
+                        
+                        // If no exact match, return the first method with the same name
+                        return methods.FirstOrDefault();
+                    }
+                }
+                
+                return null;
+            }
+            catch (Exception ex)
+            {
+                _logger.LogDebug(ex, "Fallback symbol resolution failed for invocation at line {LineNumber}",
+                    invocation.GetLocation().GetLineSpan().StartLinePosition.Line + 1);
+                return null;
+            }
+        }
     }
 }
\ No newline at end of file
diff --git a/src/TestIntelligence.ImpactAnalyzer/Analysis/GitDiffParser.cs b/src/TestIntelligence.ImpactAnalyzer/Analysis/GitDiffParser.cs
index 82772e8..3e417de 100644
--- a/src/TestIntelligence.ImpactAnalyzer/Analysis/GitDiffParser.cs
+++ b/src/TestIntelligence.ImpactAnalyzer/Analysis/GitDiffParser.cs
@@ -267,18 +267,8 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
                     }
                 }
 
-                // Extract variable names from assignments (related to changed logic)
-                var varMatches = VariableAssignmentPattern.Matches(line);
-                foreach (Match match in varMatches)
-                {
-                    var varName = match.Groups.Count > 2 && !string.IsNullOrEmpty(match.Groups[2].Value) ? 
-                        match.Groups[2].Value.Trim() : match.Groups[1].Value.Trim();
-                    if (!string.IsNullOrEmpty(varName) && IsValidMethodName(varName))
-                    {
-                        methodNames.Add($"Variable_{varName}"); // Prefix to distinguish variables
-                        _logger.LogDebug("Found variable assignment: {VarName}", varName);
-                    }
-                }
+                // Skip variable extraction as it creates noise in method detection
+                // Focus on actual method signatures and method calls only
             }
 
             return methodNames;
@@ -310,11 +300,23 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
 
         private static bool IsValidMethodName(string methodName)
         {
+            if (string.IsNullOrWhiteSpace(methodName))
+                return false;
+                
+            // Filter out common non-method patterns
+            if (methodName.StartsWith("Variable_", StringComparison.OrdinalIgnoreCase) ||
+                methodName.Contains("Regex", StringComparison.OrdinalIgnoreCase) ||
+                methodName.Length < 2 ||
+                methodName.All(char.IsDigit))
+                return false;
+                
             // Basic validation to filter out keywords and invalid identifiers
             var csharpKeywords = new HashSet<string>
             {
                 "if", "else", "while", "for", "foreach", "do", "switch", "case", "return", "break", "continue",
-                "try", "catch", "finally", "throw", "using", "namespace", "class", "interface", "struct", "enum"
+                "try", "catch", "finally", "throw", "using", "namespace", "class", "interface", "struct", "enum",
+                "var", "new", "this", "base", "null", "true", "false", "static", "public", "private", "protected",
+                "internal", "override", "virtual", "abstract", "sealed", "readonly", "const", "async", "await"
             };
 
             return !csharpKeywords.Contains(methodName.ToLower()) && 
diff --git a/src/TestIntelligence.ImpactAnalyzer/Analysis/MethodCallGraph.cs b/src/TestIntelligence.ImpactAnalyzer/Analysis/MethodCallGraph.cs
index 79128ee..4a37b92 100644
--- a/src/TestIntelligence.ImpactAnalyzer/Analysis/MethodCallGraph.cs
+++ b/src/TestIntelligence.ImpactAnalyzer/Analysis/MethodCallGraph.cs
@@ -112,6 +112,20 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
             var visited = new HashSet<string>();
             var paths = new Dictionary<string, List<string>>();
 
+            // Debug logging for ScoreTestsAsync method lookup
+            if (methodId.Contains("ScoreTestsAsync"))
+            {
+                System.Console.WriteLine($"DEBUG: Starting BFS for method: {methodId}");
+                var initialDependents = GetMethodDependents(methodId);
+                System.Console.WriteLine($"DEBUG: Initial dependents count: {initialDependents.Count}");
+                foreach (var dep in initialDependents)
+                {
+                    System.Console.WriteLine($"  - {dep}");
+                    var methodInfo = GetMethodInfo(dep);
+                    System.Console.WriteLine($"    IsTest: {methodInfo?.IsTestMethod}");
+                }
+            }
+
             // BFS to find all test methods that can reach the target method
             var queue = new Queue<(string methodId, List<string> path)>();
             queue.Enqueue((methodId, new List<string> { methodId }));
@@ -143,6 +157,12 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
                                 methodInfo.FilePath,
                                 newPath.ToArray(),
                                 confidence));
+                            
+                            // Debug logging for found tests
+                            if (methodId.Contains("ScoreTestsAsync"))
+                            {
+                                System.Console.WriteLine($"DEBUG: Found test method: {methodInfo.Name} (confidence: {confidence})");
+                            }
                         }
                         else
                         {
@@ -153,6 +173,16 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
                 }
             }
 
+            // Debug logging for final results
+            if (methodId.Contains("ScoreTestsAsync"))
+            {
+                System.Console.WriteLine($"DEBUG: Final results count: {results.Count}");
+                foreach (var result in results)
+                {
+                    System.Console.WriteLine($"  - {result.TestMethodName}");
+                }
+            }
+
             return results;
         }
 
@@ -172,6 +202,17 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
                 }
             }
 
+            // Debug logging for ScoreTestsAsync reverse graph entries
+            if (reverseGraph.ContainsKey("global::TestIntelligence.SelectionEngine.Engine.TestSelectionEngine.ScoreTestsAsync(global::System.Collections.Generic.IEnumerable<global::TestIntelligence.SelectionEngine.Models.TestInfo>,global::TestIntelligence.ImpactAnalyzer.Models.CodeChangeSet,global::System.Threading.CancellationToken)"))
+            {
+                var dependents = reverseGraph["global::TestIntelligence.SelectionEngine.Engine.TestSelectionEngine.ScoreTestsAsync(global::System.Collections.Generic.IEnumerable<global::TestIntelligence.SelectionEngine.Models.TestInfo>,global::TestIntelligence.ImpactAnalyzer.Models.CodeChangeSet,global::System.Threading.CancellationToken)"];
+                System.Console.WriteLine($"DEBUG: ScoreTestsAsync has {dependents.Count} dependents in reverse graph:");
+                foreach (var dependent in dependents)
+                {
+                    System.Console.WriteLine($"  - {dependent}");
+                }
+            }
+
             return reverseGraph;
         }
 
diff --git a/src/TestIntelligence.ImpactAnalyzer/Services/CodeChangeCoverageAnalyzer.cs b/src/TestIntelligence.ImpactAnalyzer/Services/CodeChangeCoverageAnalyzer.cs
index 00802cf..3d4b577 100644
--- a/src/TestIntelligence.ImpactAnalyzer/Services/CodeChangeCoverageAnalyzer.cs
+++ b/src/TestIntelligence.ImpactAnalyzer/Services/CodeChangeCoverageAnalyzer.cs
@@ -121,14 +121,61 @@ namespace TestIntelligence.ImpactAnalyzer.Services
             var providedTestCoverage = new List<TestCoverageInfo>();
             var testMethodIdSet = new HashSet<string>(testMethodIdList, StringComparer.OrdinalIgnoreCase);
             
+            // Debug: Log what test IDs we're looking for
+            _logger.LogInformation("Looking for test method IDs: {TestIds}", string.Join(", ", testMethodIdList));
+            
+            // Debug: Sample the first few test method IDs from the coverage map
+            var sampleTestIds = testCoverageMap.MethodToTests.Values
+                .SelectMany(coverage => coverage.Select(c => c.TestMethodId))
+                .Take(10)
+                .ToList();
+            _logger.LogInformation("Sample test method IDs from coverage map: {SampleIds}", string.Join(", ", sampleTestIds));
+            
             // Find all coverage relationships where the test method ID matches our provided tests
+            var exactMatches = new HashSet<string>();
+            var fuzzyMatches = new List<TestCoverageInfo>();
+            
             foreach (var kvp in testCoverageMap.MethodToTests)
             {
                 var coverageInfos = kvp.Value.Where(coverage => testMethodIdSet.Contains(coverage.TestMethodId));
                 providedTestCoverage.AddRange(coverageInfos);
+                
+                foreach (var coverage in coverageInfos)
+                {
+                    exactMatches.Add(coverage.TestMethodId);
+                }
+            }
+            
+            // If no exact matches found, try fuzzy matching
+            if (!exactMatches.Any())
+            {
+                _logger.LogWarning("No exact test method ID matches found, attempting fuzzy matching");
+                
+                foreach (var testId in testMethodIdList)
+                {
+                    var fuzzyMatchesForTest = FindFuzzyTestMatches(testId, testCoverageMap);
+                    fuzzyMatches.AddRange(fuzzyMatchesForTest);
+                    
+                    if (fuzzyMatchesForTest.Any())
+                    {
+                        _logger.LogInformation("Found fuzzy matches for '{TestId}': {FuzzyMatches}", 
+                            testId, string.Join(", ", fuzzyMatchesForTest.Select(p => p.TestMethodId)));
+                    }
+                    else
+                    {
+                        _logger.LogWarning("No matches (exact or fuzzy) found for test: '{TestId}'", testId);
+                    }
+                }
+                
+                // Use fuzzy matches if no exact matches were found
+                providedTestCoverage.AddRange(fuzzyMatches);
+            }
+            else
+            {
+                _logger.LogInformation("Found exact matches for test IDs: {ExactMatches}", string.Join(", ", exactMatches));
             }
 
-            _logger.LogDebug("Found {CoverageCount} coverage relationships for provided tests", providedTestCoverage.Count);
+            _logger.LogInformation("Found {CoverageCount} coverage relationships for provided tests", providedTestCoverage.Count);
 
             // Get all changed methods from the code changes
             var changedMethods = codeChanges.GetChangedMethods().ToList();
@@ -187,5 +234,49 @@ namespace TestIntelligence.ImpactAnalyzer.Services
 
             return matchingTests;
         }
+
+        /// <summary>
+        /// Attempts to find test methods using fuzzy matching when exact matches fail.
+        /// Tries different matching strategies including method name only, class.method, etc.
+        /// </summary>
+        private IReadOnlyList<TestCoverageInfo> FindFuzzyTestMatches(string testId, TestCoverageMap coverageMap)
+        {
+            var matches = new List<TestCoverageInfo>();
+            
+            // Strategy 1: Match by method name only (last part after final dot)
+            var methodNameOnly = testId.Split('.').LastOrDefault();
+            if (!string.IsNullOrEmpty(methodNameOnly))
+            {
+                var methodNameMatches = coverageMap.MethodToTests.Values
+                    .SelectMany(coverage => coverage)
+                    .Where(c => c.TestMethodName.Equals(methodNameOnly, StringComparison.OrdinalIgnoreCase))
+                    .ToList();
+                matches.AddRange(methodNameMatches);
+            }
+            
+            // Strategy 2: Match by class.method pattern (last two parts)
+            var parts = testId.Split('.');
+            if (parts.Length >= 2)
+            {
+                var classMethod = $"{parts[^2]}.{parts[^1]}";
+                var classMethodMatches = coverageMap.MethodToTests.Values
+                    .SelectMany(coverage => coverage)
+                    .Where(c => c.TestMethodId.EndsWith(classMethod, StringComparison.OrdinalIgnoreCase) ||
+                               $"{c.TestClassName.Split('.').LastOrDefault()}.{c.TestMethodName}".Equals(classMethod, StringComparison.OrdinalIgnoreCase))
+                    .ToList();
+                matches.AddRange(classMethodMatches);
+            }
+            
+            // Strategy 3: Partial substring matching
+            var substringMatches = coverageMap.MethodToTests.Values
+                .SelectMany(coverage => coverage)
+                .Where(c => c.TestMethodId.Contains(testId, StringComparison.OrdinalIgnoreCase) ||
+                           testId.Contains(c.TestMethodId, StringComparison.OrdinalIgnoreCase))
+                .ToList();
+            matches.AddRange(substringMatches);
+            
+            // Remove duplicates and return
+            return matches.GroupBy(m => m.TestMethodId).Select(g => g.First()).ToList();
+        }
     }
 }
\ No newline at end of file
diff --git a/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs b/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs
index 615f94d..a05b91b 100644
--- a/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs
+++ b/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs
@@ -569,6 +569,16 @@ namespace TestIntelligence.ImpactAnalyzer.Services
             var targetMethodIds = FindMatchingMethodIds(methodId, allMethods);
             _logger.LogDebug("Found {Count} target method IDs matching pattern: {Pattern}", targetMethodIds.Count, methodId);
             
+            // Additional console debug output for ScoreTestsAsync
+            if (methodId.Contains("ScoreTestsAsync"))
+            {
+                System.Console.WriteLine($"DEBUG STREAMING: Found {targetMethodIds.Count} target method IDs:");
+                foreach (var id in targetMethodIds)
+                {
+                    System.Console.WriteLine($"  - {id}");
+                }
+            }
+            
             if (targetMethodIds.Count == 0)
             {
                 _logger.LogWarning("No methods found matching pattern: {MethodId}", methodId);
diff --git a/src/TestIntelligence.SelectionEngine/Engine/TestSelectionEngine.cs b/src/TestIntelligence.SelectionEngine/Engine/TestSelectionEngine.cs
index 7347f64..68f4ea7 100644
--- a/src/TestIntelligence.SelectionEngine/Engine/TestSelectionEngine.cs
+++ b/src/TestIntelligence.SelectionEngine/Engine/TestSelectionEngine.cs
@@ -1,9 +1,12 @@
 using System;
 using System.Collections.Generic;
+using System.IO;
 using System.Linq;
 using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Extensions.Logging;
+using TestIntelligence.Core.Assembly;
+using TestIntelligence.Core.Discovery;
 using TestIntelligence.ImpactAnalyzer.Models;
 using TestIntelligence.SelectionEngine.Interfaces;
 using TestIntelligence.SelectionEngine.Models;
@@ -20,6 +23,7 @@ namespace TestIntelligence.SelectionEngine.Engine
         private readonly List<ITestScoringAlgorithm> _scoringAlgorithms;
         private readonly ITestCategorizer? _testCategorizer;
         private readonly IImpactAnalyzer? _impactAnalyzer;
+        private readonly string? _solutionPath;
 
         // In-memory storage for demonstration - in production this would be a database
         private readonly Dictionary<string, TestInfo> _testRepository;
@@ -29,11 +33,13 @@ namespace TestIntelligence.SelectionEngine.Engine
             ILogger<TestSelectionEngine> logger,
             IEnumerable<ITestScoringAlgorithm>? scoringAlgorithms = null,
             ITestCategorizer? testCategorizer = null,
-            IImpactAnalyzer? impactAnalyzer = null)
+            IImpactAnalyzer? impactAnalyzer = null,
+            string? solutionPath = null)
         {
             _logger = logger ?? throw new ArgumentNullException(nameof(logger));
             _testCategorizer = testCategorizer;
             _impactAnalyzer = impactAnalyzer;
+            _solutionPath = solutionPath;
             _testRepository = new Dictionary<string, TestInfo>();
             _executionHistory = new List<TestExecutionResult>();
 
@@ -52,12 +58,13 @@ namespace TestIntelligence.SelectionEngine.Engine
         public async Task<TestExecutionPlan> GetOptimalTestPlanAsync(
             CodeChangeSet changes, 
             ConfidenceLevel confidenceLevel, 
+            TestSelectionOptions? options = null,
             CancellationToken cancellationToken = default)
         {
             _logger.LogInformation("Creating optimal test plan for {ChangeCount} changes with {ConfidenceLevel} confidence", 
                 changes.Changes.Count, confidenceLevel);
 
-            var options = new TestSelectionOptions();
+            options ??= new TestSelectionOptions();
             return await GetTestPlanInternalAsync(changes, confidenceLevel, options, cancellationToken);
         }
 
@@ -164,18 +171,38 @@ namespace TestIntelligence.SelectionEngine.Engine
                     "No tests available");
             }
 
-            // Score all candidate tests
-            var context = new TestScoringContext(confidenceLevel, changes, options);
-            var scoredTests = new List<TestInfo>();
-
-            foreach (var test in candidateTests)
+            List<TestInfo> selectedTests;
+            
+            // For Full confidence, select ALL tests without scoring
+            if (confidenceLevel == ConfidenceLevel.Full)
             {
-                test.SelectionScore = await CalculateCombinedScore(test, context, cancellationToken);
-                scoredTests.Add(test);
+                _logger.LogInformation("Full confidence selected - including ALL {TestCount} tests", candidateTests.Count);
+                selectedTests = candidateTests;
+                
+                // Apply basic filtering for Full confidence (exclude flaky tests if requested)
+                if (!options.IncludeFlakyTests)
+                {
+                    selectedTests = selectedTests.Where(t => !t.IsFlaky()).ToList();
+                }
+                
+                // Apply category and tag filters if specified
+                selectedTests = ApplyBasicFilters(selectedTests, options);
             }
+            else
+            {
+                // Score all candidate tests for other confidence levels
+                var context = new TestScoringContext(confidenceLevel, changes, options);
+                var scoredTests = new List<TestInfo>();
 
-            // Select tests based on confidence level and constraints
-            var selectedTests = await SelectTestsForPlan(scoredTests, confidenceLevel, options, cancellationToken);
+                foreach (var test in candidateTests)
+                {
+                    test.SelectionScore = await CalculateCombinedScore(test, context, cancellationToken);
+                    scoredTests.Add(test);
+                }
+
+                // Select tests based on confidence level and constraints
+                selectedTests = await SelectTestsForPlan(scoredTests, confidenceLevel, options, cancellationToken);
+            }
 
             // Calculate total estimated duration
             var estimatedDuration = TimeSpan.FromMilliseconds(
@@ -198,12 +225,33 @@ namespace TestIntelligence.SelectionEngine.Engine
             TestSelectionOptions options,
             CancellationToken cancellationToken)
         {
-            // In production, this would query a test repository/database
-            // For now, return mock tests for demonstration
             var candidates = new List<TestInfo>();
 
-            // This is a simplified mock - in production, we'd have a proper test discovery service
-            await Task.CompletedTask;
+            try
+            {
+                // If we have a solution path, discover tests from it
+                if (!string.IsNullOrEmpty(_solutionPath))
+                {
+                    candidates = await DiscoverTestsFromSolution(_solutionPath, cancellationToken);
+                }
+                // If we don't have a solution path but have changes, try to infer from the first change path
+                else if (changes?.Changes.Count > 0)
+                {
+                    var firstChangePath = changes.Changes.First().FilePath;
+                    var solutionPath = FindSolutionFile(firstChangePath);
+                    if (!string.IsNullOrEmpty(solutionPath))
+                    {
+                        _logger.LogInformation("Inferred solution path from changes: {SolutionPath}", solutionPath);
+                        candidates = await DiscoverTestsFromSolution(solutionPath, cancellationToken);
+                    }
+                }
+
+                _logger.LogInformation("Discovered {CandidateCount} candidate tests", candidates.Count);
+            }
+            catch (Exception ex)
+            {
+                _logger.LogWarning(ex, "Error discovering candidate tests");
+            }
 
             return candidates;
         }
@@ -244,13 +292,177 @@ namespace TestIntelligence.SelectionEngine.Engine
             var sortedTests = scoredTests.OrderByDescending(t => t.SelectionScore).ToList();
 
             // Apply confidence level limits
-            var maxTests = Math.Min(
-                options.MaxTestCount ?? confidenceLevel.GetMaxTestCount(),
-                confidenceLevel.GetMaxTestCount());
+            var maxTests = options.MaxTestCount ?? confidenceLevel.GetMaxTestCount();
 
             var maxDuration = options.MaxExecutionTime ?? confidenceLevel.GetEstimatedDuration();
             var minScore = options.MinSelectionScore ?? GetMinScoreForConfidenceLevel(confidenceLevel);
 
+            var selectedTests = new List<TestInfo>();
+            
+            // For Fast confidence, use strategic category balance
+            if (confidenceLevel == ConfidenceLevel.Fast)
+            {
+                selectedTests = await SelectFastConfidenceTests(sortedTests, maxTests, maxDuration, minScore, options, cancellationToken);
+            }
+            else
+            {
+                // Standard selection for other confidence levels
+                selectedTests = SelectStandardTests(sortedTests, maxTests, maxDuration, minScore, options);
+            }
+
+            await Task.CompletedTask; // Placeholder for async operations
+
+            _logger.LogDebug("Selected {SelectedCount} tests out of {CandidateCount} candidates", 
+                selectedTests.Count, scoredTests.Count);
+
+            return selectedTests;
+        }
+
+        private static double GetMinScoreForConfidenceLevel(ConfidenceLevel confidenceLevel)
+        {
+            return confidenceLevel switch
+            {
+                ConfidenceLevel.Fast => 0.6,
+                ConfidenceLevel.Medium => 0.4,
+                ConfidenceLevel.High => 0.2,
+                ConfidenceLevel.Full => 0.0,
+                _ => 0.3
+            };
+        }
+
+        private static List<TestInfo> ApplyBasicFilters(List<TestInfo> tests, TestSelectionOptions options)
+        {
+            var filtered = tests.AsEnumerable();
+
+            // Apply category filters
+            if (options.ExcludedCategories?.Count > 0)
+            {
+                filtered = filtered.Where(t => !options.ExcludedCategories.Contains(t.Category));
+            }
+
+            if (options.IncludedCategories?.Count > 0)
+            {
+                filtered = filtered.Where(t => options.IncludedCategories.Contains(t.Category));
+            }
+
+            // Apply tag filters
+            if (options.ExcludedTags?.Count > 0)
+            {
+                filtered = filtered.Where(t => !t.Tags.Any(tag => options.ExcludedTags.Contains(tag)));
+            }
+
+            if (options.RequiredTags?.Count > 0)
+            {
+                filtered = filtered.Where(t => options.RequiredTags.Any(tag => t.Tags.Contains(tag)));
+            }
+
+            return filtered.ToList();
+        }
+
+        private Task<List<TestInfo>> SelectFastConfidenceTests(
+            List<TestInfo> sortedTests,
+            int maxTests,
+            TimeSpan maxDuration,
+            double minScore,
+            TestSelectionOptions options,
+            CancellationToken cancellationToken)
+        {
+            var selectedTests = new List<TestInfo>();
+            var currentDuration = TimeSpan.Zero;
+
+            // Strategy for Fast confidence: prioritize high-scoring tests with balanced categories
+            // 60% Unit tests (fast feedback), 40% Integration tests (broader coverage)
+            var unitTestLimit = Math.Max(1, (int)(maxTests * 0.6));
+            var integrationTestLimit = maxTests - unitTestLimit;
+            
+            var unitTestsSelected = 0;
+            var integrationTestsSelected = 0;
+
+            // Use a higher score threshold for Fast confidence to ensure quality
+            var fastMinScore = Math.Max(minScore, 0.8);
+
+            _logger.LogDebug("Fast selection: targeting {UnitLimit} unit tests, {IntegrationLimit} integration tests, min score {MinScore}",
+                unitTestLimit, integrationTestLimit, fastMinScore);
+
+            // First pass: select high-scoring tests with category balance
+            foreach (var test in sortedTests)
+            {
+                if (selectedTests.Count >= maxTests)
+                    break;
+
+                if (test.SelectionScore < fastMinScore)
+                    continue;
+
+                if (currentDuration + test.AverageExecutionTime > maxDuration)
+                    continue;
+
+                // Apply basic filters
+                if (!PassesBasicFilters(test, options))
+                    continue;
+
+                // Apply category limits for balanced selection
+                var canSelectTest = test.Category switch
+                {
+                    TestCategory.Unit when unitTestsSelected < unitTestLimit => true,
+                    TestCategory.Integration when integrationTestsSelected < integrationTestLimit => true,
+                    _ => false
+                };
+
+                if (canSelectTest)
+                {
+                    selectedTests.Add(test);
+                    currentDuration += test.AverageExecutionTime;
+                    test.LastSelected = DateTimeOffset.UtcNow;
+
+                    if (test.Category == TestCategory.Unit)
+                        unitTestsSelected++;
+                    else if (test.Category == TestCategory.Integration)
+                        integrationTestsSelected++;
+                }
+            }
+
+            // Second pass: fill remaining slots with highest scoring tests if we have capacity
+            if (selectedTests.Count < maxTests)
+            {
+                foreach (var test in sortedTests)
+                {
+                    if (selectedTests.Count >= maxTests)
+                        break;
+
+                    if (selectedTests.Contains(test))
+                        continue;
+
+                    if (test.SelectionScore < minScore) // Use original threshold for backfill
+                        continue;
+
+                    if (currentDuration + test.AverageExecutionTime > maxDuration)
+                        continue;
+
+                    if (!PassesBasicFilters(test, options))
+                        continue;
+
+                    selectedTests.Add(test);
+                    currentDuration += test.AverageExecutionTime;
+                    test.LastSelected = DateTimeOffset.UtcNow;
+                }
+            }
+
+            _logger.LogInformation("Fast selection: selected {Total} tests ({Unit} unit, {Integration} integration, {Other} other)",
+                selectedTests.Count,
+                selectedTests.Count(t => t.Category == TestCategory.Unit),
+                selectedTests.Count(t => t.Category == TestCategory.Integration),
+                selectedTests.Count(t => t.Category != TestCategory.Unit && t.Category != TestCategory.Integration));
+
+            return Task.FromResult(selectedTests);
+        }
+
+        private List<TestInfo> SelectStandardTests(
+            List<TestInfo> sortedTests,
+            int maxTests,
+            TimeSpan maxDuration,
+            double minScore,
+            TestSelectionOptions options)
+        {
             var selectedTests = new List<TestInfo>();
             var currentDuration = TimeSpan.Zero;
 
@@ -266,52 +478,276 @@ namespace TestIntelligence.SelectionEngine.Engine
                 if (currentDuration + test.AverageExecutionTime > maxDuration)
                     continue; // Skip this test, try others
 
-                // Apply category filters
-                if (options.ExcludedCategories?.Contains(test.Category) == true)
+                if (!PassesBasicFilters(test, options))
                     continue;
 
-                if (options.IncludedCategories?.Count > 0 && 
-                    !options.IncludedCategories.Contains(test.Category))
-                    continue;
+                selectedTests.Add(test);
+                currentDuration += test.AverageExecutionTime;
+                test.LastSelected = DateTimeOffset.UtcNow;
+            }
 
-                // Apply tag filters
-                if (options.ExcludedTags?.Count > 0 && 
-                    test.Tags.Any(tag => options.ExcludedTags.Contains(tag)))
-                    continue;
+            return selectedTests;
+        }
 
-                if (options.RequiredTags?.Count > 0 && 
-                    !options.RequiredTags.Any(tag => test.Tags.Contains(tag)))
-                    continue;
+        private static bool PassesBasicFilters(TestInfo test, TestSelectionOptions options)
+        {
+            // Apply category filters
+            if (options.ExcludedCategories?.Contains(test.Category) == true)
+                return false;
 
-                // Apply flaky test filter
-                if (!options.IncludeFlakyTests && test.IsFlaky())
-                    continue;
+            if (options.IncludedCategories?.Count > 0 && 
+                !options.IncludedCategories.Contains(test.Category))
+                return false;
 
-                selectedTests.Add(test);
-                currentDuration += test.AverageExecutionTime;
+            // Apply tag filters
+            if (options.ExcludedTags?.Count > 0 && 
+                test.Tags.Any(tag => options.ExcludedTags.Contains(tag)))
+                return false;
 
-                // Update selection timestamp
-                test.LastSelected = DateTimeOffset.UtcNow;
+            if (options.RequiredTags?.Count > 0 && 
+                !options.RequiredTags.Any(tag => test.Tags.Contains(tag)))
+                return false;
+
+            // Apply flaky test filter
+            if (!options.IncludeFlakyTests && test.IsFlaky())
+                return false;
+
+            return true;
+        }
+
+        private async Task<List<TestInfo>> DiscoverTestsFromSolution(string solutionPath, CancellationToken cancellationToken)
+        {
+            var testInfos = new List<TestInfo>();
+
+            try
+            {
+                // Find test assemblies in the solution
+                var assemblyPaths = await FindTestAssembliesInSolution(solutionPath);
+                
+                _logger.LogInformation("Found {AssemblyCount} test assemblies in solution", assemblyPaths.Count);
+                foreach (var path in assemblyPaths)
+                {
+                    _logger.LogInformation("  Test assembly: {Assembly}", path);
+                }
+
+                // Use shared loader for efficiency
+                using var loader = new CrossFrameworkAssemblyLoader();
+                var discovery = TestDiscoveryFactory.CreateNUnitTestDiscovery();
+
+                foreach (var assemblyPath in assemblyPaths)
+                {
+                    try
+                    {
+                        var loadResult = await loader.LoadAssemblyAsync(assemblyPath);
+                        if (!loadResult.IsSuccess || loadResult.Assembly == null)
+                        {
+                            _logger.LogWarning("Failed to load assembly: {Assembly} - {Errors}", 
+                                assemblyPath, string.Join(", ", loadResult.Errors));
+                            continue;
+                        }
+
+                        var discoveryResult = await discovery.DiscoverTestsAsync(loadResult.Assembly, cancellationToken);
+                        
+                        // Convert discovered tests to TestInfo objects
+                        foreach (var testMethod in discoveryResult.GetAllTestMethods())
+                        {
+                            var testInfo = ConvertToTestInfo(testMethod);
+                            testInfos.Add(testInfo);
+                        }
+
+                        _logger.LogDebug("Discovered {TestCount} tests from {Assembly}", 
+                            discoveryResult.TestMethodCount, Path.GetFileName(assemblyPath));
+                    }
+                    catch (Exception ex)
+                    {
+                        _logger.LogWarning(ex, "Error discovering tests from assembly: {Assembly}", assemblyPath);
+                    }
+                }
+            }
+            catch (Exception ex)
+            {
+                _logger.LogError(ex, "Error discovering tests from solution: {Solution}", solutionPath);
             }
 
-            await Task.CompletedTask; // Placeholder for async operations
+            return testInfos;
+        }
 
-            _logger.LogDebug("Selected {SelectedCount} tests out of {CandidateCount} candidates", 
-                selectedTests.Count, scoredTests.Count);
+        private async Task<List<string>> FindTestAssembliesInSolution(string solutionPath)
+        {
+            var assemblies = new List<string>();
 
-            return selectedTests;
+            try
+            {
+                var solutionDir = Path.GetDirectoryName(solutionPath)!;
+                var projectPaths = await FindTestProjectsInSolution(solutionPath);
+                
+                _logger.LogInformation("Found {ProjectCount} test projects", projectPaths.Count);
+
+                foreach (var projectPath in projectPaths)
+                {
+                    var assemblyPath = GetAssemblyPathFromProject(projectPath);
+                    _logger.LogDebug("Checking assembly path: {Assembly} (exists: {Exists})", assemblyPath, File.Exists(assemblyPath));
+                    if (File.Exists(assemblyPath))
+                    {
+                        assemblies.Add(assemblyPath);
+                    }
+                }
+            }
+            catch (Exception ex)
+            {
+                _logger.LogWarning(ex, "Error finding test assemblies in solution: {Solution}", solutionPath);
+            }
+
+            return assemblies;
         }
 
-        private static double GetMinScoreForConfidenceLevel(ConfidenceLevel confidenceLevel)
+        private async Task<List<string>> FindTestProjectsInSolution(string solutionPath)
         {
-            return confidenceLevel switch
+            var testProjects = new List<string>();
+
+            try
             {
-                ConfidenceLevel.Fast => 0.6,
-                ConfidenceLevel.Medium => 0.4,
-                ConfidenceLevel.High => 0.2,
-                ConfidenceLevel.Full => 0.0,
-                _ => 0.3
+                var solutionContent = await File.ReadAllTextAsync(solutionPath);
+                var solutionDir = Path.GetDirectoryName(solutionPath)!;
+
+                // Parse solution file properly
+                // Format: Project("{GUID}") = "ProjectName", "RelativePath", "{ProjectGUID}"
+                var lines = solutionContent.Split('\n');
+                foreach (var line in lines)
+                {
+                    if (line.StartsWith("Project(") && line.Contains(".csproj"))
+                    {
+                        // Extract project path from solution line
+                        var parts = line.Split(',');
+                        if (parts.Length >= 2)
+                        {
+                            var relativePath = parts[1].Trim().Trim('"');
+                            
+                            // Only include test projects (in tests directory or with "Test" in path/name)
+                            if (relativePath.Contains("test", StringComparison.OrdinalIgnoreCase) || 
+                                relativePath.StartsWith("tests", StringComparison.OrdinalIgnoreCase))
+                            {
+                                var fullPath = Path.Combine(solutionDir, relativePath).Replace('\\', Path.DirectorySeparatorChar);
+                                if (File.Exists(fullPath))
+                                {
+                                    testProjects.Add(fullPath);
+                                    _logger.LogDebug("Found test project: {Project}", fullPath);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+            catch (Exception ex)
+            {
+                _logger.LogWarning(ex, "Error parsing solution file: {Solution}", solutionPath);
+            }
+
+            return testProjects;
+        }
+
+        private string GetAssemblyPathFromProject(string projectPath)
+        {
+            var projectDir = Path.GetDirectoryName(projectPath)!;
+            var projectName = Path.GetFileNameWithoutExtension(projectPath);
+            
+            // Try common output paths
+            var possiblePaths = new[]
+            {
+                Path.Combine(projectDir, "bin", "Debug", "net8.0", $"{projectName}.dll"),
+                Path.Combine(projectDir, "bin", "Release", "net8.0", $"{projectName}.dll"),
+                Path.Combine(projectDir, "bin", "Debug", $"{projectName}.dll"),
+                Path.Combine(projectDir, "bin", "Release", $"{projectName}.dll")
             };
+
+            foreach (var path in possiblePaths)
+            {
+                if (File.Exists(path))
+                {
+                    return path;
+                }
+            }
+
+            // Default to Debug net8.0 path even if it doesn't exist yet
+            return Path.Combine(projectDir, "bin", "Debug", "net8.0", $"{projectName}.dll");
+        }
+
+        private TestInfo ConvertToTestInfo(Core.Models.TestMethod testMethod)
+        {
+            var category = CategorizeTest(testMethod);
+            var averageTime = TimeSpan.FromMilliseconds(100); // Default estimate
+            
+            var testInfo = new TestInfo(testMethod, category, averageTime);
+
+            // Add tags to the test info
+            var tags = ExtractTestTags(testMethod);
+            foreach (var tag in tags)
+            {
+                testInfo.Tags.Add(tag);
+            }
+
+            return testInfo;
+        }
+
+        private TestCategory CategorizeTest(Core.Models.TestMethod testMethod)
+        {
+            var methodName = testMethod.MethodInfo.Name.ToLower();
+            var className = testMethod.MethodInfo.DeclaringType?.Name.ToLower() ?? "";
+
+            if (methodName.Contains("database") || methodName.Contains("db") || 
+                className.Contains("database") || className.Contains("db"))
+                return TestCategory.Database;
+
+            if (methodName.Contains("api") || methodName.Contains("http") ||
+                className.Contains("api") || className.Contains("http"))
+                return TestCategory.API;
+
+            if (methodName.Contains("integration") || className.Contains("integration"))
+                return TestCategory.Integration;
+
+            if (methodName.Contains("ui") || methodName.Contains("selenium") ||
+                className.Contains("ui") || className.Contains("selenium"))
+                return TestCategory.UI;
+
+            return TestCategory.Unit;
+        }
+
+        private List<string> ExtractTestTags(Core.Models.TestMethod testMethod)
+        {
+            var tags = new List<string>();
+            
+            // Add category as a tag
+            var category = CategorizeTest(testMethod);
+            tags.Add(category.ToString());
+
+            // You could add more sophisticated tag extraction from attributes here
+            
+            return tags;
+        }
+
+        private string? FindSolutionFile(string filePath)
+        {
+            try
+            {
+                var directory = Path.GetDirectoryName(Path.GetFullPath(filePath));
+                
+                while (directory != null)
+                {
+                    var solutionFiles = Directory.GetFiles(directory, "*.sln");
+                    if (solutionFiles.Length > 0)
+                    {
+                        return solutionFiles.First(); // Return the first solution file found
+                    }
+                    
+                    directory = Path.GetDirectoryName(directory);
+                }
+            }
+            catch (Exception ex)
+            {
+                _logger.LogWarning(ex, "Error finding solution file for path: {FilePath}", filePath);
+            }
+
+            return null;
         }
     }
 
diff --git a/src/TestIntelligence.SelectionEngine/Interfaces/ITestSelectionEngine.cs b/src/TestIntelligence.SelectionEngine/Interfaces/ITestSelectionEngine.cs
index 7cc9673..b09ed2c 100644
--- a/src/TestIntelligence.SelectionEngine/Interfaces/ITestSelectionEngine.cs
+++ b/src/TestIntelligence.SelectionEngine/Interfaces/ITestSelectionEngine.cs
@@ -17,6 +17,7 @@ namespace TestIntelligence.SelectionEngine.Interfaces
         Task<TestExecutionPlan> GetOptimalTestPlanAsync(
             CodeChangeSet changes,
             ConfidenceLevel confidenceLevel,
+            TestSelectionOptions? options = null,
             CancellationToken cancellationToken = default);
 
         /// <summary>
diff --git a/test-changes.patch b/test-changes.patch
index 11bbfa0..f1929a3 100644
--- a/test-changes.patch
+++ b/test-changes.patch
@@ -1,2130 +1,13353 @@
-diff --git a/recent-changes.patch b/recent-changes.patch
+diff --git a/SELECT_COMMAND_VERIFICATION_REPORT.md b/SELECT_COMMAND_VERIFICATION_REPORT.md
 new file mode 100644
-index 0000000..6d0dbc7
+index 0000000..bb32619
 --- /dev/null
-+++ b/recent-changes.patch
-@@ -0,0 +1,2102 @@
-+diff --git a/.claude/commands/debug-find-tests.md b/.claude/commands/debug-find-tests.md
-+new file mode 100644
-+index 0000000..10c1e5e
-+--- /dev/null
-++++ b/.claude/commands/debug-find-tests.md
-+@@ -0,0 +1,454 @@
-++# Debug Find-Tests Command
-++
-++Debug version of find-tests testing with enhanced tracing to troubleshoot issues we've been experiencing with the find-tests command accuracy.
-++
-++## Known Issues to Investigate
-++- Potential false positives in test detection
-++- Missing tests that should be found
-++- Incorrect confidence scoring
-++- Call graph traversal problems
-++- Assembly loading or reflection issues
-++
-++## Debug Testing Protocol
-++
-++### Step 1: Select Target Method with Debug Context
-++1. **Choose a well-known method** with clear test relationships:
-++   ```bash
-++   # Example: Pick a method we know is tested
-++   echo "üîç Selecting target method for debug analysis..."
-++   grep -r "DiscoverTestsAsync\|AnalyzeAssembly\|ProcessDependencies" src/ --include="*.cs" -n | head -5
-++   ```
-++
-++2. **Document expected behavior**:
-++   ```bash
-++   echo "üìù Documenting what we expect to find..."
-++   # Manually identify tests that should be found
-++   grep -r "TargetMethodName" tests/ --include="*.cs" -l
-++   ```
-++
-++### Step 2: Add Debug Tracing to Source Code
-++
-++Before running the command, temporarily add debug statements to trace execution:
-++
-++```bash
-++# Backup original files
-++cp src/TestIntelligence.CLI/Commands/FindTestsCommand.cs src/TestIntelligence.CLI/Commands/FindTestsCommand.cs.debug-backup
-++cp src/TestIntelligence.Core/Services/TestMethodMapper.cs src/TestIntelligence.Core/Services/TestMethodMapper.cs.debug-backup
-++```
-++
-++#### Add debug statements to key files:
-++
-++**1. FindTestsCommand.cs - Entry point tracing**:
-++```csharp
-++// Add after method signature
-++Console.WriteLine($"üîç DEBUG: Starting find-tests for method: {methodName}");
-++Console.WriteLine($"üîç DEBUG: Solution path: {solutionPath}");
-++Console.WriteLine($"üîç DEBUG: Output format: {format}");
-++```
-++
-++**2. TestMethodMapper.cs - Core logic tracing**:
-++```csharp
-++// Add in FindTestsForMethod
-++Console.WriteLine($"üîç DEBUG: Loading solution: {solutionPath}");
-++Console.WriteLine($"üîç DEBUG: Target method: {targetMethod}");
-++Console.WriteLine($"üîç DEBUG: Found {projects.Count} projects to analyze");
-++
-++// Add in call graph traversal
-++Console.WriteLine($"üîç DEBUG: Building call graph for method: {method.Name}");
-++Console.WriteLine($"üîç DEBUG: Found {callers.Count} direct callers");
-++
-++// Add in test discovery
-++Console.WriteLine($"üîç DEBUG: Discovered {testMethods.Count} total test methods");
-++Console.WriteLine($"üîç DEBUG: Filtering tests that call target method...");
-++```
-++
-++**3. Assembly loading tracing**:
-++```csharp
-++// Add assembly loading debug info
-++Console.WriteLine($"üîç DEBUG: Loading assembly: {assemblyPath}");
-++Console.WriteLine($"üîç DEBUG: Assembly loaded successfully: {assembly.FullName}");
-++Console.WriteLine($"üîç DEBUG: Found {types.Length} types in assembly");
-++```
-++
-++### Step 3: Run Debug-Enhanced Find-Tests Command
-++
-++```bash
-++# Clear cache to ensure fresh analysis
-++dotnet run --project src/TestIntelligence.CLI cache \
-++  --solution TestIntelligence.sln \
-++  --action clear
-++
-++echo "üöÄ Running debug find-tests command..."
-++dotnet run --project src/TestIntelligence.CLI find-tests \
-++  --method "TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync" \
-++  --solution TestIntelligence.sln \
-++  --format json \
-++  --output debug-find-tests-result.json \
-++  --verbose 2>&1 | tee debug-find-tests-trace.log
-++```
-++
-++### Step 4: Enhanced Debug Analysis
-++
-++#### 4.1 Trace Analysis
-++```bash
-++echo "üìä Analyzing debug trace..."
-++
-++# Check if solution loaded correctly
-++grep "Loading solution" debug-find-tests-trace.log
-++grep "Found.*projects" debug-find-tests-trace.log
-++
-++# Check assembly loading
-++grep "Loading assembly" debug-find-tests-trace.log
-++grep "Assembly loaded successfully" debug-find-tests-trace.log
-++
-++# Check call graph construction
-++grep "Building call graph" debug-find-tests-trace.log
-++grep "Found.*callers" debug-find-tests-trace.log
-++
-++# Check test discovery
-++grep "Discovered.*test methods" debug-find-tests-trace.log
-++grep "Filtering tests" debug-find-tests-trace.log
-++```
-++
-++#### 4.2 Validate Each Step
-++```bash
-++echo "üîç Step-by-step validation..."
-++
-++# 1. Verify target method exists
-++echo "1. Checking if target method exists in codebase:"
-++grep -r "DiscoverTestsAsync" src/ --include="*.cs" -A 2 -B 2
-++
-++# 2. Verify test methods that should be found
-++echo "2. Manual search for tests that should be found:"
-++grep -r "DiscoverTestsAsync\|NUnitTestDiscovery" tests/ --include="*.cs" -n
-++
-++# 3. Check for false positives in results
-++echo "3. Examining found tests for false positives:"
-++jq '.foundTests[].testName' debug-find-tests-result.json
-++
-++# 4. Cross-reference with actual test code
-++echo "4. Cross-referencing with actual test implementations:"
-++for test in $(jq -r '.foundTests[].testName' debug-find-tests-result.json); do
-++  echo "Examining test: $test"
-++  # Find the test file and examine it
-++  grep -r "$test" tests/ --include="*.cs" -A 10 -B 2
-++done
-++```
-++
-++### Step 5: Deep Dive Debugging
-++
-++#### 5.1 Call Graph Debugging
-++```bash
-++echo "üï∏Ô∏è Deep dive into call graph construction..."
-++
-++# Generate call graph for target method
-++dotnet run --project src/TestIntelligence.CLI callgraph \
-++  --path TestIntelligence.sln \
-++  --format json \
-++  --output debug-callgraph.json \
-++  --verbose
-++
-++# Compare call graph with find-tests results
-++echo "Comparing call graph with find-tests results..."
-++jq '.methods[] | select(.name | contains("DiscoverTestsAsync"))' debug-callgraph.json
-++```
-++
-++#### 5.2 Assembly Reflection Debugging
-++Add deeper assembly inspection:
-++```csharp
-++// Add to assembly loading section
-++Console.WriteLine($"üîç DEBUG: Assembly types found:");
-++foreach (var type in assembly.GetTypes())
-++{
-++    Console.WriteLine($"  - {type.FullName}");
-++    if (type.Name.Contains("Test"))
-++    {
-++        var methods = type.GetMethods().Where(m => m.GetCustomAttributes().Any());
-++        Console.WriteLine($"    Test methods: {methods.Count()}");
-++        foreach (var method in methods)
-++        {
-++            Console.WriteLine($"      - {method.Name}");
-++        }
-++    }
-++}
-++```
-++
-++### Step 6: Issue Classification and Reporting
-++
-++#### 6.1 Categorize Issues Found
-++```bash
-++echo "üìã Categorizing issues found during debug session..."
-++
-++# False Positives Analysis
-++echo "‚ùå FALSE POSITIVES:"
-++echo "Tests that were found but don't actually call the target method:"
-++# Manual analysis based on code examination
-++
-++# False Negatives Analysis  
-++echo "‚ùå FALSE NEGATIVES:"
-++echo "Tests that should have been found but weren't:"
-++# Compare manual grep results with CLI output
-++
-++# Confidence Score Issues
-++echo "‚ö†Ô∏è CONFIDENCE SCORE ISSUES:"
-++echo "Tests with inappropriate confidence scores:"
-++# Analyze if scores match call depth/complexity
-++```
-++
-++#### 6.2 Root Cause Analysis
-++Based on debug output, identify likely causes:
-++
-++**Common Issues to Look For**:
-++- **Assembly Loading**: Are all test assemblies being loaded?
-++- **Reflection Issues**: Are test attributes being detected correctly?
-++- **Call Graph**: Is method call traversal working correctly?
-++- **Name Matching**: Are there namespace or overload resolution issues?
-++- **Caching**: Are cached results stale or incorrect?
-++
-++### Step 7: Debug Report Format
-++
-++```
-++## Debug Find-Tests Analysis Report
-++
-++**Target Method**: TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync
-++**Debug Session Date**: [Current Date]
-++**Known Issues Being Investigated**: False positives, missing integration tests
-++
-++### Debug Trace Summary
-++- ‚úÖ Solution loaded: 15 projects found
-++- ‚úÖ Target method located in: TestIntelligence.Core.dll
-++- ‚ö†Ô∏è Assembly loading: 2 warnings about dependency versions
-++- ‚úÖ Call graph construction: 45 direct callers found
-++- ‚ùå Test discovery: Only 12 test methods found (expected ~20)
-++
-++### Execution Flow Analysis
-++
-++#### 1. Solution Loading (‚úÖ Working)
-++```
-++üîç DEBUG: Loading solution: TestIntelligence.sln
-++üîç DEBUG: Found 15 projects to analyze
-++```
-++
-++#### 2. Target Method Resolution (‚úÖ Working)
-++```
-++üîç DEBUG: Target method: TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync
-++üîç DEBUG: Method located in assembly: TestIntelligence.Core
-++```
-++
-++#### 3. Call Graph Construction (‚ö†Ô∏è Partial Issue)
-++```
-++üîç DEBUG: Building call graph for method: DiscoverTestsAsync
-++üîç DEBUG: Found 45 direct callers
-++Issue: Missing some integration test callers due to indirect invocation
-++```
-++
-++#### 4. Test Discovery (‚ùå Major Issue)
-++```
-++üîç DEBUG: Discovered 89 total test methods
-++üîç DEBUG: Filtering tests that call target method...
-++Issue: Filter logic excluding valid tests with indirect calls
-++```
-++
-++### Issues Identified
-++
-++#### ‚ùå Issue #1: Missing Integration Tests
-++**Problem**: Integration tests that call TestAnalyzer.AnalyzeAssembly (which calls DiscoverTestsAsync) are not being found
-++**Root Cause**: Call graph depth limit or indirect call resolution
-++**Evidence**: Manual grep found 8 integration tests, CLI found only 2
-++**Debug Trace**: 
-++```
-++Manual: grep -r "AnalyzeAssembly" tests/ found 8 matches
-++CLI Result: Only 2 tests with confidence scores > 0.5
-++```
-++
-++#### ‚ùå Issue #2: False Positive Detection
-++**Problem**: Test "SomeUnrelatedTest" was found with 0.3 confidence
-++**Root Cause**: Name collision or incorrect dependency analysis
-++**Evidence**: Test code shows no actual calls to target method
-++**Debug Trace**:
-++```
-++Test code analysis: Only calls DatabaseHelper.Setup() and Assert methods
-++No path to DiscoverTestsAsync found in manual trace
-++```
-++
-++#### ‚ö†Ô∏è Issue #3: Confidence Score Inaccuracy
-++**Problem**: Direct test has confidence 0.7, indirect test has 0.8
-++**Root Cause**: Scoring algorithm may be inverted or considering other factors
-++**Evidence**: NUnitTestDiscoveryTests.DirectTest should have higher confidence than IntegrationTests.IndirectTest
-++
-++### Recommended Fixes
-++
-++1. **Call Graph Depth**: Increase traversal depth for integration tests
-++2. **Filter Logic**: Review test filtering criteria to include indirect callers
-++3. **Name Resolution**: Improve method name matching to avoid false positives
-++4. **Confidence Scoring**: Review algorithm to properly weight direct vs indirect calls
-++
-++### Next Steps
-++1. Apply debug fixes to core components
-++2. Re-run debug session to validate improvements
-++3. Add unit tests for edge cases discovered
-++4. Update documentation with known limitations
-++```
-++
-++### Step 8: Fix Issues Found
-++
-++**CRITICAL**: After identifying issues through debugging, you MUST implement fixes for all problems discovered.
-++
-++#### 8.1 Apply Fixes Based on Root Cause Analysis
-++
-++Based on the issues identified in the debug report, implement the following fixes:
-++
-++**Fix #1: Call Graph Depth Issues**
-++```bash
-++echo "üîß Fixing call graph traversal depth..."
-++
-++# Edit the call graph construction to increase depth limit
-++# Look for depth limiting code in TestMethodMapper or CallGraphBuilder
-++grep -r "depth\|limit" src/TestIntelligence.Core/ --include="*.cs" -n
-++
-++# Implement fix - example:
-++# Change: const int MAX_DEPTH = 3;
-++# To:     const int MAX_DEPTH = 5;
-++```
-++
-++**Fix #2: Test Filtering Logic**
-++```bash
-++echo "üîß Fixing test filtering to include indirect callers..."
-++
-++# Find and fix the test filtering logic
-++# Look for filtering criteria that might be too restrictive
-++grep -r "filter\|where.*confidence\|threshold" src/TestIntelligence.Core/ --include="*.cs" -A 3 -B 3
-++```
-++
-++**Fix #3: Confidence Score Algorithm**
-++```bash
-++echo "üîß Fixing confidence scoring algorithm..."
-++
-++# Locate confidence scoring logic
-++grep -r "confidence.*score\|calculateConfidence" src/TestIntelligence.Core/ --include="*.cs" -n
-++
-++# Review and fix scoring to properly weight:
-++# - Direct calls: Higher confidence (0.8-1.0)
-++# - One-hop indirect: Medium confidence (0.6-0.8)  
-++# - Multi-hop indirect: Lower confidence (0.3-0.6)
-++# - No relation: Very low confidence (0.0-0.2)
-++```
-++
-++**Fix #4: False Positive Prevention**
-++```bash
-++echo "üîß Implementing false positive detection..."
-++
-++# Add stricter validation for method relationships
-++# Implement additional verification steps before including tests
-++```
-++
-++#### 8.2 Implement Specific Code Changes
-++
-++For each identified issue, make the actual code changes:
-++
-++```bash
-++echo "üìù Implementing code fixes..."
-++
-++# Example fix for call graph depth
-++# Find the relevant file and implement the change
-++# Use Edit tool to modify the source code with the fix
-++```
-++
-++#### 8.3 Validate Fixes
-++
-++After implementing fixes, validate they work:
-++
-++```bash
-++echo "‚úÖ Validating fixes..."
-++
-++# Rebuild the solution
-++dotnet build
-++
-++# Clear cache to ensure fresh analysis
-++dotnet run --project src/TestIntelligence.CLI cache \
-++  --solution TestIntelligence.sln \
-++  --action clear
-++
-++# Re-run the find-tests command to verify improvements
-++dotnet run --project src/TestIntelligence.CLI find-tests \
-++  --method "TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync" \
-++  --solution TestIntelligence.sln \
-++  --format json \
-++  --output fixed-find-tests-result.json \
-++  --verbose
-++
-++echo "üîç Comparing before/after results..."
-++# Compare original debug results with fixed results
-++echo "Before fix - tests found: $(jq '.foundTests | length' debug-find-tests-result.json)"
-++echo "After fix - tests found: $(jq '.foundTests | length' fixed-find-tests-result.json)"
-++
-++# Verify specific issues were resolved:
-++echo "Checking if missing integration tests are now found..."
-++echo "Checking if false positives were eliminated..."
-++echo "Checking if confidence scores are more accurate..."
-++```
-++
-++#### 8.4 Run Comprehensive Tests
-++
-++Ensure fixes don't break other functionality:
-++
-++```bash
-++echo "üß™ Running comprehensive tests after fixes..."
-++
-++# Run all relevant tests
-++dotnet test tests/TestIntelligence.Core.Tests/ -v normal
-++dotnet test tests/TestIntelligence.ImpactAnalyzer.Tests/ -v normal
-++
-++# Test with different target methods to ensure general improvement
-++dotnet run --project src/TestIntelligence.CLI find-tests \
-++  --method "TestIntelligence.Core.TestAnalyzer.AnalyzeAssembly" \
-++  --solution TestIntelligence.sln \
-++  --output validation-test-2.json
-++
-++dotnet run --project src/TestIntelligence.CLI find-tests \
-++  --method "TestIntelligence.DataTracker.DatabaseAnalyzer.AnalyzeDependencies" \
-++  --solution TestIntelligence.sln \
-++  --output validation-test-3.json
-++```
-++
-++### Step 9: Cleanup and Restoration
-++
-++```bash
-++echo "üßπ Cleaning up debug modifications..."
-++
-++# Restore original files (debug tracing code)
-++mv src/TestIntelligence.CLI/Commands/FindTestsCommand.cs.debug-backup src/TestIntelligence.CLI/Commands/FindTestsCommand.cs
-++mv src/TestIntelligence.Core/Services/TestMethodMapper.cs.debug-backup src/TestIntelligence.Core/Services/TestMethodMapper.cs
-++
-++# Keep debug logs and results for reference
-++mkdir -p debug-logs
-++mv debug-find-tests-trace.log debug-logs/
-++mv debug-find-tests-result.json debug-logs/
-++mv fixed-find-tests-result.json debug-logs/
-++mv debug-callgraph.json debug-logs/
-++mv validation-test-*.json debug-logs/
-++
-++echo "‚úÖ Debug session complete with fixes applied. Logs saved to debug-logs/"
-++```
-++
-++## Usage Instructions for Claude
-++
-++When running this debug command, you MUST:
-++
-++1. **Be systematic** - Follow each debug step to identify the exact failure point
-++2. **Preserve evidence** - Save all debug output and manual verification results
-++3. **Compare exhaustively** - Cross-reference CLI results with manual code analysis
-++4. **Focus on root causes** - Don't just identify symptoms, trace to underlying issues
-++5. **Document thoroughly** - Create detailed reports to help fix the underlying problems
-++6. **IMPLEMENT FIXES** - Actually modify the source code to resolve identified issues
-++7. **Validate fixes** - Re-run debug session and tests after applying fixes
-++8. **Test comprehensively** - Ensure fixes don't break other functionality
-++
-++**CRITICAL REQUIREMENT**: This command is not complete until you have:
-++- ‚úÖ Identified all issues through debugging
-++- ‚úÖ Implemented code fixes for each identified problem
-++- ‚úÖ Validated that fixes resolve the issues
-++- ‚úÖ Confirmed no regressions were introduced
-++- ‚úÖ Updated any relevant tests or documentation
-++
-++This debug-and-fix approach will not only identify where the find-tests command is failing but will also resolve those issues to improve the overall accuracy and reliability of the TestIntelligence library.
-+\ No newline at end of file
-+diff --git a/.claude/commands/test-analyze-coverage.md b/.claude/commands/test-analyze-coverage.md
-+new file mode 100644
-+index 0000000..9eb3bdc
-+--- /dev/null
-++++ b/.claude/commands/test-analyze-coverage.md
-+@@ -0,0 +1,187 @@
-++# Test Analyze Coverage Command
-++
-++Instructions for Claude to test the analyze-coverage command by selecting test methods and verifying how well they cover code changes.
-++
-++## Testing Protocol
-++
-++### Step 1: Create Test Scenario
-++1. **Select Target Tests**: Choose 2-3 test methods from different test projects:
-++   - Pick tests that exercise different parts of the codebase
-++   - Include both unit tests and integration tests
-++   - Choose tests you can manually trace through
-++
-++2. **Create Mock Changes**: Generate a git diff to analyze:
-++   ```bash
-++   # Option A: Create actual changes and diff them
-++   echo "// Test change" >> src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
-++   git add -A
-++   git diff --cached > test-changes.patch
-++   git reset HEAD
-++   
-++   # Option B: Use existing git history
-++   git diff HEAD~1 > recent-changes.patch
-++   ```
-++
-++### Step 2: Run the Analyze-Coverage Command
-++```bash
-++dotnet run --project src/TestIntelligence.CLI analyze-coverage \
-++  --solution TestIntelligence.sln \
-++  --tests "TestClass1.TestMethod1" "TestClass2.TestMethod2" "TestClass3.TestMethod3" \
-++  --git-command "diff HEAD~1" \
-++  --verbose \
-++  --output coverage-analysis.json
-++```
-++
-++Alternative with diff file:
-++```bash
-++dotnet run --project src/TestIntelligence.CLI analyze-coverage \
-++  --solution TestIntelligence.sln \
-++  --tests "TestClass1.TestMethod1" "TestClass2.TestMethod2" \
-++  --diff-file test-changes.patch \
-++  --verbose \
-++  --output coverage-analysis.json
-++```
-++
-++### Step 3: Manual Verification Process
-++
-++#### 3.1 Analyze the Output
-++1. **Read Coverage Report**: Examine JSON results for:
-++   - Coverage percentage for each test
-++   - List of changed methods/classes covered by each test
-++   - Uncovered changes identified
-++   - Overall coverage metrics
-++
-++2. **Understand Change Set**: Review the git diff to identify:
-++   - Which files were modified
-++   - Which methods/classes were changed
-++   - Nature of changes (new code, modifications, deletions)
-++
-++#### 3.2 Manual Coverage Verification
-++For each test method:
-++
-++1. **Trace Test Execution**:
-++   - Read the test method source code
-++   - Follow all method calls made by the test
-++   - Map the execution path through the codebase
-++
-++2. **Match Against Changes**:
-++   - Compare test execution path with changed code
-++   - Identify which changed methods/classes the test actually exercises
-++   - Note any changed code the test doesn't reach
-++
-++3. **Validate Coverage Calculation**:
-++   - Count changed methods covered vs. total changed methods
-++   - Verify the coverage percentage is mathematically correct
-++   - Check if the analysis missed any coverage or overcounted
-++
-++#### 3.3 Gap Analysis
-++1. **Identify Uncovered Changes**:
-++   - Find changed code not exercised by any of the selected tests
-++   - Verify these are truly uncovered (not false negatives)
-++
-++2. **Find Coverage Gaps**:
-++   - Look for changed code that should be covered but isn't
-++   - Search for additional tests that might cover the gaps
-++
-++### Step 4: Verification Commands
-++
-++```bash
-++# Search for tests that might cover a specific changed class
-++grep -r "ChangedClassName" tests/ --include="*.cs" -l
-++
-++# Look at specific changed file to understand modifications
-++git show HEAD~1:src/path/to/ChangedFile.cs | diff - src/path/to/ChangedFile.cs
-++
-++# Find all tests in a specific test class
-++grep -n "\[Test\]\|\[Fact\]\|\[TestMethod\]" tests/path/to/TestClass.cs
-++
-++# Trace method usage across the codebase
-++grep -r "ChangedMethodName" src/ --include="*.cs"
-++```
-++
-++### Step 5: Sample Verification Report Format
-++
-++```
-++## Analyze-Coverage Verification Report
-++
-++**Test Scenario**:
-++- Selected Tests: 3 tests from Core and DataTracker projects
-++- Change Set: Modified NUnitTestDiscovery.cs and TestAnalyzer.cs (8 methods changed)
-++- Git Command: `diff HEAD~1`
-++
-++**CLI Output Summary**:
-++- Test1 Coverage: 75% (6/8 changed methods)
-++- Test2 Coverage: 25% (2/8 changed methods)  
-++- Test3 Coverage: 0% (0/8 changed methods)
-++- Overall Coverage: 87.5% (7/8 changed methods covered by at least one test)
-++
-++**Manual Verification**:
-++
-++‚úÖ **Test1: NUnitTestDiscoveryTests.DiscoverTestsAsync_ValidAssembly**
-++   - Claimed Coverage: 75% (6/8 methods)
-++   - Manual Trace: Calls NUnitTestDiscovery.DiscoverTestsAsync ‚Üí LoadAssembly ‚Üí ProcessTypes ‚Üí ExtractAttributes
-++   - Actually Covers: NUnitTestDiscovery.DiscoverTestsAsync, LoadAssembly, ProcessTypes, ExtractAttributes, ValidateTest, FormatResults (6/8) ‚úÖ
-++   - Coverage calculation: Correct
-++
-++‚úÖ **Test2: TestAnalyzerTests.AnalyzeFullSolution**  
-++   - Claimed Coverage: 25% (2/8 methods)
-++   - Manual Trace: Calls TestAnalyzer.AnalyzeAssembly ‚Üí NUnitTestDiscovery.DiscoverTestsAsync ‚Üí LoadAssembly
-++   - Actually Covers: AnalyzeAssembly, DiscoverTestsAsync (2/8) ‚úÖ
-++   - Coverage calculation: Correct
-++
-++‚ö†Ô∏è **Test3: DataTrackerTests.SomeUnrelatedTest**
-++   - Claimed Coverage: 0% (0/8 methods)
-++   - Manual Trace: Only exercises database tracking functionality
-++   - Actually Covers: None of the changed methods ‚úÖ
-++   - Coverage calculation: Correct (true negative)
-++
-++**Uncovered Changes Verification**:
-++‚úÖ **TestAnalyzer.ValidateConfiguration** - Correctly identified as uncovered
-++   - No selected tests call this method
-++   - Manually confirmed by searching test codebase
-++
-++‚ùå **Missing Coverage Detection**:
-++   - Found integration test `FullPipelineTests.CompleteAnalysis` that exercises ValidateConfiguration
-++   - This test wasn't in the selected set but would provide coverage
-++   - CLI correctly reported method as uncovered for the selected tests
-++
-++**Overall Accuracy**: 100% - All coverage calculations verified as correct
-++**Coverage Gap Analysis**: 1/8 methods uncovered by selected tests (12.5% gap)
-++
-++**Recommendations**: 
-++- Coverage analysis is mathematically accurate
-++- Consider expanding test selection to include integration tests for better coverage
-++- The uncovered method has tests available but weren't in the analyzed set
-++```
-++
-++### Additional Verification Scenarios
-++
-++#### Scenario A: High Coverage Test Set
-++Select tests known to exercise broad functionality:
-++- Integration tests
-++- End-to-end workflow tests  
-++- Tests that call multiple components
-++
-++#### Scenario B: Low Coverage Test Set
-++Select very focused unit tests:
-++- Tests that only exercise one method
-++- Isolated component tests
-++- Mock-heavy tests with limited real code execution
-++
-++#### Scenario C: Mixed Framework Changes
-++Create changes spanning multiple projects:
-++- Core library changes
-++- CLI command changes
-++- Test framework changes
-++
-++## Usage Instructions for Claude
-++
-++When running this command:
-++1. **Be methodical** - actually trace through test execution paths
-++2. **Verify math** - check that coverage percentages are calculated correctly
-++3. **Look for edge cases** - tests that might have unexpected coverage patterns
-++4. **Consider test types** - unit vs integration tests may have different coverage patterns
-++5. **Cross-reference** - use grep/search to validate coverage claims
-++6. **Report thoroughly** - document both correct results and any discrepancies found
-++
-++This testing ensures the analyze-coverage command accurately maps test execution to code changes, which is critical for intelligent test selection and impact analysis.
-+\ No newline at end of file
-+diff --git a/.claude/commands/test-and-commit.md b/.claude/commands/test-and-commit.md
-+new file mode 100644
-+index 0000000..9db3c91
-+--- /dev/null
-++++ b/.claude/commands/test-and-commit.md
-+@@ -0,0 +1,39 @@
-++# Test and Commit
-++
-++Run all non-E2E tests, fix any issues found, and commit/push if all tests pass.
-++
-++## Command
-++
-++```bash
-++# Run all tests except E2E tests
-++dotnet test --filter "Category!=E2E" --verbosity normal
-++
-++# If tests fail, Claude will analyze and fix the issues
-++# If all tests pass, commit and push changes
-++if [ $? -eq 0 ]; then
-++  echo "All tests passed! Committing and pushing changes..."
-++  git add .
-++  git commit -m "$(cat <<'EOF'
-++Fix test issues and update codebase
-++
-++All non-E2E tests are now passing.
-++
-++ü§ñ Generated with [Claude Code](https://claude.ai/code)
-++
-++Co-Authored-By: Claude <noreply@anthropic.com>
-++EOF
-++)"
-++  git push
-++else
-++  echo "Tests failed. Claude will analyze and fix the issues."
-++fi
-++```
-++
-++## Usage
-++
-++Run this command when you want to:
-++1. Execute all tests except E2E tests
-++2. Have Claude automatically fix any test failures
-++3. Commit and push changes if all tests pass
-++
-++This command ensures your codebase maintains test quality while automating the commit process for successful test runs.
-+\ No newline at end of file
-+diff --git a/.claude/commands/test-find-tests.md b/.claude/commands/test-find-tests.md
-+new file mode 100644
-+index 0000000..89bb827
-+--- /dev/null
-++++ b/.claude/commands/test-find-tests.md
-+@@ -0,0 +1,103 @@
-++# Test Find-Tests Command
-++
-++Instructions for Claude to test the find-tests command by selecting a random method and verifying the output accuracy.
-++
-++## Testing Protocol
-++
-++### Step 1: Select a Random Method
-++1. Use `find` or `grep` to discover methods in the src/ directory
-++2. Pick a method from a Core, Categorizer, DataTracker, ImpactAnalyzer, or SelectionEngine class
-++3. Choose a method that's likely to be tested (public methods, important functionality)
-++
-++### Step 2: Run the Find-Tests Command
-++```bash
-++dotnet run --project src/TestIntelligence.CLI find-tests \
-++  --method "FullNamespace.ClassName.MethodName" \
-++  --solution TestIntelligence.sln \
-++  --format json \
-++  --output find-tests-result.json \
-++  --verbose
-++```
-++
-++### Step 3: Manual Verification Process
-++1. **Read the Output**: Examine the JSON results for:
-++   - List of test methods that allegedly exercise the target method
-++   - Confidence scores for each test
-++   - Call path depth information
-++
-++2. **Code Analysis**: For each test found:
-++   - Read the test method source code
-++   - Trace through the test execution path
-++   - Verify the test actually calls (directly or indirectly) the target method
-++   - Check if the confidence score seems reasonable based on call depth
-++
-++3. **Completeness Check**: 
-++   - Search the test codebase for the target method name
-++   - Look for any tests that should have been found but weren't
-++   - Verify no false positives (tests that don't actually exercise the method)
-++
-++4. **Report Results**:
-++   - Summarize accuracy: "X out of Y tests correctly identified"
-++   - Note any false positives or missed tests
-++   - Comment on confidence score appropriateness
-++   - Highlight any patterns or issues discovered
-++
-++### Step 4: Sample Commands to Help with Verification
-++
-++```bash
-++# Search for direct method calls in tests
-++grep -r "MethodName" tests/ --include="*.cs"
-++
-++# Search for class usage in tests
-++grep -r "ClassName" tests/ --include="*.cs"
-++
-++# Look at specific test file
-++cat tests/path/to/TestClass.cs
-++```
-++
-++### Example Verification Report Format
-++
-++```
-++## Find-Tests Verification Report
-++
-++**Target Method**: TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync
-++
-++**CLI Output Summary**:
-++- Found: 5 tests
-++- Confidence scores: High(2), Medium(2), Low(1)
-++
-++**Manual Verification**:
-++‚úÖ TestIntelligence.Core.Tests.Discovery.NUnitTestDiscoveryTests.DiscoverTestsAsync_ValidAssembly_ReturnsTests
-++   - Directly calls target method
-++   - Confidence: High (appropriate)
-++
-++‚úÖ TestIntelligence.Core.Tests.TestAnalyzerTests.AnalyzeAssembly_WithNUnitTests_IncludesNUnitTests  
-++   - Calls TestAnalyzer.AnalyzeAssembly which calls target method
-++   - Confidence: Medium (appropriate for 1-hop call)
-++
-++‚ùå TestIntelligence.SelectionEngine.Tests.SomeUnrelatedTest
-++   - False positive - doesn't actually call target method
-++   - Issue: Possible name collision or incorrect call graph
-++
-++**Missing Tests**:
-++- TestIntelligence.Core.Tests.Integration.FullAnalysisTests.CompleteAnalysis
-++  - This test exercises the full pipeline including the target method
-++  - Should have been found with Low confidence
-++
-++**Overall Accuracy**: 4/5 correct (80%)
-++**Recommendations**: 
-++- Investigate false positive detection
-++- Review call graph completeness for integration tests
-++```
-++
-++## Usage Instructions for Claude
-++
-++When running this command:
-++1. Be thorough in your verification - actually read the test code
-++2. Don't just trust the CLI output - verify by examining source code
-++3. Look for both false positives and false negatives
-++4. Consider the appropriateness of confidence scores
-++5. Report your findings in a clear, structured format
-++6. If you find issues, suggest potential causes or improvements
-++
-++This testing helps ensure the find-tests command is working accurately and can be trusted for real-world usage.
-+\ No newline at end of file
-+diff --git a/.claude/commands/test-select.md b/.claude/commands/test-select.md
-+new file mode 100644
-+index 0000000..dcb866c
-+--- /dev/null
-++++ b/.claude/commands/test-select.md
-+@@ -0,0 +1,278 @@
-++# Test Select Command
-++
-++Instructions for Claude to test the select command by creating code changes and verifying intelligent test selection accuracy across different confidence levels.
-++
-++## Testing Protocol
-++
-++### Step 1: Create Test Scenarios
-++
-++#### Scenario A: Single File Change (Core Component)
-++```bash
-++# Make a targeted change to a core component
-++cp src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs.backup
-++echo "        // Test change for select command validation" >> src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
-++```
-++
-++#### Scenario B: Multi-File Change (Cross-Component)
-++```bash
-++# Make changes across multiple components
-++echo "        // Cross-component change test" >> src/TestIntelligence.Core/TestAnalyzer.cs
-++echo "        // Related CLI change" >> src/TestIntelligence.CLI/Commands/AnalyzeCommand.cs
-++```
-++
-++#### Scenario C: Interface/Contract Change
-++```bash
-++# Modify an interface or base class that affects multiple implementations
-++echo "        // Interface change affecting multiple implementations" >> src/TestIntelligence.Core/Interfaces/ITestDiscovery.cs
-++```
-++
-++### Step 2: Test Different Confidence Levels
-++
-++#### 2.1 Fast Confidence (30 sec, 70% confidence)
-++```bash
-++dotnet run --project src/TestIntelligence.CLI select \
-++  --path TestIntelligence.sln \
-++  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" \
-++  --confidence Fast \
-++  --max-tests 20 \
-++  --output select-fast.json \
-++  --verbose
-++```
-++
-++#### 2.2 Medium Confidence (5 min, 85% confidence)  
-++```bash
-++dotnet run --project src/TestIntelligence.CLI select \
-++  --path TestIntelligence.sln \
-++  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" \
-++  --confidence Medium \
-++  --max-tests 50 \
-++  --output select-medium.json \
-++  --verbose
-++```
-++
-++#### 2.3 High Confidence (15 min, 95% confidence)
-++```bash
-++dotnet run --project src/TestIntelligence.CLI select \
-++  --path TestIntelligence.sln \
-++  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" \
-++  --confidence High \
-++  --max-tests 100 \
-++  --output select-high.json \
-++  --verbose
-++```
-++
-++#### 2.4 Full Confidence (Complete suite, 100% confidence)
-++```bash
-++dotnet run --project src/TestIntelligence.CLI select \
-++  --path TestIntelligence.sln \
-++  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" \
-++  --confidence Full \
-++  --output select-full.json \
-++  --verbose
-++```
-++
-++### Step 3: Manual Verification Process
-++
-++#### 3.1 Analyze Selection Results
-++For each confidence level, examine:
-++1. **Number of tests selected**
-++2. **Test categories included** (Unit, Integration, Database, API, UI)
-++3. **Confidence scores** for each selected test
-++4. **Execution time estimates**
-++5. **Tests organized by priority/relevance**
-++
-++#### 3.2 Validate Test Selection Logic
-++
-++**Direct Impact Tests (Should be in Fast)**:
-++```bash
-++# Find tests that directly test the changed class
-++grep -r "NUnitTestDiscovery" tests/ --include="*.cs" -l
-++# These should appear in Fast confidence with high scores
-++```
-++
-++**Indirect Impact Tests (Should be in Medium)**:
-++```bash
-++# Find tests that use classes that depend on the changed class
-++grep -r "TestAnalyzer\|Discovery" tests/ --include="*.cs" -l
-++# These should appear in Medium confidence with medium scores
-++```
-++
-++**Integration Tests (Should be in High)**:
-++```bash
-++# Find integration tests that exercise the full pipeline
-++grep -r "Integration\|EndToEnd\|FullPipeline" tests/ --include="*.cs" -l
-++# These should appear in High confidence with lower scores
-++```
-++
-++#### 3.3 Confidence Level Validation
-++
-++Verify that each confidence level follows the expected pattern:
-++- **Fast ‚äÇ Medium ‚äÇ High ‚äÇ Full** (each level includes previous levels)
-++- **Decreasing relevance scores** as confidence level increases
-++- **Appropriate test count limits** respected
-++- **Time estimates** align with confidence level targets
-++
-++### Step 4: Cross-Reference with Other Commands
-++
-++#### 4.1 Verify Against Find-Tests
-++```bash
-++# For each selected test, verify it actually relates to the changed code
-++dotnet run --project src/TestIntelligence.CLI find-tests \
-++  --method "TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync" \
-++  --solution TestIntelligence.sln \
-++  --output find-tests-cross-check.json
-++```
-++
-++#### 4.2 Verify Against Coverage Analysis
-++```bash
-++# Check if selected tests actually provide good coverage of changes
-++dotnet run --project src/TestIntelligence.CLI analyze-coverage \
-++  --solution TestIntelligence.sln \
-++  --tests $(jq -r '.selectedTests[].testName' select-medium.json | tr '\n' ' ') \
-++  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" \
-++  --output coverage-cross-check.json
-++```
-++
-++### Step 5: Sample Verification Report Format
-++
-++```
-++## Select Command Verification Report
-++
-++**Test Scenario**: Modified NUnitTestDiscovery.cs (single method change)
-++**Change Type**: Core component modification affecting test discovery logic
-++
-++### Confidence Level Analysis
-++
-++#### Fast Confidence (Target: 30 sec, 70% confidence)
-++- **Selected**: 8 tests
-++- **Time Estimate**: 25 seconds ‚úÖ
-++- **Categories**: Unit (6), Integration (2)
-++- **Top Tests**:
-++  ‚úÖ NUnitTestDiscoveryTests.DiscoverTestsAsync_ValidAssembly (Score: 0.95)
-++  ‚úÖ NUnitTestDiscoveryTests.DiscoverTestsAsync_EmptyAssembly (Score: 0.92)  
-++  ‚úÖ TestAnalyzerTests.AnalyzeAssembly_WithNUnitTests (Score: 0.78)
-++
-++#### Medium Confidence (Target: 5 min, 85% confidence)  
-++- **Selected**: 23 tests (includes all Fast + 15 more) ‚úÖ
-++- **Time Estimate**: 4.2 minutes ‚úÖ
-++- **Categories**: Unit (15), Integration (6), Database (2)
-++- **Additional Tests**:
-++  ‚úÖ CoreIntegrationTests.FullDiscoveryPipeline (Score: 0.65)
-++  ‚úÖ MultiFrameworkTests.NUnitAndXUnit (Score: 0.58)
-++
-++#### High Confidence (Target: 15 min, 95% confidence)
-++- **Selected**: 47 tests (includes all Medium + 24 more) ‚úÖ  
-++- **Time Estimate**: 12.8 minutes ‚úÖ
-++- **Categories**: Unit (25), Integration (15), Database (4), API (3)
-++- **Additional Tests**:
-++  ‚úÖ E2ETests.CompleteAnalysisWorkflow (Score: 0.35)
-++  ‚ö†Ô∏è UnrelatedUITests.SomeUITest (Score: 0.12) - Questionable relevance
-++
-++#### Full Confidence
-++- **Selected**: All 215 tests ‚úÖ
-++- **Includes**: Every test in the solution
-++
-++### Manual Verification Results
-++
-++#### Direct Impact Validation ‚úÖ
-++**Expected**: Tests that directly call NUnitTestDiscovery methods
-++- Found 6 direct tests in TestIntelligence.Core.Tests
-++- All 6 appeared in Fast confidence with scores > 0.8 ‚úÖ
-++- Scores appropriately reflect call directness ‚úÖ
-++
-++#### Indirect Impact Validation ‚úÖ  
-++**Expected**: Tests that call TestAnalyzer which uses NUnitTestDiscovery
-++- Found 8 indirect tests across Core and CLI test projects
-++- 7/8 appeared in Medium confidence ‚úÖ
-++- 1 missing test: CLIIntegrationTests.AnalyzeCommand_WithNUnit ‚ùå
-++- Scores appropriately lower (0.5-0.8 range) ‚úÖ
-++
-++#### Integration Test Validation ‚ö†Ô∏è
-++**Expected**: End-to-end tests that exercise full discovery pipeline  
-++- Found 12 integration tests
-++- 10/12 appeared in High confidence ‚úÖ
-++- 2 missing: PerformanceTests.LargeSolutionAnalysis, StressTests.ConcurrentDiscovery ‚ùå
-++- Some questionable inclusions with very low relevance scores
-++
-++### Cross-Reference Validation
-++
-++#### Find-Tests Cross-Check ‚úÖ
-++- Selected tests from Fast confidence all verified via find-tests command
-++- No false positives detected in direct impact tests
-++- Confidence scores align between select and find-tests commands
-++
-++#### Coverage Analysis Cross-Check ‚ö†Ô∏è
-++- Medium confidence tests provide 78% coverage of changed code
-++- Expected: ~85% based on confidence level target
-++- Gap: Some edge cases in error handling not covered by selected tests
-++- Recommendation: Include additional error handling tests
-++
-++### Selection Logic Assessment
-++
-++**Strengths**:
-++- ‚úÖ Confidence levels properly nested (Fast ‚äÇ Medium ‚äÇ High ‚äÇ Full)
-++- ‚úÖ Time estimates realistic and within targets
-++- ‚úÖ Direct impact tests correctly prioritized
-++- ‚úÖ Test categories appropriately distributed
-++- ‚úÖ Relevance scores generally accurate
-++
-++**Issues Found**:
-++- ‚ùå 2 high-relevance tests missed in Medium confidence
-++- ‚ùå Some very low relevance tests included in High confidence  
-++- ‚ùå Coverage gap vs confidence level expectations
-++
-++**Overall Accuracy**: 85% - Good test selection with minor gaps
-++**Recommendation**: 
-++- Review inclusion threshold for High confidence
-++- Investigate why 2 relevant tests were missed
-++- Consider adjusting relevance scoring for integration tests
-++```
-++
-++### Advanced Test Scenarios
-++
-++#### Scenario D: Configuration Change Impact
-++```bash
-++# Test with configuration/settings changes that might affect many components
-++echo "    // Configuration change" >> src/TestIntelligence.Core/Configuration/AnalysisSettings.cs
-++```
-++
-++#### Scenario E: Multiple File Changes
-++```bash  
-++# Test selection with multiple related changes
-++dotnet run --project src/TestIntelligence.CLI select \
-++  --path TestIntelligence.sln \
-++  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" "src/TestIntelligence.Core/TestAnalyzer.cs" \
-++  --confidence Medium \
-++  --output select-multifile.json
-++```
-++
-++#### Scenario F: Max Tests Constraint
-++```bash
-++# Test that max-tests parameter is respected
-++dotnet run --project src/TestIntelligence.CLI select \
-++  --path TestIntelligence.sln \
-++  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" \
-++  --confidence High \
-++  --max-tests 10 \
-++  --output select-constrained.json
-++```
-++
-++### Cleanup
-++```bash
-++# Restore original files after testing
-++mv src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs.backup src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
-++git checkout -- src/TestIntelligence.Core/TestAnalyzer.cs src/TestIntelligence.CLI/Commands/AnalyzeCommand.cs
-++```
-++
-++## Usage Instructions for Claude
-++
-++When running this command:
-++1. **Test all confidence levels** - verify the nested relationship and appropriateness
-++2. **Validate time estimates** - check if they align with confidence level targets  
-++3. **Cross-reference results** - use find-tests and analyze-coverage to verify selections
-++4. **Check edge cases** - test with multiple files, constraints, and different change types
-++5. **Assess relevance scoring** - ensure tests are ranked appropriately by impact likelihood
-++6. **Verify completeness** - look for missing tests that should be included
-++7. **Report systematically** - document accuracy, gaps, and recommendations
-++
-++This testing ensures the select command provides intelligent, accurate test selection that balances coverage with execution efficiency across different confidence levels.
-+\ No newline at end of file
-+diff --git a/Directory.Build.props b/Directory.Build.props
-+index 14da534..fe3608c 100644
-+--- a/Directory.Build.props
-++++ b/Directory.Build.props
-+@@ -10,7 +10,7 @@
-+     <LangVersion>latest</LangVersion>
-+     <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
-+     <WarningsAsErrors />
-+-    <WarningsNotAsErrors>NU1605;NU1701</WarningsNotAsErrors>
-++    <WarningsNotAsErrors>NU1605;NU1701;MSB3277</WarningsNotAsErrors>
-+     
-+     <!-- Common package metadata -->
-+     <Authors>TestIntelligence Contributors</Authors>
-+diff --git a/src/TestIntelligence.CLI/Commands/BaseCommandHandler.cs b/src/TestIntelligence.CLI/Commands/BaseCommandHandler.cs
-+index 3118751..5892681 100644
-+--- a/src/TestIntelligence.CLI/Commands/BaseCommandHandler.cs
-++++ b/src/TestIntelligence.CLI/Commands/BaseCommandHandler.cs
-+@@ -35,28 +35,113 @@ namespace TestIntelligence.CLI.Commands
-+             catch (OperationCanceledException)
-+             {
-+                 Logger.LogInformation("Command execution was cancelled");
-+-                return 1;
-++                Console.Error.WriteLine("Operation was cancelled by user.");
-++                return 130; // Standard exit code for cancelled operations
-+             }
-+             catch (ArgumentException ex)
-+             {
-+                 Logger.LogError(ex, "Invalid arguments provided to command");
-+-                Console.Error.WriteLine($"Error: {ex.Message}");
-++                Console.Error.WriteLine($"‚ùå Invalid argument: {ex.Message}");
-++                PrintUsageHint(context);
-+                 return 1;
-+             }
-++            catch (FileNotFoundException ex)
-++            {
-++                Logger.LogError(ex, "Required file not found");
-++                Console.Error.WriteLine($"‚ùå File not found: {ex.FileName ?? ex.Message}");
-++                Console.Error.WriteLine("Please verify that the file path is correct and accessible.");
-++                return 2;
-++            }
-++            catch (DirectoryNotFoundException ex)
-++            {
-++                Logger.LogError(ex, "Required directory not found");
-++                Console.Error.WriteLine($"‚ùå Directory not found: {ex.Message}");
-++                Console.Error.WriteLine("Please verify that the directory path is correct and accessible.");
-++                return 2;
-++            }
-++            catch (UnauthorizedAccessException ex)
-++            {
-++                Logger.LogError(ex, "Access denied to file or directory");
-++                Console.Error.WriteLine($"‚ùå Access denied: {ex.Message}");
-++                Console.Error.WriteLine("Please check file/directory permissions or run with appropriate privileges.");
-++                return 13; // Standard exit code for permission denied
-++            }
-++            catch (TimeoutException ex)
-++            {
-++                Logger.LogError(ex, "Operation timed out");
-++                Console.Error.WriteLine($"‚ùå Operation timed out: {ex.Message}");
-++                Console.Error.WriteLine("The operation took longer than expected. Try reducing the scope or running again.");
-++                return 124; // Standard exit code for timeout
-++            }
-++            catch (System.IO.FileLoadException ex) when (ex.Message.Contains("Microsoft.Bcl.AsyncInterfaces"))
-++            {
-++                Logger.LogError(ex, "Assembly loading conflict detected");
-++                Console.Error.WriteLine("‚ùå Assembly conflict detected:");
-++                Console.Error.WriteLine($"   {ex.Message}");
-++                Console.Error.WriteLine();
-++                Console.Error.WriteLine("üí° This is usually caused by conflicting package versions. Try:");
-++                Console.Error.WriteLine("   ‚Ä¢ Clearing NuGet cache: dotnet nuget locals all --clear");
-++                Console.Error.WriteLine("   ‚Ä¢ Rebuilding the solution: dotnet clean && dotnet build");
-++                Console.Error.WriteLine("   ‚Ä¢ Updating packages to consistent versions");
-++                return 125; // Custom exit code for assembly conflicts
-++            }
-++            catch (System.Reflection.ReflectionTypeLoadException ex)
-++            {
-++                Logger.LogError(ex, "Failed to load types from assembly");
-++                Console.Error.WriteLine("‚ùå Failed to load assembly types:");
-++                if (ex.LoaderExceptions != null)
-++                {
-++                    foreach (var loaderEx in ex.LoaderExceptions.Take(3))
-++                    {
-++                        Console.Error.WriteLine($"   ‚Ä¢ {loaderEx?.Message}");
-++                    }
-++                    if (ex.LoaderExceptions.Length > 3)
-++                    {
-++                        Console.Error.WriteLine($"   ... and {ex.LoaderExceptions.Length - 3} more errors");
-++                    }
-++                }
-++                Console.Error.WriteLine();
-++                Console.Error.WriteLine("üí° This usually indicates missing dependencies or version mismatches.");
-++                Console.Error.WriteLine("   Check that all required packages are installed and compatible.");
-++                return 126; // Custom exit code for type loading failures
-++            }
-++            catch (OutOfMemoryException ex)
-++            {
-++                Logger.LogError(ex, "Out of memory during command execution");
-++                Console.Error.WriteLine("‚ùå Insufficient memory to complete the operation.");
-++                Console.Error.WriteLine("üí° Try reducing the scope (e.g., analyze fewer files) or increase available memory.");
-++                return 127; // Custom exit code for memory issues
-++            }
-+             catch (Exception ex)
-+             {
-+                 Logger.LogError(ex, "Unexpected error during command execution");
-+-                Console.Error.WriteLine($"Error: {ex.Message}");
-++                Console.Error.WriteLine($"‚ùå Unexpected error: {ex.Message}");
-+                 
-+                 if (Logger.IsEnabled(LogLevel.Debug))
-+                 {
-+                     Console.Error.WriteLine($"Stack trace: {ex.StackTrace}");
-+                 }
-++                else
-++                {
-++                    Console.Error.WriteLine("Use --verbose for detailed error information.");
-++                }
-++                
-++                Console.Error.WriteLine();
-++                Console.Error.WriteLine("üí° If this error persists, please report it at:");
-++                Console.Error.WriteLine("   https://github.com/TestIntelligence/TestIntelligence/issues");
-+                 
-+                 return 1;
-+             }
++++ b/SELECT_COMMAND_VERIFICATION_REPORT.md
+@@ -0,0 +1,143 @@
++# Select Command Verification Report
++
++**Test Date**: 2025-09-04 00:33  
++**Test Scenario**: Modified NUnitTestDiscovery.cs (core component modification)  
++**Change Type**: Single comment addition to trigger analysis  
++
++## Executive Summary
++
++‚ùå **CRITICAL ISSUE IDENTIFIED**: The select command is not functioning correctly across all confidence levels. While the underlying analysis infrastructure works properly (as confirmed by find-tests and diff commands), the selection engine reports "No candidate tests found" even when relevant tests exist.
++
++## Test Results Summary
++
++| Confidence Level | Expected Behavior | Actual Result | Status |
++|------------------|-------------------|---------------|---------|
++| Fast (30s, 70%) | Select 3-8 direct tests | 0 tests selected | ‚ùå FAIL |
++| Medium (5m, 85%) | Select 15-25 related tests | 0 tests selected | ‚ùå FAIL |
++| High (15m, 95%) | Select 40-60 comprehensive tests | 0 tests selected | ‚ùå FAIL |
++| Full (complete, 100%) | Select all 866 tests | 0 tests selected | ‚ùå FAIL |
++
++## Detailed Analysis
++
++### Test Scenario Setup ‚úÖ
++- **Change Applied**: Added comment to `src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs`
++- **Tests Available**: 866 total tests in solution (confirmed by analyze command)
++- **Direct Tests Found**: 5 tests directly related to NUnitTestDiscovery (confirmed by find-tests command)
++
++### Confidence Level Testing Results
++
++#### Fast Confidence (Target: 30 sec, 70% confidence)
++```
++Selected Tests: 0
++Time Estimate: 0s
++Average Score: 0.000
++Status: "No candidate tests found for selection"
++```
++**Expected**: 3-8 direct tests with high confidence scores (0.8-1.0)
++**Issue**: Selection engine failed to identify any candidate tests
++
++#### Medium Confidence (Target: 5 min, 85% confidence)
++```
++Selected Tests: 0
++Time Estimate: 0s
++Average Score: 0.000
++Status: "No candidate tests found for selection"
++```
++**Expected**: 15-25 tests including direct and indirect dependencies
++**Issue**: Same failure pattern as Fast confidence
++
++#### High Confidence (Target: 15 min, 95% confidence)
++```
++Selected Tests: 0
++Time Estimate: 0s
++Average Score: 0.000
++Status: "No candidate tests found for selection"
++```
++**Expected**: 40-60 tests including integration tests
++**Issue**: Same failure pattern across all levels
++
++#### Full Confidence (Complete suite, 100% confidence)
++```
++Selected Tests: 0
++Time Estimate: 0s
++Average Score: 0.000
++Status: "No candidate tests found for selection"
++```
++**Expected**: All 866 tests in the solution
++**Issue**: Even Full confidence failed to select any tests
++
++### Cross-Reference Validation
++
++#### ‚úÖ Find-Tests Command Verification
++The find-tests command successfully identified relevant tests:
++```
++‚Ä¢ NUnitTestDiscoveryTests.DiscoverTestsAsync_WithValidAssembly_ReturnsResult (Confidence: 1.00)
++‚Ä¢ NUnitTestDiscoveryTests.DiscoverTestsAsync_WithNullAssembly_ThrowsArgumentNullException (Confidence: 1.00)
++‚Ä¢ NUnitTestDiscoveryTests.DiscoverTestsAsync_MultipleAssemblies_ReturnsResults (Confidence: 0.80)
++‚Ä¢ NUnitTestDiscoveryTests.DiscoverTestsAsync_MultipleAssemblies_WithNullInput_ThrowsArgumentNullException (Confidence: 0.80)
++```
++
++#### ‚úÖ Analyze Command Verification
++The analyze command successfully discovered:
++- **Total Assemblies**: 15
++- **Total Test Methods**: 866
++- **Categories**: Unit (755), UI (55), Database (54), Integration (2)
++
++#### ‚úÖ Diff Command Verification
++The diff command successfully identified impacts from git changes:
++- **Code Changes Detected**: 3 files with method-level changes
++- **Potentially Impacted Tests**: 13 test references found
++- **Change Detection**: Working correctly
++
++### Root Cause Analysis
++
++The evidence points to a **disconnect between the selection engine and the analysis infrastructure**:
++
++1. **Analysis Infrastructure is Working**: 
++   - find-tests command finds relevant tests with confidence scores
++   - analyze command discovers all tests correctly
++   - diff command detects code changes and impacts
++
++2. **Selection Engine is Failing**:
++   - All confidence levels report "No candidate tests found"
++   - No tests selected even with Full confidence
++   - Selection engine appears unable to connect file changes to available tests
++
++3. **Possible Issues**:
++   - File path resolution problem between select command and analysis engine
++   - Missing integration between SelectionEngine and TestCoverageAnalyzer
++   - Configuration or initialization issue in the selection workflow
++   - Bug in the candidate test discovery logic within the selection engine
++
++### Impact Assessment
++
++**Severity**: CRITICAL - Core functionality completely non-functional
++**User Impact**: High - Users cannot use intelligent test selection
++**Confidence in Findings**: High - Multiple cross-references confirm the issue
++
++### Recommendations
++
++#### Immediate Actions Required:
++1. **Debug Selection Engine Integration**: Investigate connection between SelectCommandHandler and TestSelectionEngine
++2. **Fix Candidate Discovery**: Review TestSelectionEngine.CreateOptimalTestPlan method
++3. **Validate File Path Handling**: Ensure file paths are correctly resolved between commands
++4. **Add Debug Logging**: Enhance logging in selection engine to identify failure point
++
++#### Verification Steps for Fix:
++1. Test with same scenario after fix
++2. Verify all confidence levels select appropriate test counts
++3. Confirm time estimates align with confidence targets
++4. Validate test relevance scores are meaningful
++
++### Test Environment Details
++
++- **.NET Version**: 8.0.204
++- **Solution Size**: 866 tests across 15 assemblies
++- **Test Frameworks**: Mixed (NUnit, xUnit, MSTest)
++- **Analysis Performance**: Good (find-tests: ~5s, analyze: ~15s)
++
++## Conclusion
++
++While the TestIntelligence analysis infrastructure is robust and functional, the select command - a core feature for intelligent test selection - is completely non-functional. This represents a critical bug that prevents users from leveraging the system's primary value proposition. The issue appears to be in the selection engine's candidate discovery logic rather than the underlying analysis capabilities.
++
++**Recommendation**: Prioritize immediate investigation and fix of the TestSelectionEngine before any release or deployment.
+\ No newline at end of file
+diff --git a/analyze-baseline.json b/analyze-baseline.json
+new file mode 100644
+index 0000000..fba5c66
+--- /dev/null
++++ b/analyze-baseline.json
+@@ -0,0 +1,92 @@
++=== Test Intelligence Analysis Report ===
++Path: TestIntelligence.sln
++Timestamp: 2025-09-04 00:33:12
++
++=== Summary ===
++Total Assemblies: 15
++Total Test Methods: 866
++Successfully Analyzed: 15
++Failed Analyses: 0
++
++=== Category Breakdown ===
++  Unit: 755 tests
++  UI: 55 tests
++  Database: 54 tests
++  Integration: 2 tests
++
++=== Assembly Details ===
++Assembly: TestIntelligence.Core.dll
++  Framework: NetStandard
++  Test Methods: 0
++
++Assembly: TestIntelligence.Categorizer.dll
++  Framework: NetStandard
++  Test Methods: 0
++
++Assembly: TestIntelligence.DataTracker.dll
++  Framework: NetStandard
++  Test Methods: 0
++
++Assembly: TestIntelligence.ImpactAnalyzer.dll
++  Framework: NetStandard
++  Test Methods: 0
++
++Assembly: TestIntelligence.SelectionEngine.dll
++  Framework: NetStandard
++  Test Methods: 0
++
++Assembly: TestIntelligence.Core.Tests.dll
++  Framework: Net5Plus
++  Test Methods: 300
++    Unit: 292 tests
++    Integration: 2 tests
++    UI: 1 tests
++    Database: 5 tests
++
++Assembly: TestIntelligence.DataTracker.Tests.dll
++  Framework: Net5Plus
++  Test Methods: 120
++    Unit: 74 tests
++    Database: 46 tests
++
++Assembly: TestIntelligence.ImpactAnalyzer.Tests.dll
++  Framework: Net5Plus
++  Test Methods: 336
++    Unit: 285 tests
++    UI: 49 tests
++    Database: 2 tests
++
++Assembly: TestIntelligence.Framework48Adapter.dll
++  Framework: NetStandard
++  Test Methods: 0
++
++Assembly: TestIntelligence.NetCoreAdapter.dll
++  Framework: NetStandard
++  Test Methods: 0
++
++Assembly: TestIntelligence.API.dll
++  Framework: Net5Plus
++  Test Methods: 0
++
++Assembly: TestIntelligence.API.Tests.dll
++  Framework: Net5Plus
++  Test Methods: 20
++    Unit: 20 tests
++
++Assembly: TestIntelligence.CLI.dll
++  Framework: Net5Plus
++  Test Methods: 0
++
++Assembly: TestIntelligence.SelectionEngine.Tests.dll
++  Framework: Net5Plus
++  Test Methods: 47
++    Unit: 45 tests
++    Database: 1 tests
++    UI: 1 tests
++
++Assembly: TestIntelligence.E2E.Tests.dll
++  Framework: Net5Plus
++  Test Methods: 43
++    Unit: 39 tests
++    UI: 4 tests
++
+diff --git a/diff-analysis.json b/diff-analysis.json
+new file mode 100644
+index 0000000..486eb56
+--- /dev/null
++++ b/diff-analysis.json
+@@ -0,0 +1 @@
++{"Summary":{"TotalChanges":3,"TotalFiles":3,"TotalMethods":13,"TotalImpactedTests":13,"AnalyzedAt":"2025-09-04T00:35:33.579242Z"},"CodeChanges":[{"FilePath":"src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs","ChangeType":"Modified","ChangedMethods":["ValidateTestMethod","IsTestMethod"],"ChangedTypes":[],"DetectedAt":"2025-09-04T00:35:32.681604+00:00"},{"FilePath":"src/TestIntelligence.DataTracker/TestDataDependencyTracker.cs","ChangeType":"Modified","ChangedMethods":["HasConflicts"],"ChangedTypes":[],"DetectedAt":"2025-09-04T00:35:32.6824+00:00"},{"FilePath":"src/TestIntelligence.ImpactAnalyzer/Analysis/GitDiffParser.cs","ChangeType":"Modified","ChangedMethods":["Variable_Regex","LogDebug","Matches","Variable_simpleMatches","Trim","Variable_methodName","Add","assignments","Variable_varMatches","Variable_varName"],"ChangedTypes":[],"DetectedAt":"2025-09-04T00:35:32.68812+00:00"}],"AffectedMethods":["ValidateTestMethod","IsTestMethod","HasConflicts","Variable_Regex","LogDebug","Matches","Variable_simpleMatches","Trim","Variable_methodName","Add","assignments","Variable_varMatches","Variable_varName"],"ImpactedTests":[{"Id":"Tests.AutoGenerated.ValidateTestMethodTest","MethodName":"ValidateTestMethodTest","TypeName":"AutoGenerated","Namespace":"Tests","AssemblyPath":"Generated.Tests","Confidence":0.8,"ImpactReasons":"Method name similarity"},{"Id":"Tests.AutoGenerated.IsTestMethodTest","MethodName":"IsTestMethodTest","TypeName":"AutoGenerated","Namespace":"Tests","AssemblyPath":"Generated.Tests","Confidence":0.8,"ImpactReasons":"Method name similarity"},{"Id":"Tests.AutoGenerated.HasConflictsTest","MethodName":"HasConflictsTest","TypeName":"AutoGenerated","Namespace":"Tests","AssemblyPath":"Generated.Tests","Confidence":0.8,"ImpactReasons":"Method name similarity"},{"Id":"Tests.AutoGenerated.Variable_RegexTest","MethodName":"Variable_RegexTest","TypeName":"AutoGenerated","Namespace":"Tests","AssemblyPath":"Generated.Tests","Confidence":0.8,"ImpactReasons":"Method name similarity"},{"Id":"Tests.AutoGenerated.LogDebugTest","MethodName":"LogDebugTest","TypeName":"AutoGenerated","Namespace":"Tests","AssemblyPath":"Generated.Tests","Confidence":0.8,"ImpactReasons":"Method name similarity"},{"Id":"Tests.AutoGenerated.MatchesTest","MethodName":"MatchesTest","TypeName":"AutoGenerated","Namespace":"Tests","AssemblyPath":"Generated.Tests","Confidence":0.8,"ImpactReasons":"Method name similarity"},{"Id":"Tests.AutoGenerated.Variable_simpleMatchesTest","MethodName":"Variable_simpleMatchesTest","TypeName":"AutoGenerated","Namespace":"Tests","AssemblyPath":"Generated.Tests","Confidence":0.8,"ImpactReasons":"Method name similarity"},{"Id":"Tests.AutoGenerated.TrimTest","MethodName":"TrimTest","TypeName":"AutoGenerated","Namespace":"Tests","AssemblyPath":"Generated.Tests","Confidence":0.8,"ImpactReasons":"Method name similarity"},{"Id":"Tests.AutoGenerated.Variable_methodNameTest","MethodName":"Variable_methodNameTest","TypeName":"AutoGenerated","Namespace":"Tests","AssemblyPath":"Generated.Tests","Confidence":0.8,"ImpactReasons":"Method name similarity"},{"Id":"Tests.AutoGenerated.AddTest","MethodName":"AddTest","TypeName":"AutoGenerated","Namespace":"Tests","AssemblyPath":"Generated.Tests","Confidence":0.8,"ImpactReasons":"Method name similarity"},{"Id":"Tests.AutoGenerated.assignmentsTest","MethodName":"assignmentsTest","TypeName":"AutoGenerated","Namespace":"Tests","AssemblyPath":"Generated.Tests","Confidence":0.8,"ImpactReasons":"Method name similarity"},{"Id":"Tests.AutoGenerated.Variable_varMatchesTest","MethodName":"Variable_varMatchesTest","TypeName":"AutoGenerated","Namespace":"Tests","AssemblyPath":"Generated.Tests","Confidence":0.8,"ImpactReasons":"Method name similarity"},{"Id":"Tests.AutoGenerated.Variable_varNameTest","MethodName":"Variable_varNameTest","TypeName":"AutoGenerated","Namespace":"Tests","AssemblyPath":"Generated.Tests","Confidence":0.8,"ImpactReasons":"Method name similarity"}]}
+\ No newline at end of file
+diff --git a/find-tests-cross-check.json b/find-tests-cross-check.json
+new file mode 100644
+index 0000000..c156acb
+--- /dev/null
++++ b/find-tests-cross-check.json
+@@ -0,0 +1,36 @@
++‚Ä¢ NUnitTestDiscoveryTests.DiscoverTestsAsync_WithValidAssembly_ReturnsResult
++  Assembly: NUnitTestDiscoveryTests.cs
++  Type: Unit
++  Confidence: 1.00
++  Call Depth: 1
++
++‚Ä¢ NUnitTestDiscovery.DiscoverTestsAsync
++  Assembly: NUnitTestDiscovery.cs
++  Type: Unit
++  Confidence: 1.00
++  Call Depth: 1
++
++‚Ä¢ NUnitTestDiscoveryTests.DiscoverTestsAsync_WithNullAssembly_ThrowsArgumentNullException
++  Assembly: NUnitTestDiscoveryTests.cs
++  Type: Unit
++  Confidence: 1.00
++  Call Depth: 1
++
++‚Ä¢ NUnitTestDiscoveryTests.DiscoverTestsAsync_MultipleAssemblies_ReturnsResults
++  Assembly: NUnitTestDiscoveryTests.cs
++  Type: Unit
++  Confidence: 0.80
++  Call Depth: 2
++
++‚Ä¢ NUnitTestDiscoveryTests.DiscoverTestsAsync_MultipleAssemblies_WithNullInput_ThrowsArgumentNullException
++  Assembly: NUnitTestDiscoveryTests.cs
++  Type: Unit
++  Confidence: 0.80
++  Call Depth: 2
++
++‚Ä¢ NUnitTestDiscovery.DiscoverTestsAsync
++  Assembly: NUnitTestDiscovery.cs
++  Type: Unit
++  Confidence: 0.00
++  Call Depth: 0
++
+diff --git a/find-tests-result.json b/find-tests-result.json
+new file mode 100644
+index 0000000..449c8df
+--- /dev/null
++++ b/find-tests-result.json
+@@ -0,0 +1,87 @@
++[
++  {
++    "TestMethodId": "global::TestIntelligence.Core.Tests.Discovery.NUnitTestDiscoveryTests.DiscoverTestsAsync_WithValidAssembly_ReturnsResult()",
++    "TestMethodName": "DiscoverTestsAsync_WithValidAssembly_ReturnsResult",
++    "TestClassName": "NUnitTestDiscoveryTests",
++    "TestAssembly": "NUnitTestDiscoveryTests.cs",
++    "CallPath": [
++      "global::TestIntelligence.Core.Tests.Discovery.NUnitTestDiscoveryTests.DiscoverTestsAsync_WithValidAssembly_ReturnsResult()",
++      "global::TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync(global::TestIntelligence.Core.Assembly.ITestAssembly,global::System.Threading.CancellationToken)"
++    ],
++    "Confidence": 1.0,
++    "TestType": "Unit",
++    "CallDepth": 1,
++    "IsDirectCoverage": true
++  },
++  {
++    "TestMethodId": "global::TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync(global::TestIntelligence.Core.Assembly.ITestAssembly,global::System.Threading.CancellationToken)",
++    "TestMethodName": "DiscoverTestsAsync",
++    "TestClassName": "NUnitTestDiscovery",
++    "TestAssembly": "NUnitTestDiscovery.cs",
++    "CallPath": [
++      "global::TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync(global::TestIntelligence.Core.Assembly.ITestAssembly,global::System.Threading.CancellationToken)"
++    ],
++    "Confidence": 0.0,
++    "TestType": "Unit",
++    "CallDepth": 0,
++    "IsDirectCoverage": false
++  },
++  {
++    "TestMethodId": "global::TestIntelligence.Core.Tests.Discovery.NUnitTestDiscoveryTests.DiscoverTestsAsync_MultipleAssemblies_ReturnsResults()",
++    "TestMethodName": "DiscoverTestsAsync_MultipleAssemblies_ReturnsResults",
++    "TestClassName": "NUnitTestDiscoveryTests",
++    "TestAssembly": "NUnitTestDiscoveryTests.cs",
++    "CallPath": [
++      "global::TestIntelligence.Core.Tests.Discovery.NUnitTestDiscoveryTests.DiscoverTestsAsync_MultipleAssemblies_ReturnsResults()",
++      "global::TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync(global::System.Collections.Generic.IEnumerable<global::TestIntelligence.Core.Assembly.ITestAssembly>,global::System.Threading.CancellationToken)",
++      "global::TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync(global::TestIntelligence.Core.Assembly.ITestAssembly,global::System.Threading.CancellationToken)"
++    ],
++    "Confidence": 0.8,
++    "TestType": "Unit",
++    "CallDepth": 2,
++    "IsDirectCoverage": false
++  },
++  {
++    "TestMethodId": "global::TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync(global::System.Collections.Generic.IEnumerable<global::TestIntelligence.Core.Assembly.ITestAssembly>,global::System.Threading.CancellationToken)",
++    "TestMethodName": "DiscoverTestsAsync",
++    "TestClassName": "NUnitTestDiscovery",
++    "TestAssembly": "NUnitTestDiscovery.cs",
++    "CallPath": [
++      "global::TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync(global::System.Collections.Generic.IEnumerable<global::TestIntelligence.Core.Assembly.ITestAssembly>,global::System.Threading.CancellationToken)",
++      "global::TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync(global::TestIntelligence.Core.Assembly.ITestAssembly,global::System.Threading.CancellationToken)"
++    ],
++    "Confidence": 1.0,
++    "TestType": "Unit",
++    "CallDepth": 1,
++    "IsDirectCoverage": true
++  },
++  {
++    "TestMethodId": "global::TestIntelligence.Core.Tests.Discovery.NUnitTestDiscoveryTests.DiscoverTestsAsync_MultipleAssemblies_WithNullInput_ThrowsArgumentNullException()",
++    "TestMethodName": "DiscoverTestsAsync_MultipleAssemblies_WithNullInput_ThrowsArgumentNullException",
++    "TestClassName": "NUnitTestDiscoveryTests",
++    "TestAssembly": "NUnitTestDiscoveryTests.cs",
++    "CallPath": [
++      "global::TestIntelligence.Core.Tests.Discovery.NUnitTestDiscoveryTests.DiscoverTestsAsync_MultipleAssemblies_WithNullInput_ThrowsArgumentNullException()",
++      "global::TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync(global::System.Collections.Generic.IEnumerable<global::TestIntelligence.Core.Assembly.ITestAssembly>,global::System.Threading.CancellationToken)",
++      "global::TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync(global::TestIntelligence.Core.Assembly.ITestAssembly,global::System.Threading.CancellationToken)"
++    ],
++    "Confidence": 0.8,
++    "TestType": "Unit",
++    "CallDepth": 2,
++    "IsDirectCoverage": false
++  },
++  {
++    "TestMethodId": "global::TestIntelligence.Core.Tests.Discovery.NUnitTestDiscoveryTests.DiscoverTestsAsync_WithNullAssembly_ThrowsArgumentNullException()",
++    "TestMethodName": "DiscoverTestsAsync_WithNullAssembly_ThrowsArgumentNullException",
++    "TestClassName": "NUnitTestDiscoveryTests",
++    "TestAssembly": "NUnitTestDiscoveryTests.cs",
++    "CallPath": [
++      "global::TestIntelligence.Core.Tests.Discovery.NUnitTestDiscoveryTests.DiscoverTestsAsync_WithNullAssembly_ThrowsArgumentNullException()",
++      "global::TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync(global::TestIntelligence.Core.Assembly.ITestAssembly,global::System.Threading.CancellationToken)"
++    ],
++    "Confidence": 1.0,
++    "TestType": "Unit",
++    "CallDepth": 1,
++    "IsDirectCoverage": true
++  }
++]
+\ No newline at end of file
+diff --git a/select-fast-fixed-debug.json b/select-fast-fixed-debug.json
+new file mode 100644
+index 0000000..9bf3359
+--- /dev/null
++++ b/select-fast-fixed-debug.json
+@@ -0,0 +1,88 @@
++=== Test Selection Report ===
++Path: TestIntelligence.sln
++Timestamp: 2025-09-04 00:44:45
++Confidence Level: Fast
++Changed Files: NUnitTestDiscovery.cs
++
++=== Selection Summary ===
++Selected Tests: 18
++Estimated Duration: 2s
++Average Score: 0.690
++Optimal Parallelism: 4
++
++=== Category Breakdown ===
++  Integration: 18 tests
++
++=== Selected Tests ===
++‚Ä¢ CacheInvalidationIntegrationTests.SolutionCacheManager_InvalidatesOnFileChange
++  Score: 0.690 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CacheInvalidationIntegrationTests.ProjectCacheManager_InvalidatesOnContentChange
++  Score: 0.690 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CacheInvalidationIntegrationTests.CallGraphCache_InvalidatesOnProjectFileChange
++  Score: 0.690 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CacheInvalidationIntegrationTests.EndToEndCacheInvalidation_WorksAcrossAllLayers
++  Score: 0.690 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CacheInvalidationIntegrationTests.CacheInvalidation_PerformanceTest
++  Score: 0.690 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.Resolver_WithCircularDependency_CanBeTestedThroughIntegration
++  Score: 0.690 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.TryUnloadAssembly_Integration_ReturnsExpectedValue
++  Score: 0.690 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceTestExecutionAsync_WithDeepCallChain_HandlesMaxDepthCorrectly
++  Score: 0.690 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceTestExecutionAsync_WithCircularReferences_PreventsInfiniteLoop
++  Score: 0.690 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceTestExecutionAsync_WithLargeBreadth_LimitsBreadthCorrectly
++  Score: 0.690 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceTestExecutionAsync_WithCachingEnabled_UsesCachedResults
++  Score: 0.690 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceMultipleTestsAsync_WithLargeTestSuite_UsesParallelProcessing
++  Score: 0.690 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceTestExecutionAsync_WithAsyncMethods_TracesCorrectly
++  Score: 0.690 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.GenerateCoverageReportAsync_WithMixedCodebase_GeneratesAccurateReport
++  Score: 0.690 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceTestExecutionAsync_WithGenericMethods_HandlesCorrectly
++  Score: 0.690 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CompilationCacheIntegrationTests.OptimizedAnalyzer_ShowsPerformanceImprovement
++  Score: 0.690 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CompilationCacheIntegrationTests.EnhancedCache_MultiLevelCaching_WorksCorrectly
++  Score: 0.690 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CompilationCacheIntegrationTests.SyntaxTreePool_ShowsMemoryOptimization
++  Score: 0.690 | Category: Integration | Duration: 0s
++  Tags: Integration
++
+diff --git a/select-fast-fixed.json b/select-fast-fixed.json
+new file mode 100644
+index 0000000..9ebc28a
+--- /dev/null
++++ b/select-fast-fixed.json
+@@ -0,0 +1,15 @@
++=== Test Selection Report ===
++Path: TestIntelligence.sln
++Timestamp: 2025-09-04 00:42:16
++Confidence Level: Fast
++Changed Files: NUnitTestDiscovery.cs
++
++=== Selection Summary ===
++Selected Tests: 0
++Estimated Duration: 0s
++Average Score: 0.000
++Optimal Parallelism: 0
++
++=== Category Breakdown ===
++
++=== Selected Tests ===
+diff --git a/select-fast.json b/select-fast.json
+new file mode 100644
+index 0000000..628777f
+--- /dev/null
++++ b/select-fast.json
+@@ -0,0 +1,15 @@
++=== Test Selection Report ===
++Path: TestIntelligence.sln
++Timestamp: 2025-09-04 00:33:25
++Confidence Level: Fast
++Changed Files: NUnitTestDiscovery.cs
++
++=== Selection Summary ===
++Selected Tests: 0
++Estimated Duration: 0s
++Average Score: 0.000
++Optimal Parallelism: 0
++
++=== Category Breakdown ===
++
++=== Selected Tests ===
+diff --git a/select-full.json b/select-full.json
+new file mode 100644
+index 0000000..a5cbed7
+--- /dev/null
++++ b/select-full.json
+@@ -0,0 +1,3483 @@
++=== Test Selection Report ===
++Path: TestIntelligence.sln
++Timestamp: 2025-09-04 00:56:51
++Confidence Level: Full
++Changed Files: NUnitTestDiscovery.cs
++
++=== Selection Summary ===
++Selected Tests: 866
++Estimated Duration: 1.4m
++Average Score: 0.446
++Optimal Parallelism: 4
++
++=== Category Breakdown ===
++  Unit: 719 tests
++  UI: 75 tests
++  Database: 54 tests
++  Integration: 18 tests
++
++=== Selected Tests ===
++‚Ä¢ CacheInvalidationIntegrationTests.SolutionCacheManager_InvalidatesOnFileChange
++  Score: 0.633 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CacheInvalidationIntegrationTests.ProjectCacheManager_InvalidatesOnContentChange
++  Score: 0.633 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CacheInvalidationIntegrationTests.CallGraphCache_InvalidatesOnProjectFileChange
++  Score: 0.633 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CacheInvalidationIntegrationTests.EndToEndCacheInvalidation_WorksAcrossAllLayers
++  Score: 0.633 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CacheInvalidationIntegrationTests.CacheInvalidation_PerformanceTest
++  Score: 0.633 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.Resolver_WithCircularDependency_CanBeTestedThroughIntegration
++  Score: 0.633 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.TryUnloadAssembly_Integration_ReturnsExpectedValue
++  Score: 0.633 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceTestExecutionAsync_WithDeepCallChain_HandlesMaxDepthCorrectly
++  Score: 0.633 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceTestExecutionAsync_WithCircularReferences_PreventsInfiniteLoop
++  Score: 0.633 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceTestExecutionAsync_WithLargeBreadth_LimitsBreadthCorrectly
++  Score: 0.633 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceTestExecutionAsync_WithCachingEnabled_UsesCachedResults
++  Score: 0.633 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceMultipleTestsAsync_WithLargeTestSuite_UsesParallelProcessing
++  Score: 0.633 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceTestExecutionAsync_WithAsyncMethods_TracesCorrectly
++  Score: 0.633 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.GenerateCoverageReportAsync_WithMixedCodebase_GeneratesAccurateReport
++  Score: 0.633 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceTestExecutionAsync_WithGenericMethods_HandlesCorrectly
++  Score: 0.633 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CompilationCacheIntegrationTests.OptimizedAnalyzer_ShowsPerformanceImprovement
++  Score: 0.633 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CompilationCacheIntegrationTests.EnhancedCache_MultiLevelCaching_WorksCorrectly
++  Score: 0.633 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CompilationCacheIntegrationTests.SyntaxTreePool_ShowsMemoryOptimization
++  Score: 0.633 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.AssemblyLoaded_EventHandlers_ShouldBeInvokable
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.AssemblyLoadFailed_EventHandlers_ShouldBeInvokable
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssembly_ConcurrentCalls_ShouldBeThreadSafe
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_ShouldBeCaseInsensitive
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_ConcurrentCalls_ShouldBeThreadSafe
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ DataConflictTests.Constructor_WithNullTestMethodB_ThrowsArgumentNullException
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ DatabaseFrameworkTests.DatabaseFramework_EnumValues_AreCorrect
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ DatabaseFrameworkTests.DatabaseFramework_ToString_ReturnsCorrectName
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ DatabaseFrameworkTests.DatabaseFramework_AllValuesAreDefined
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.DetectDatabaseOperationsAsync_WithNullTestMethod_ThrowsArgumentNullException
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.DetectDatabaseOperationsAsync_WithValidTestMethod_ReturnsEmptyList
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.DetectDatabaseOperationsAsync_WithCancellationToken_RespectsToken
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.DetectDatabaseOperationsAsync_WithSetupMethods_HandlesNullEnumerable
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.DetectDatabaseOperationsAsync_WithSetupMethods_ReturnsEmptyListForEmptyEnumerable
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.DetectDatabaseOperationsAsync_WithSetupMethods_ProcessesMultipleMethods
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.RequiresExclusiveDbAccess_WithMethodNameIndicatingExclusiveAccess_ReturnsTrue
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.RequiresExclusiveDbAccess_WithNormalTestMethod_ReturnsFalse
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.RequiresExclusiveDbAccess_WithNullTestMethod_ThrowsArgumentNullException
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.SharesDatabaseDependency_WithNullParameters_ThrowsArgumentNullException
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.SharesDatabaseDependency_WithNoDatabaseDependencies_ReturnsFalse
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.SharesDatabaseDependency_WithSameResourceIdentifier_ReturnsTrue
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.SharesDatabaseDependency_WithSharedEntityTypes_ReturnsTrue
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.SharesDatabaseDependency_WithNoSharedDependencies_ReturnsFalse
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.DetectDbContextUsageAsync_WithNullMethod_ThrowsArgumentNullException
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.DetectDbContextUsageAsync_WithValidMethod_ReturnsResult
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.RequiresExclusiveDbAccess_WithExceptionThrown_ReturnsTrue
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectDatabaseOperationsAsync_WithNullTestMethod_ThrowsArgumentNullException
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectDatabaseOperationsAsync_WithValidTestMethod_ReturnsEmptyList
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectDatabaseOperationsAsync_WithCancellationToken_RespectsToken
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectDatabaseOperationsAsync_WithSetupMethods_HandlesNullEnumerable
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectDatabaseOperationsAsync_WithSetupMethods_ReturnsEmptyListForEmptyEnumerable
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectDatabaseOperationsAsync_WithSetupMethods_ProcessesMultipleMethods
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.RequiresExclusiveDbAccess_WithInMemoryDatabase_ReturnsFalse
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.RequiresExclusiveDbAccess_WithNullTestMethod_ThrowsArgumentNullException
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.SharesDatabaseDependency_WithNullParameters_ThrowsArgumentNullException
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.SharesDatabaseDependency_WithNoDatabaseDependencies_ReturnsFalse
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.SharesDatabaseDependency_WithSameInMemoryDatabase_ReturnsTrue
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.SharesDatabaseDependency_WithDifferentInMemoryDatabases_ReturnsFalse
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.SharesDatabaseDependency_WithSameResourceIdentifier_ReturnsTrue
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.SharesDatabaseDependency_WithSharedEntityTypes_ReturnsTrue
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.SharesDatabaseDependency_WithNoSharedDependencies_ReturnsFalse
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectDbContextUsageAsync_WithNullMethod_ThrowsArgumentNullException
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectDbContextUsageAsync_WithValidMethod_ReturnsResult
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectInMemoryDatabaseUsageAsync_WithNullMethod_ThrowsArgumentNullException
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectInMemoryDatabaseUsageAsync_WithValidMethod_ReturnsResult
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.RequiresExclusiveDbAccess_WithExceptionThrown_ReturnsFalse
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.RequiresExclusiveDbAccess_CurrentBehavior_BlocksOnAsyncCall
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.RequiresExclusiveDbAccess_CurrentBehaviorWithException_HandlesGracefully
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ HelperClassTests.InMemoryDatabaseUsage_Constructor_WithValidParameters_SetsProperties
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ HelperClassTests.InMemoryDatabaseUsage_Constructor_WithNullDatabaseName_ThrowsArgumentNullException
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ HelperClassTests.InMemoryDatabaseUsage_Constructor_WithNullContextType_ThrowsArgumentNullException
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ SyntaxTreePoolOptionsTests.Options_ShouldBeConfigurable
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ CancellationHandlingTests.CancellationDuringWorkspaceInitialization_ShouldBeHandledGracefully
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ TestSelectionEngineTests.ScoreTestsAsync_WithCodeChanges_ShouldBoostRelatedTests
++  Score: 0.513 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ ConsoleAssemblyLoadLoggerTests.LogDebug_InDebugBuild_ShouldWriteToConsole
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ StreamingTestCoverageAnalyzerTests.FindTestsExercisingMethodStreamAsync_WithCallGraphBuildFailure_ShouldUseFallback
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ TestCoverageAnalyzerTests.BuildTestCoverageMapAsync_WithValidSolution_ReturnsTestCoverageMap
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ BasicRoslynTests.BuildCallGraphAsync_WithEmptyFiles_ReturnsEmptyGraph
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ CancellationHandlingTests.BuildCallGraphAsync_WithPreCancelledToken_ShouldThrowOperationCanceledException
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ CancellationHandlingTests.BuildCallGraphAsync_WithTokenCancelledDuringExecution_ShouldThrowOperationCanceledException
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ CancellationHandlingTests.BuildCallGraphAsync_WithTimeoutToken_ShouldRespectTimeout
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ CancellationHandlingTests.BuildCallGraphAsync_WithVariousTimeouts_ShouldHandleCorrectly
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ EnhancedRoslynAnalyzerTests.BuildCallGraph_WithCrossProjectCalls_ShouldCaptureAllReferences
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.BuildCallGraphForMethodAsync_WithValidMethod_ShouldReturnCallGraph
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.BuildCallGraphForMethodAsync_WithNonexistentMethod_ShouldReturnEmptyGraph
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.BuildCallGraphForMethodAsync_WithMaxDepthLimit_ShouldRespectDepth
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.BuildCallGraphForMethodsAsync_WithMultipleMethods_ShouldCombineResults
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.BuildCallGraphForMethodAsync_WithCachedResult_ShouldUseCacheOnSecondCall
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.BuildCallGraphForMethodAsync_WithCompilationError_ShouldHandleGracefully
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.ClearCaches_ShouldResetInternalCaches
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.BuildCallGraphForMethodAsync_WithCancellation_ShouldRespectCancellationToken
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.BuildCallGraphForMethodsAsync_WithEmptyMethodList_ShouldReturnEmptyResult
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.BuildCallGraphForMethodAsync_WithInvalidMaxDepth_ShouldHandleGracefully
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.InitializeAsync_WithValidSolution_ShouldSucceed
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.InitializeAsync_WithSingleProject_ShouldSucceed
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetOrLoadProjectAsync_WithValidProject_ShouldLoadProject
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetOrLoadProjectAsync_WithSameProjectTwice_ShouldUseCache
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetOrLoadProjectAsync_WithNonexistentProject_ShouldReturnNull
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetCompilationAsync_WithValidProject_ShouldReturnCompilation
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetCompilationAsync_WithSameProjectTwice_ShouldUseCache
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetProjectContainingFileAsync_WithValidFile_ShouldReturnProject
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetProjectContainingFileAsync_WithNonexistentFile_ShouldReturnNull
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetProjectsContainingMethodAsync_WithValidMethod_ShouldReturnProjects
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetAllProjectPathsAsync_ShouldReturnAllProjects
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.PreloadProjectsAsync_ShouldLoadProjectsInBackground
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetStats_ShouldReturnAccurateStatistics
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.ClearCaches_ShouldResetCachedData
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.InitializeAsync_WithInvalidPath_ShouldHandleGracefully
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.WorkspaceStats_LoadedProjectsPercentage_ShouldCalculateCorrectly
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.WorkspaceStats_LoadedProjectsPercentage_WithZeroTotal_ShouldReturnZero
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerCallGraphTests.BuildCallGraphAsync_CapturesConstructorCalls
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerCallGraphTests.BuildCallGraphAsync_CapturesPropertyAccess
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerCallGraphTests.BuildCallGraphAsync_CapturesMethodInvocations
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerCallGraphTests.BuildCallGraphAsync_IdentifiesTestMethods
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerCallGraphTests.BuildCallGraphAsync_HandlesComplexCallChains
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerEdgeCaseTests.BuildCallGraphAsync_WithGenericMethods_ShouldHandleCorrectly
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerEdgeCaseTests.BuildCallGraphAsync_WithInterfaceImplementations_ShouldDetectPolymorphism
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerEdgeCaseTests.BuildCallGraphAsync_WithLambdaExpressions_ShouldHandleCorrectly
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerEdgeCaseTests.BuildCallGraphAsync_WithAsyncAwaitPattern_ShouldHandleCorrectly
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerEdgeCaseTests.BuildCallGraphAsync_WithReflectionCalls_ShouldHandleGracefully
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerEdgeCaseTests.BuildCallGraphAsync_WithCircularReferences_ShouldHandleWithoutInfiniteLoop
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerEdgeCaseTests.BuildCallGraphAsync_WithLargeCodebase_ShouldPerformReasonably
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithLazyWorkspace_ShouldInitializeLazilyOnFirstCall
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithLazyWorkspace_ShouldFallbackToLegacyOnFailure
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithValidSolution_ShouldPreferIncrementalAnalysis
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithMultipleCalls_ShouldReuseInfrastructure
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithCancellation_ShouldHandleGracefully
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithEmptyFileList_ShouldReturnEmptyGraph
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithInvalidSolutionPath_ShouldFallbackGracefully
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithMixedFileTypes_ShouldHandleAppropriately
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithRepeatedCalls_ShouldMaintainPerformance
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithLargeTimeout_ShouldCompleteWithinReasonableTime
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerTests.BuildCallGraphAsync_WithSimpleClass_ShouldReturnCallGraph
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerTests.BuildCallGraphAsync_WithCancellationToken_ShouldRespectCancellation
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.BuildCallGraphAsync_WithNonExistentFiles_ShouldFallbackToFileAnalysis
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.BuildCallGraphAsync_WithMalformedSolutionFile_ShouldFallbackGracefully
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.BuildCallGraphAsync_WithCancellationDuringInitialization_ShouldThrowOperationCanceledException
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.BuildCallGraphAsync_WithMemoryPressure_ShouldHandleGracefully
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynCoreComponentTests.BuildCallGraphAsync_WithEmptyFiles_ShouldReturnEmptyCallGraph
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ SymbolIndexTests.BuildIndexAsync_WithValidSolution_ShouldIndexAllMethods
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ SymbolIndexTests.BuildIndexAsync_WithProjectFile_ShouldWork
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ TestSelectionEngineTests.ScoreTestsAsync_WithLargeTestSuite_ShouldHandlePerformantly
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ AnalyzeCommandE2ETests.Analyze_WithMissingRequiredArguments_ShowsHelp
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ CallGraphCommandE2ETests.CallGraph_WithMissingRequiredArguments_ShowsHelp
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ DiffCommandE2ETests.Diff_WithMissingRequiredArguments_ShowsHelp
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ FindTestsCommandE2ETests.FindTests_WithMissingRequiredArguments_ShowsHelp
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ QuickValidationE2ETests.CLI_Version_Command_Works
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ QuickValidationE2ETests.CLI_Help_Command_Works
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ QuickValidationE2ETests.CLI_InvalidCommand_ShowsError
++  Score: 0.473 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ TestCoverageInfoTests.Constructor_WithValidParameters_CreatesInstance
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.Constructor_WithInvalidConfidence_ClampsToValidRange
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.Constructor_WithNullTestMethodId_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.Constructor_WithNullCallPath_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.CallDepth_WithVariousCallPaths_ReturnsCorrectDepth
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.IsDirectCoverage_WithVariousCallPaths_ReturnsCorrectValue
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.GetCallPathDisplay_WithMultipleSteps_ReturnsFormattedPath
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.ToString_ReturnsExpectedFormat
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.Equals_WithSameMethodIdAndCallPath_ReturnsTrue
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.Equals_WithDifferentMethodId_ReturnsFalse
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.GetHashCode_WithSameMethodIdAndCallPath_ReturnsSameValue
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageMapTests.Constructor_WithValidParameters_CreatesInstance
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageMapTests.Constructor_WithNullMethodToTests_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageMapTests.Constructor_WithNullSolutionPath_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageMapTests.GetTestsForMethod_WithExistingMethod_ReturnsTests
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageMapTests.GetTestsForMethod_WithNonExistentMethod_ReturnsEmptyList
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageMapTests.GetCoveredMethods_WithMultipleMethods_ReturnsAllMethodIds
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageMapTests.CoveredMethodCount_ReturnsCorrectCount
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageMapTests.TotalCoverageRelationships_ReturnsCorrectCount
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageStatisticsTests.Constructor_WithValidParameters_CreatesInstance
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageStatisticsTests.CoveragePercentage_WithVariousValues_ReturnsCorrectPercentage
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageStatisticsTests.UncoveredMethods_WithVariousValues_ReturnsCorrectCount
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageStatisticsTests.Constructor_WithNullCoverageByTestType_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.Constructor_WithValidParameters_SetsProperties
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.Constructor_WithNullType_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.Constructor_WithNullAssemblyPath_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.GetUniqueId_ReturnsFullClassName
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.TestMethods_IsInitialized
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.FixtureAttributes_IsInitialized
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.HasSetUpMethods_WithNoSetupMethods_ReturnsFalse
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.HasTearDownMethods_WithNoTearDownMethods_ReturnsFalse
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.HasTests_WithNoTestMethods_ReturnsFalse
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.GetExecutableTests_ReturnsExpectedCollection
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.GetSetUpMethods_ReturnsExpectedCollection
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.GetTearDownMethods_ReturnsExpectedCollection
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.GetCategories_ReturnsExpectedCollection
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.ToString_ReturnsExpectedFormat
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.Constructor_WithValidParameters_SetsProperties
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.Constructor_WithNullMethodInfo_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.Constructor_WithNullDeclaringType_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.Constructor_WithNullAssemblyPath_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.GetUniqueId_ReturnsExpectedFormat
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.GetDisplayName_ReturnsExpectedFormat
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.IsExecutableTest_WithRegularMethod_ReturnsFalse
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.TestAttributes_IsInitialized
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.ToString_ReturnsDisplayName
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.GetTestCaseParameters_WithRegularMethod_ReturnsEmpty
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NUnitTestDiscoveryTests.IsTestFixture_WithNullType_ReturnsFalse
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NUnitTestDiscoveryTests.IsTestFixture_WithNonTestClass_ReturnsFalse
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NUnitTestDiscoveryTests.IsTestMethod_WithNullMethod_ReturnsFalse
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NUnitTestDiscoveryTests.IsTestMethod_WithRegularMethod_ReturnsFalse
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NUnitTestDiscoveryTests.DiscoverTestsAsync_WithNullAssembly_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NUnitTestDiscoveryTests.DiscoverTestsAsync_WithValidAssembly_ReturnsResult
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NUnitTestDiscoveryTests.DiscoverTestsAsync_MultipleAssemblies_WithNullInput_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NUnitTestDiscoveryTests.DiscoverTestsAsync_MultipleAssemblies_ReturnsResults
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryStartedEventArgsTests.Constructor_ShouldSetPropertiesCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryStartedEventArgsTests.Constructor_WithNullAssemblyPath_ShouldSetNullAssemblyPath
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryStartedEventArgsTests.Constructor_WithEmptyAssemblyPath_ShouldSetEmptyAssemblyPath
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryCompletedEventArgsTests.Constructor_ShouldSetPropertiesCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryCompletedEventArgsTests.Constructor_WithNullAssemblyPath_ShouldSetNullAssemblyPath
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryCompletedEventArgsTests.Constructor_WithNullResult_ShouldSetNullResult
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryErrorEventArgsTests.Constructor_ShouldSetPropertiesCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryErrorEventArgsTests.Constructor_WithNullAssemblyPath_ShouldSetNullAssemblyPath
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryErrorEventArgsTests.Constructor_WithNullException_ShouldSetNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryFactoryTests.CreateNUnitTestDiscovery_ShouldReturnNUnitTestDiscoveryInstance
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfigurationServiceTests.LoadConfigurationAsync_WithNonExistentDirectory_ReturnsDefaultConfiguration
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfigurationServiceTests.LoadConfigurationAsync_WithSolutionFile_LoadsFromSolutionDirectory
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfigurationServiceTests.CreateDefaultConfigurationAsync_CreatesValidJsonFile
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfigurationServiceTests.LoadConfigurationFromFileAsync_WithValidJson_LoadsCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfigurationServiceTests.FilterProjects_WithEmptyList_ReturnsEmpty
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfigurationServiceTests.FilterProjects_WithExcludePatterns_FiltersCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfigurationServiceTests.FilterProjects_WithIncludePatterns_FiltersCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfigurationServiceTests.FilterProjects_WithExcludeTypes_FiltersCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfigurationServiceTests.FilterProjects_WithBothIncludeAndExclude_ExcludeTakesPrecedence
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfigurationServiceTests.AnalyzeProjectFilteringAsync_WithNonExistentSolution_ReturnsEmptyResult
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfigurationServiceTests.AnalyzeProjectFilteringAsync_WithMockSolution_AnalyzesCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.GetOrCacheTestDiscoveryAsync_WithNullAssemblyPath_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.GetOrCacheTestDiscoveryAsync_WithNullFactory_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.GetOrCacheTestDiscoveryAsync_WithValidInput_CallsFactory
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.GetOrCacheAssemblyLoadAsync_WithNullAssemblyPath_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.GetOrCacheAssemblyLoadAsync_WithNullFactory_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.GetOrCacheAssemblyLoadAsync_WithValidInput_CallsFactory
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.CacheFrameworkVersionAsync_WithNullAssemblyPath_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.CacheFrameworkVersionAsync_WithValidInput_DoesNotThrow
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.GetCachedFrameworkVersionAsync_WithNullAssemblyPath_ReturnsNull
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.GetCachedFrameworkVersionAsync_WithNonCachedAssembly_ReturnsNull
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.InvalidateAssemblyAsync_WithValidPath_DoesNotThrow
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.ClearAllAsync_DoesNotThrow
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.GetModifiedAssembliesAsync_WithNullInput_ReturnsEmptyList
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.Dispose_CanBeCalledMultipleTimes
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.CompressAsync_WithValidObject_ReturnsCompressedData
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.CompressAsync_WithNullObject_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.DecompressAsync_WithValidCompressedData_ReturnsOriginalObject
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.DecompressAsync_WithNullCompressedData_ReturnsNull
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.DecompressAsync_WithEmptyCompressedData_ReturnsNull
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.CompressToStreamAsync_WithValidObject_WritesToStream
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.CompressToStreamAsync_WithNullObject_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.CompressToStreamAsync_WithNullStream_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.DecompressFromStreamAsync_WithValidStream_ReturnsOriginalObject
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.DecompressFromStreamAsync_WithNullStream_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.EstimateCompressionRatio_WithValidObject_ReturnsReasonableEstimate
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.EstimateCompressionRatio_WithNullObject_ReturnsZero
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.EstimateCompressionRatio_WithSmallObject_ProcessesDirectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.CompressionRoundTrip_WithComplexObject_MaintainsDataIntegrity
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.CompressAsync_WithDifferentCompressionLevels_ProducesDifferentResults
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.CompressDecompress_WithCancellation_RespectsCancellationToken
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.GetAsync_WithNonExistentKey_ReturnsNull
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.SetAsync_WithValidData_StoresCompressedData
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.SetAsync_WithNullKey_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.SetAsync_WithNullValue_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.GetAsync_WithExpiredEntry_ReturnsNull
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.RemoveAsync_WithExistingKey_RemovesEntry
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.RemoveAsync_WithNonExistentKey_ReturnsFalse
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.GetCompressedSizeAsync_WithExistingEntry_ReturnsSize
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.GetCompressedSizeAsync_WithNonExistentKey_ReturnsNull
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.GetStatsAsync_WithMultipleEntries_ReturnsAccurateStats
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.GetOrSetAsync_WithExistingKey_ReturnsExistingValue
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.GetOrSetAsync_WithNewKey_CallsFactory
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.ClearAsync_RemovesAllEntries
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.PerformMaintenanceAsync_RemovesExpiredEntries
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.StorageLimitEnforcement_EvictsOldestEntries
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.CompressionEffectiveness_AchievesGoodRatio
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.ConcurrentAccess_HandlesMultipleOperations
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.CacheResilience_HandlesCorruptedFiles
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.GetAsync_WithNonExistentKey_ReturnsNull
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.GetAsync_WithNullKey_ReturnsNull
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.SetAsync_WithValidKeyAndValue_StoresValue
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.SetAsync_WithNullKey_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.SetAsync_WithNullValue_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.RemoveAsync_WithExistingKey_RemovesValue_ReturnsTrue
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.RemoveAsync_WithNonExistentKey_ReturnsFalse
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.ExistsAsync_WithExistingKey_ReturnsTrue
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.ExistsAsync_WithNonExistentKey_ReturnsFalse
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.ClearAsync_RemovesAllEntries
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.GetOrSetAsync_WithNonExistentKey_CallsFactory
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.GetOrSetAsync_WithExistingKey_DoesNotCallFactory
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.GetOrSetAsync_WithNullKey_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.GetOrSetAsync_WithNullFactory_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.GetStatistics_ReturnsValidStatistics
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.Dispose_CanBeCalledMultipleTimes
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ PersistentCacheProviderTests.GetAsync_WhenKeyDoesNotExist_ReturnsNull
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ PersistentCacheProviderTests.SetAndGetAsync_WhenValueExists_ReturnsValue
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ PersistentCacheProviderTests.GetAsync_WhenEntryExpired_ReturnsNull
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ PersistentCacheProviderTests.ExistsAsync_WhenKeyExists_ReturnsTrue
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ PersistentCacheProviderTests.ExistsAsync_WhenKeyDoesNotExist_ReturnsFalse
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ PersistentCacheProviderTests.RemoveAsync_WhenKeyExists_ReturnsTrue
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ PersistentCacheProviderTests.GetOrSetAsync_WhenKeyDoesNotExist_CreatesAndReturnsValue
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ PersistentCacheProviderTests.GetOrSetAsync_WhenKeyExists_ReturnsExistingValue
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ PersistentCacheProviderTests.ClearAsync_RemovesAllEntries
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ PersistentCacheProviderTests.GetStatisticsAsync_ReturnsAccurateStats
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ PersistentCacheProviderTests.CleanupExpiredAsync_RemovesOnlyExpiredEntries
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ PersistentCacheProviderTests.MultipleThreads_CanAccessCacheConcurrently
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ PersistentCacheProviderTests.Constructor_CreatesDirectoryIfNotExists
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.GetProjectAsync_WithNoCachedEntry_ReturnsNull
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.CreateProjectEntryAsync_WithValidProject_CreatesEntry
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.StoreProjectAsync_WithValidEntry_StoresSuccessfully
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.GetProjectAsync_WithValidCachedEntry_ReturnsEntry
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.GetProjectAsync_WithModifiedProject_InvalidatesCache
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.GetProjectsAsync_WithMultipleProjects_ReturnsValidEntries
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.InvalidateProjectAsync_RemovesProjectEntries
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.GetStatisticsAsync_ReturnsAccurateStatistics
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.ClearAsync_RemovesAllEntries
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.PerformMaintenanceAsync_ExecutesWithoutError
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.CreateProjectEntryAsync_WithProjectReferences_DiscoversReferences
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.StoreProjectAsync_WithNullEntry_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.StoreProjectAsync_WithEmptyProjectPath_ThrowsArgumentException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.CreateProjectEntryAsync_WithNonExistentProject_ThrowsArgumentException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.CompressionEffectiveness_AchievesGoodCompression
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.ConcurrentAccess_HandlesMultipleOperations
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SolutionCacheManagerTests.InitializeAsync_WithNoSnapshot_CreatesNewSnapshot
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SolutionCacheManagerTests.GetOrSetAsync_WithNewKey_CallsFactoryAndCachesResult
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SolutionCacheManagerTests.GetOrSetAsync_WithExistingKey_ReturnsFromCache
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SolutionCacheManagerTests.RegisterFileDependenciesAsync_TracksFileDependencies
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SolutionCacheManagerTests.DetectChangesAsync_WithModifiedFile_DetectsChanges
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SolutionCacheManagerTests.SaveAndLoadSnapshot_PreservesFileState
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SolutionCacheManagerTests.ClearAllAsync_RemovesAllCacheData
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SolutionCacheManagerTests.LargeSolutionSimulation_HandlesManyCacheEntries
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SolutionCacheManagerTests.ConcurrentAccess_HandlesMultipleThreadsSafely
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoaderFactoryTests.CreateDefault_ShouldReturnCrossFrameworkAssemblyLoader
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoaderFactoryTests.CreateWithConsoleLogging_ShouldReturnCrossFrameworkAssemblyLoaderWithConsoleLogger
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoaderFactoryTests.CreateWithLogger_ShouldReturnCrossFrameworkAssemblyLoaderWithCustomLogger
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoaderFactoryTests.CreateSilent_ShouldReturnCrossFrameworkAssemblyLoaderWithNullLogger
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoaderFactoryTests.CreateFrameworkLoader_WithSupportedFramework_ShouldReturnCorrectLoader
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoaderFactoryTests.CreateFrameworkLoader_WithUnsupportedFramework_ShouldThrowNotSupportedException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoaderFactoryTests.TryCreateFrameworkLoader_WithSupportedFramework_ShouldReturnTrueAndLoader
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoaderFactoryTests.TryCreateFrameworkLoader_WithUnsupportedFramework_ShouldReturnFalseAndNullLoader
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoadExceptionTests.DefaultConstructor_ShouldInitializeWithEmptyProperties
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoadExceptionTests.Constructor_WithMessage_ShouldSetMessage
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoadExceptionTests.Constructor_WithMessageAndInnerException_ShouldSetBoth
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoadExceptionTests.Constructor_WithAssemblyPathAndErrors_ShouldSetProperties
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoadExceptionTests.Constructor_WithAssemblyPathAndEmptyErrors_ShouldUseEmptyErrors
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoadExceptionTests.Constructor_WithAssemblyPathErrorsAndInnerException_ShouldSetAllProperties
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoadExceptionTests.CreateMessage_WithAssemblyPathAndErrors_ShouldFormatCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoadExceptionTests.CreateMessage_WithEmptyErrors_ShouldNotIncludeErrorsSection
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.Loader_WithMultipleConcurrentCalls_HandlesThreadSafety
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.CanLoad_WithInvalidAssemblyName_HandlesGracefully
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.CanLoad_WithMalformedPath_ReturnssFalseGracefully
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.LoadAssembly_WithInvalidPath_ThrowsAppropriateException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.LoadAssembly_WithNullPath_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.CanLoad_WithValidPathAndSupportedFramework_IntegratesCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.CanLoad_WithInvalidPath_ReturnsFalse
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.CanLoad_WithNonExistentFile_ReturnsFalse
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.LoadAssembly_WithValidPath_CreatesTestAssemblyWrapper
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.Dispose_CanBeCalledMultipleTimes
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.ThrowIfDisposed_AfterDisposal_ThrowsObjectDisposedException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.LoadAssembly_AfterDisposal_ThrowsObjectDisposedException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConsoleAssemblyLoadLoggerTests.LogInformation_ShouldWriteToConsole
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConsoleAssemblyLoadLoggerTests.LogInformation_WithArguments_ShouldFormatMessage
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConsoleAssemblyLoadLoggerTests.LogWarning_ShouldWriteToConsole
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConsoleAssemblyLoadLoggerTests.LogError_ShouldWriteToConsole
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConsoleAssemblyLoadLoggerTests.LogError_WithException_ShouldWriteErrorAndException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConsoleAssemblyLoadLoggerTests.WriteLog_ShouldIncludeTimestamp
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NullAssemblyLoadLoggerTests.Instance_ShouldReturnSameSingletonInstance
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NullAssemblyLoadLoggerTests.LogInformation_ShouldNotThrow
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NullAssemblyLoadLoggerTests.LogInformation_WithArguments_ShouldNotThrow
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NullAssemblyLoadLoggerTests.LogWarning_ShouldNotThrow
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NullAssemblyLoadLoggerTests.LogError_ShouldNotThrow
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NullAssemblyLoadLoggerTests.LogError_WithException_ShouldNotThrow
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NullAssemblyLoadLoggerTests.LogDebug_ShouldNotThrow
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.Constructor_WithLogger_ShouldInitializeCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.Constructor_WithNullLogger_ShouldUseNullLogger
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.SupportedFrameworks_ShouldContainExpectedFrameworks
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.DetectFrameworkVersion_WithNullPath_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.DetectFrameworkVersion_WithEmptyPath_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.DetectFrameworkVersion_WithWhitespacePath_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.DetectFrameworkVersion_WithNonExistentFile_ShouldThrowFileNotFoundException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.DetectFrameworkVersion_WithValidFile_ShouldCallFrameworkDetector
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssembly_WithNullPath_ShouldReturnFailureResult
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssembly_WithEmptyPath_ShouldReturnFailureResult
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssembly_WithNonExistentFile_ShouldReturnFailureResult
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssembly_WithFrameworkDetectionFailure_ShouldReturnFailureResult
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssembly_SamePath_ShouldReturnCachedResult
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssemblyAsync_WithValidPath_ShouldCallLoadAssembly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssemblyAsync_WithCancellation_ShouldRespectCancellation
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssembliesAsync_WithNullPaths_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssembliesAsync_WithEmptyList_ShouldReturnEmptyDictionary
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssembliesAsync_WithMultiplePaths_ShouldProcessAll
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssembliesAsync_WithCancellation_ShouldRespectCancellation
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.GetLoadedAssemblies_InitialState_ShouldReturnEmptyList
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.TryUnloadAssembly_WithNullAssembly_ShouldReturnFalse
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.TryUnloadAssembly_WithUnknownAssembly_ShouldReturnFalse
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.UnloadAllAssemblies_WithNoLoadedAssemblies_ShouldNotThrow
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.Dispose_ShouldUnloadAllAssemblies
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.Dispose_CalledMultipleTimes_ShouldNotThrow
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssembly_CurrentBehavior_BlocksOnAsyncCall
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssembly_CurrentBehaviorWithMultipleThreads_HandlesBlocking
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssembly_WithCorruptedFrameworkDetection_ShouldHandleGracefully
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoadedEventArgsTests.Constructor_ShouldInitializeAllProperties
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoadFailedEventArgsTests.Constructor_ShouldInitializeAllProperties
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoadFailedEventArgsTests.Constructor_WithoutDetectedFramework_ShouldAcceptNull
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithNullPath_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithEmptyPath_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithWhitespacePath_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithNonExistentFile_ShouldThrowFileNotFoundException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithPathContainingFrameworkInfo_ShouldDetectFromPath
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithGenericPath_ShouldFallbackGracefully
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithCurrentTestAssembly_ShouldDetectFramework
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithSystemAssembly_ShouldDetectFramework
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithCorruptedFile_ShouldFallbackGracefully
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithEmptyFile_ShouldFallbackGracefully
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithBinaryGibberish_ShouldFallbackGracefully
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_ParseTargetFramework_ShouldHandleVariousFormats
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithVeryLongPath_ShouldHandleGracefully
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithSpecialCharactersInPath_ShouldHandleGracefully
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithUnicodeCharactersInPath_ShouldHandleGracefully
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_ShouldTryMultipleStrategies
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithMixedContent_ShouldPrioritizeMetadata
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.Constructor_WithValidParameters_ShouldInitializeProperties
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.Constructor_WithNullAssembly_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.Constructor_WithNullAssemblyPath_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.GetTypes_ShouldReturnAllTypes
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.GetTypes_WithPredicate_ShouldReturnFilteredTypes
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.GetTypes_WithNullPredicate_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.GetTestClasses_ShouldReturnTestClasses
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.GetTestMethods_WithValidTestClass_ShouldReturnTestMethods
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.GetTestMethods_WithNullTestClass_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.GetAllTestMethods_ShouldReturnAllTestMethods
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.GetCustomAttributes_ShouldReturnAttributes
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.HasTestFrameworkReference_WithExistingFramework_ShouldReturnTrue
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.HasTestFrameworkReference_WithNonExistingFramework_ShouldReturnFalse
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.HasTestFrameworkReference_WithNullOrWhitespaceFrameworkName_ShouldReturnFalse
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.GetReferencedAssemblies_ShouldReturnReferencedAssemblies
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.TargetFramework_ShouldReturnTargetFrameworkString
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.Dispose_ShouldMarkAsDisposed
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.Dispose_CalledMultipleTimes_ShouldNotThrow
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.AfterDispose_AllMethodsShouldThrowObjectDisposedException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.Properties_AfterDispose_ShouldStillBeAccessible
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.Constructor_WithoutLogger_UsesNullLogger
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.Constructor_WithLogger_UsesProvidedLogger
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.FindDataConflictsAsync_WithNullTestAssembly_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.FindDataConflictsAsync_WithValidAssembly_ReturnsReport
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.FindDataConflictsAsync_WithCancellationToken_RespectsToken
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.CanRunInParallelAsync_WithNullTestA_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.CanRunInParallelAsync_WithNullTestB_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.CanRunInParallelAsync_WithValidTestMethods_ReturnsBoolean
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.CanRunInParallelAsync_WithTestsWithoutConflicts_ReturnsTrue
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.GetParallelExecutionRecommendationsAsync_WithNullTestMethods_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.GetParallelExecutionRecommendationsAsync_WithValidTestMethods_ReturnsRecommendations
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.GetParallelExecutionRecommendationsAsync_WithEmptyTestMethods_ReturnsEmptyRecommendations
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.GetParallelExecutionRecommendationsAsync_WithSingleTestMethod_ReturnsEmptyRecommendations
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.GetParallelExecutionRecommendationsAsync_WithCancellationToken_RespectsToken
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.ParallelExecutionRecommendations_Constructor_WithNullCanRunInParallel_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.ParallelExecutionRecommendations_Constructor_WithNullMustRunSequentially_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.ParallelExecutionRecommendations_Properties_SetCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.ParallelExecutionRecommendations_ParallelExecutionRatio_CalculatesCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.ParallelExecutionRecommendations_WithZeroTotalPairs_ReturnsZeroRatio
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.FindDataConflictsAsync_LogsInformation
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.CanRunInParallelAsync_WithException_ReturnsFalse
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.Constructor_WithValidParameters_SetsPropertiesCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.Constructor_WithNullAssemblyPath_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.Constructor_WithNullConflicts_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.Constructor_WithNullDependencies_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.HighSeverityConflictCount_ReturnsCorrectCount
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.ParallelBlockingConflictCount_ReturnsCorrectCount
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.GetConflictsBySeverity_ReturnsCorrectConflicts
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.GetTestMethodsWithDependencies_ReturnsUniqueTestMethods
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.GetTestMethodsWithDependencies_WithNoDependencies_ReturnsEmptyCollection
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.ToString_ReturnsExpectedFormat
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.Properties_AreImmutable
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.Collections_AreReadOnly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.GeneratedAt_IsSetToCurrentTime
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.Constructor_WithEmptyCollections_AllowsEmptyCollections
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.GetConflictsBySeverity_WithNoMatchingConflicts_ReturnsEmptyCollection
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictTests.Constructor_WithValidParameters_SetsPropertiesCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictTests.Constructor_WithNullTestMethodA_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictTests.Constructor_WithNullConflictReason_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictTests.Constructor_WithNullConflictingDependencies_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictTests.Severity_Property_ReturnsCorrectSeverityForConflictType
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictTests.PreventsParallelExecution_Property_ReturnsCorrectValueForConflictType
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictTests.ToString_ReturnsExpectedFormat
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictTests.Properties_AreImmutable
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictTests.ConflictingDependencies_PropertyIsReadOnly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictTests.DetectedAt_IsSetToCurrentTime
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataDependencyTests.Constructor_WithValidParameters_SetsPropertiesCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataDependencyTests.Constructor_WithNullTestMethodId_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataDependencyTests.Constructor_WithNullResourceIdentifier_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataDependencyTests.Constructor_WithNullEntityTypes_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataDependencyTests.DependencyType_Property_AcceptsAllValidValues
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataDependencyTests.AccessType_Property_AcceptsAllValidValues
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataDependencyTests.ToString_ReturnsExpectedFormat
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataDependencyTests.EntityTypes_PropertyIsReadOnly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataDependencyTests.DetectedAt_IsSetToCurrentTime
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataDependencyTests.Constructor_WithEmptyEntityTypes_AllowsEmptyList
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataDependencyTests.Properties_AreImmutable
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ EF6PatternDetectorTests.SupportedFrameworks_ContainsEntityFramework6
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ EF6PatternDetectorTests.DetectDataSeedingAsync_WithNullMethod_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ EF6PatternDetectorTests.DetectDataSeedingAsync_WithValidMethod_ReturnsResult
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ EFCorePatternDetectorTests.SupportedFrameworks_ContainsEntityFrameworkCore
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ EFCorePatternDetectorTests.DetermineAccessType_BasedOnMethodName_ReturnsCorrectAccessType
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ EFCorePatternDetectorTests.EFCorePatternDetector_StressTest_CurrentPerformance
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ HelperClassTests.EF6ContextUsage_Constructor_WithValidParameters_SetsProperties
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ HelperClassTests.EF6ContextUsage_Constructor_WithNullContextType_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ HelperClassTests.EF6ContextUsage_Constructor_WithNullEntitySets_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ HelperClassTests.EFCoreContextUsage_Constructor_WithValidParameters_SetsProperties
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ HelperClassTests.EFCoreContextUsage_Constructor_WithNullContextType_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ HelperClassTests.EFCoreContextUsage_Constructor_WithNullEntitySets_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ HelperClassTests.DataSeedingOperation_Constructor_WithValidParameters_SetsProperties
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ HelperClassTests.DataSeedingOperation_Constructor_WithNullEntityType_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ HelperClassTests.DataSeedingOperation_Constructor_WithNullOperationType_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ HelperClassTests.DataSeedingOperation_Constructor_WithZeroRecordCount_AllowsZero
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ HelperClassTests.DataSeedingOperation_Constructor_WithNegativeRecordCount_AllowsNegative
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageAnalyzerTests.AnalyzeCoverageAsync_WithValidDiff_ReturnsCorrectCoverageResult
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageAnalyzerTests.AnalyzeCoverageFromFileAsync_WithValidFile_ReturnsCorrectResult
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageAnalyzerTests.AnalyzeCoverageFromGitCommandAsync_WithValidCommand_ReturnsCorrectResult
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageAnalyzerTests.AnalyzeCoverageAsync_WithCompleteTestCoverage_Returns100PercentCoverage
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageAnalyzerTests.AnalyzeCoverageAsync_WithPartialTestCoverage_ReturnsCorrectPercentage
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageAnalyzerTests.AnalyzeCoverageAsync_WithInvalidDiffContent_ThrowsArgumentException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageAnalyzerTests.AnalyzeCoverageAsync_WithNullDiffContent_ThrowsArgumentException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageAnalyzerTests.AnalyzeCoverageFromFileAsync_WithInvalidFilePath_ThrowsArgumentException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageAnalyzerTests.AnalyzeCoverageFromFileAsync_WithNullFilePath_ThrowsArgumentException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageAnalyzerTests.AnalyzeSingleTestCoverageAsync_WithValidInputs_ReturnsCorrectResult
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ StreamingTestCoverageAnalyzerTests.FindTestsExercisingMethodStreamAsync_WithValidMethod_ShouldStreamResults
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ StreamingTestCoverageAnalyzerTests.FindTestsExercisingMethodStreamAsync_WithNullMethodId_ShouldThrowArgumentException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ StreamingTestCoverageAnalyzerTests.FindTestsExercisingMethodStreamAsync_WithNullSolutionPath_ShouldThrowArgumentException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ StreamingTestCoverageAnalyzerTests.FindTestsExercisingMethodStreamAsync_WithCancellationToken_ShouldRespectCancellation
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ StreamingTestCoverageAnalyzerTests.FindTestsExercisingMethodsStreamAsync_WithMultipleMethods_ShouldStreamAllResults
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ StreamingTestCoverageAnalyzerTests.FindTestsExercisingMethodStreamAsync_WithNoTestMethods_ShouldReturnEmpty
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ StreamingTestCoverageAnalyzerTests.FindTestsExercisingMethodStreamAsync_WithTestMethodErrors_ShouldContinueProcessing
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageAnalyzerTests.FindTestsExercisingMethodAsync_WithValidMethodId_ReturnsTestCoverageInfo
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageAnalyzerTests.FindTestsExercisingMethodAsync_WithNullMethodId_ThrowsArgumentException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageAnalyzerTests.FindTestsExercisingMethodAsync_WithEmptyMethodId_ThrowsArgumentException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageAnalyzerTests.FindTestsExercisingMethodAsync_WithNullSolutionPath_ThrowsArgumentException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageAnalyzerTests.FindTestsExercisingMethodsAsync_WithMultipleMethodIds_ReturnsCorrectMapping
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageAnalyzerTests.FindTestsExercisingMethodsAsync_WithEmptyMethodIds_ReturnsEmptyDictionary
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageAnalyzerTests.GetCoverageStatisticsAsync_WithValidSolution_ReturnsStatistics
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageAnalyzerTests.Constructor_WithNullRoslynAnalyzer_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageAnalyzerTests.Constructor_WithNullLogger_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.Constructor_WithNullRoslynAnalyzer_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.Constructor_WithNullLogger_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.TraceTestExecutionAsync_WithNullTestMethodId_ThrowsArgumentException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.TraceTestExecutionAsync_WithEmptyTestMethodId_ThrowsArgumentException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.TraceTestExecutionAsync_WithNullSolutionPath_ThrowsArgumentException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.TraceTestExecutionAsync_WithEmptySolutionPath_ThrowsArgumentException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.TraceTestExecutionAsync_WithNonExistentMethod_ThrowsArgumentException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.TraceTestExecutionAsync_WithNonTestMethod_ThrowsArgumentException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.TraceTestExecutionAsync_WithValidTestMethod_ReturnsExecutionTrace
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.TraceTestExecutionAsync_WithTestMethodCallingTestUtility_FiltersOutTestMethods
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.TraceTestExecutionAsync_WithFrameworkMethods_CategorizesProperly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.TraceMultipleTestsAsync_WithNullTestMethodIds_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.TraceMultipleTestsAsync_WithEmptyList_ReturnsEmptyList
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.TraceMultipleTestsAsync_WithValidTestMethods_ReturnsAllTraces
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.GenerateCoverageReportAsync_WithValidSolution_ReturnsComprehensiveReport
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.TraceTestExecutionAsync_CategorizesMethodsCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerBenchmarks.BenchmarkCompilationCaching_SmallCodebase
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerBenchmarks.BenchmarkCompilationCaching_MediumCodebase
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerBenchmarks.BenchmarkCompilationCaching_LargeCodebase
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerBenchmarks.BenchmarkConcurrentAccess
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerBenchmarks.BenchmarkMemoryUsage
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodClassifierTests.IsTestMethod_WithTestMethodNames_ReturnsTrue
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodClassifierTests.IsTestMethod_WithProductionMethodNames_InProductionCode_ReturnsFalse
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodClassifierTests.IsTestMethod_WithTestMethodNamesInTestPaths_ReturnsTrue
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodClassifierTests.ClassifyTestType_WithSpecificTestPaths_ReturnsCorrectType
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodClassifierTests.ClassifyTestType_WithSpecificMethodNames_ReturnsCorrectType
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodClassifierTests.ClassifyTestType_WithRegularTestMethod_ReturnsUnit
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodClassifierTests.CalculateTestConfidence_WithTestNameInTestPath_ReturnsHighConfidence
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodClassifierTests.CalculateTestConfidence_WithNonTestMethod_ReturnsLowConfidence
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodClassifierTests.GetTestMethods_WithMixedMethods_ReturnsOnlyTestMethods
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodClassifierTests.GroupTestMethodsByType_WithVariousTestTypes_GroupsCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodClassifierTests.IsTestMethod_WithNullMethodInfo_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodClassifierTests.ClassifyTestType_WithNullMethodInfo_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodClassifierTests.CalculateTestConfidence_WithNullMethodInfo_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.GetCallGraphAsync_WithNoCachedEntry_ReturnsNull
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.StoreCallGraphAsync_WithValidData_StoresSuccessfully
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.GetCallGraphAsync_WithValidCachedEntry_ReturnsEntry
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.GetCallGraphAsync_WithChangedAssemblies_InvalidatesCache
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.GetCallGraphAsync_WithModifiedProject_InvalidatesCache
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.GetStatisticsAsync_ReturnsAccurateStatistics
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.ClearAsync_RemovesAllEntries
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.PerformMaintenanceAsync_ExecutesWithoutError
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.InvalidateProjectAsync_InvalidatesSpecificProject
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.CompressionEffectiveness_AchievesGoodCompression
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.CacheEntryValidation_DetectsIntegrityIssues
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.CacheEntryStatistics_ReturnsAccurateMetrics
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.GenerateCacheKey_WithSameInputs_GeneratesSameKey
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.GenerateCacheKey_WithDifferentInputs_GeneratesDifferentKeys
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.ConcurrentAccess_HandlesMultipleOperations
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.Constructor_WithNullLogger_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.Constructor_WithValidLogger_ShouldCreateInstance
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.GetOrParse_WithSimpleCode_ShouldReturnSyntaxTree
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.GetOrParse_WithSameContent_ShouldReturnCachedTree
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.GetOrParse_WithDifferentContent_ShouldCreateNewTree
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.Return_WithValidSyntaxTree_ShouldReturnToPool
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.Return_WithNullSyntaxTree_ShouldNotThrow
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.GetOrParse_WithPooledTree_ShouldReuseFromPool
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.GetStatistics_WithMultipleOperations_ShouldTrackCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.Clear_ShouldResetAllStatistics
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.Pool_WithCustomOptions_ShouldRespectLimits
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.Pool_WithManyDifferentFiles_ShouldRespectCacheLimit
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.GetOrParse_WithInvalidOrEmptyCode_ShouldStillReturnTree
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.GetOrParse_WithLargeFile_ShouldHandleGracefully
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.GetStatistics_InitialState_ShouldReturnZeros
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.Dispose_ShouldCleanupResources
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.Pool_UnderHighConcurrency_ShouldRemainThreadSafe
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolOptionsTests.DefaultOptions_ShouldHaveReasonableDefaults
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolStatisticsTests.CacheHitRatio_WithZeroRequests_ShouldReturnZero
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolStatisticsTests.CacheHitRatio_WithRequests_ShouldCalculateCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolStatisticsTests.PoolHitRatio_WithRequests_ShouldCalculateCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolStatisticsTests.ReuseRatio_WithRequests_ShouldCalculateCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BasicRoslynTests.RoslynAnalyzer_CanBeCreated
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BasicRoslynTests.RoslynAnalyzer_Constructor_WithNullLogger_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BasicRoslynTests.RoslynAnalyzer_Constructor_WithNullLoggerFactory_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BasicRoslynTests.RoslynAnalyzer_Dispose_DoesNotThrow
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BasicRoslynTests.RoslynAnalyzer_DoubleDispose_DoesNotThrow
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BasicRoslynTests.ExtractMethodsFromFileAsync_WithEmptyFile_ReturnsEmpty
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BasicRoslynTests.ExtractMethodsFromFileAsync_WithValidClass_ExtractsMethods
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BasicRoslynTests.GetSemanticModelAsync_WithValidFile_ReturnsSemanticModel
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CancellationHandlingTests.GetAffectedMethodsAsync_WithCancelledToken_ShouldThrowOperationCanceledException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CancellationHandlingTests.GetSemanticModelAsync_WithCancelledToken_ShouldThrowOperationCanceledException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CancellationHandlingTests.AnalyzeTypeUsageAsync_WithCancelledToken_ShouldThrowOperationCanceledException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CancellationHandlingTests.ExtractMethodsFromFileAsync_WithCancelledToken_ShouldThrowOperationCanceledException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CancellationHandlingTests.FindTestsExercisingMethodAsync_WithCancelledToken_ShouldThrowOperationCanceledException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CancellationHandlingTests.CancellationToken_ShouldPropagateToNestedOperations
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CancellationHandlingTests.MultipleOperations_WithSharedCancellationToken_ShouldAllCancel
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CancellationHandlingTests.CancellationToken_WithGracefulFallback_ShouldHandleCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageResultTests.Constructor_WithValidInputs_CalculatesStatisticsCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageResultTests.Constructor_WithFullCoverage_Returns100Percent
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageResultTests.Constructor_WithNoCoverage_ReturnsZeroPercent
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageResultTests.Constructor_WithNoChanges_Returns100Percent
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageResultTests.ConfidenceBreakdown_CalculatesCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageResultTests.CoverageByTestType_CalculatesCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageResultTests.Recommendations_GeneratesCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageResultTests.Constructor_WithNullCodeChanges_ThrowsArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageResultTests.ToString_ReturnsFormattedString
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CoverageByConfidenceTests.Constructor_WithEmptyScores_InitializesCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CoverageByConfidenceTests.Constructor_WithMixedConfidenceScores_CalculatesCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CoverageByConfidenceTests.Constructor_WithBoundaryValues_CalculatesCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompilationManagerTests.Constructor_WithNullLogger_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompilationManagerTests.Constructor_WithNullWorkspace_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompilationManagerTests.Constructor_WithValidParameters_ShouldCreateInstance
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompilationManagerTests.GetSemanticModel_WithMockedWorkspace_ShouldHandleNullGracefully
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompilationManagerTests.GetSemanticModel_WithNullOrEmptyPath_ShouldReturnNull
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompilationManagerTests.ResolveSymbolInfo_WithInvalidFile_ShouldReturnNull
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompilationManagerTests.ResolveTypeInfo_WithInvalidFile_ShouldReturnNull
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompilationManagerTests.ClearSemanticModelCache_ShouldClearCache
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ EnhancedRoslynAnalyzerTests.FindTestsExercisingMethod_ShouldDetectMoreCoverage_ThanLegacyAnalyzer
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ EnhancedRoslynAnalyzerTests.RoslynAnalyzerFactory_ShouldCreateRoslynAnalyzer
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.Constructor_WithNullLogger_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.Constructor_WithNullRoslynAnalyzer_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.Constructor_WithValidParameters_ShouldInitializeSuccessfully
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithNullContent_ShouldReturnEmptyChangeSet
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithEmptyContent_ShouldReturnEmptyChangeSet
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithWhitespaceContent_ShouldReturnEmptyChangeSet
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithSimpleModification_ShouldParseCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithNewFile_ShouldDetectAddedFile
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithDeletedFile_ShouldDetectDeletedFile
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithMultipleFiles_ShouldParseAllFiles
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithNonCSharpFile_ShouldIgnoreFile
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithComplexMethodSignatures_ShouldDetectMethods
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithNoMethodOrTypeChanges_ShouldReturnEmptyChangeSet
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffFileAsync_WithNonExistentFile_ShouldThrowFileNotFoundException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffFileAsync_WithValidFile_ShouldParseContent
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffFileAsync_WithEmptyFile_ShouldReturnEmptyChangeSet
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffFromCommandAsync_WithNullCommand_ShouldHandleGracefully
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffFromCommandAsync_WithInvalidGitCommand_ShouldThrowInvalidOperationException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffFromCommandAsync_WithValidCommand_ShouldExecuteAndParse
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffFromCommandAsync_WithGitPrefix_ShouldRemovePrefix
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithVariousMethodSignatures_ShouldExtractMethodNames
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithVariousTypeDeclarations_ShouldExtractTypeNames
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithInvalidMethodNames_ShouldFilterOutKeywords
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithBinaryFile_ShouldIgnoreBinaryChanges
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithMalformedDiff_ShouldHandleGracefully
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithVeryLargeDiff_ShouldHandleEfficiently
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_ShouldLogAppropriateMessages
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithEmptyContent_ShouldLogWarning
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerEdgeCaseTests.ExtractMethodsFromFileAsync_WithComplexSyntax_ShouldHandleCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerEdgeCaseTests.FindTestsExercisingMethodAsync_WithComplexTestScenarios_ShouldDetectCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerEdgeCaseTests.AnalyzeTypeUsageAsync_WithNestedGenerics_ShouldHandleCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerTests.GetAffectedMethodsAsync_WithMethodChanges_ShouldReturnTransitiveDependents
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerTests.GetSemanticModelAsync_WithValidFile_ShouldReturnSemanticModel
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerTests.GetSemanticModelAsync_WithNonExistentFile_ShouldThrowFileNotFoundException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerTests.AnalyzeTypeUsageAsync_WithMultipleTypes_ShouldReturnAllUsages
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerTests.ExtractMethodsFromFileAsync_WithMultipleMethods_ShouldReturnAllMethods
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerTests.ExtractMethodsFromFileAsync_WithNonExistentFile_ShouldThrowFileNotFoundException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerTests.AnalyzeTypeUsageAsync_WithEmptyFileArray_ShouldReturnEmptyList
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerTests.AnalyzeTypeUsageAsync_WithDifferentTypeDeclarations_ShouldDetectAll
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerTests.FindTestsExercisingMethodAsync_WithDirectTestCall_ShouldReturnTest
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerTests.FindTestsExercisingMethodAsync_WithIndirectTestCall_ShouldReturnTest
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerTests.FindTestsExercisingMethodAsync_WithNoTestCoverage_ShouldReturnEmpty
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerTests.FindTestsExercisingMethodAsync_WithMultipleTests_ShouldReturnAll
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MethodCallGraphTests.Constructor_WithNullCallGraph_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MethodCallGraphTests.Constructor_WithNullMethodDefinitions_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MethodCallGraphTests.GetMethodCalls_WithExistingMethod_ShouldReturnCalls
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MethodCallGraphTests.GetMethodCalls_WithNonExistentMethod_ShouldReturnEmptySet
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MethodCallGraphTests.GetMethodDependents_WithMethodThatIsCalled_ShouldReturnCallers
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MethodCallGraphTests.GetTransitiveDependents_WithDeepCallChain_ShouldReturnAllTransitiveCallers
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MethodCallGraphTests.GetMethodInfo_WithExistingMethod_ShouldReturnMethodInfo
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MethodCallGraphTests.GetMethodInfo_WithNonExistentMethod_ShouldReturnNull
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MethodCallGraphTests.GetTestMethodsExercisingMethod_WithDirectTestCall_ShouldReturnTestMethod
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MethodCallGraphTests.GetTestCoverageForMethod_WithDirectTestCall_ShouldReturnCoverageResult
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MethodInfoTests.Constructor_WithValidParameters_ShouldCreateInstance
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MethodInfoTests.Constructor_WithNullParameter_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MethodInfoTests.ToString_ShouldReturnFormattedString
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TypeUsageInfoTests.Constructor_WithValidParameters_ShouldCreateInstance
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TypeUsageInfoTests.Constructor_WithNullParameter_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TypeUsageInfoTests.Constructor_WithNullNamespace_ShouldAllowNullAndConvertToEmpty
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TypeUsageInfoTests.FullTypeName_WithNamespace_ShouldReturnQualifiedName
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TypeUsageInfoTests.FullTypeName_WithEmptyNamespace_ShouldReturnTypeName
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TypeUsageInfoTests.ToString_ShouldReturnFormattedString
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageResultTests.Constructor_WithValidParameters_ShouldCreateInstance
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageResultTests.CallDepth_WithTwoElementPath_ShouldReturnOne
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageResultTests.CallDepth_WithThreeElementPath_ShouldReturnTwo
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageResultTests.CallDepth_ShouldReturnCorrectCount
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageResultTests.ToString_ShouldReturnFormattedString
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageResultTests.Constructor_WithNullParameter_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageResultTests.Constructor_WithNullCallPath_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.GetAffectedMethodsAsync_WithEmptyChanges_ShouldReturnEmptyList
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.GetAffectedMethodsAsync_WithCancellation_ShouldThrowOperationCanceledException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.GetSemanticModelAsync_WithNonExistentFile_ShouldThrowFileNotFoundException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.GetSemanticModelAsync_WithMalformedSourceCode_ShouldHandleGracefully
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.AnalyzeTypeUsageAsync_WithNonExistentFiles_ShouldSkipGracefully
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.AnalyzeTypeUsageAsync_WithMixOfValidAndInvalidFiles_ShouldProcessValidOnes
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.AnalyzeTypeUsageAsync_WithCancellation_ShouldThrowOperationCanceledException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.ExtractMethodsFromFileAsync_WithNonExistentFile_ShouldThrowFileNotFoundException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.ExtractMethodsFromFileAsync_WithEmptyFile_ShouldReturnEmptyList
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.ExtractMethodsFromFileAsync_WithCompilationErrors_ShouldHandleGracefully
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.ExtractMethodsFromFileAsync_WithCancellation_ShouldThrowOperationCanceledException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.FindTestsExercisingMethodAsync_WithNonExistentMethod_ShouldReturnEmpty
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.FindTestsExercisingMethodAsync_WithEmptySolutionFiles_ShouldFallbackGracefully
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.FindTestsExercisingMethodAsync_WithCancellation_ShouldThrowOperationCanceledException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.WorkspaceInitialization_WithCorruptedProjectFile_ShouldFallbackGracefully
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.Dispose_ShouldCleanupResources
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.Dispose_CalledMultipleTimes_ShouldNotThrow
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynCoreComponentTests.RoslynAnalyzer_Constructor_WithValidParameters_ShouldCreateInstance
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynCoreComponentTests.RoslynAnalyzer_Constructor_WithNullLogger_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynCoreComponentTests.RoslynAnalyzer_Constructor_WithNullLoggerFactory_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynCoreComponentTests.RoslynAnalyzer_Dispose_ShouldNotThrow
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynCoreComponentTests.RoslynAnalyzer_DoubleDispose_ShouldNotThrow
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynCoreComponentTests.GetAffectedMethodsAsync_WithEmptyInputs_ShouldReturnEmpty
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynCoreComponentTests.FindTestsExercisingMethodAsync_WithEmptyInputs_ShouldReturnEmpty
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynCoreComponentTests.AnalyzeTypeUsageAsync_WithEmptyFiles_ShouldReturnEmpty
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynCoreComponentTests.ExtractMethodsFromFileAsync_WithNonExistentFile_ShouldThrowFileNotFoundException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynCoreComponentTests.ExtractMethodsFromFileAsync_WithEmptyFile_ShouldReturnEmpty
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynCoreComponentTests.ExtractMethodsFromFileAsync_WithValidCSharpFile_ShouldExtractMethods
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynCoreComponentTests.GetSemanticModelAsync_WithNonExistentFile_ShouldThrowFileNotFoundException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynCoreComponentTests.GetSemanticModelAsync_WithValidFile_ShouldReturnSemanticModel
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolIndexTests.FindFilesContainingMethodAsync_WithoutIndex_ShouldReturnEmpty
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolIndexTests.FindFilesContainingMethodAsync_WithNonexistentMethod_ShouldReturnEmpty
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolIndexTests.FindFilesContainingTypeAsync_ShouldFindTypes
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolIndexTests.GetFilesInNamespaceAsync_ShouldFindNamespaces
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolIndexTests.FindProjectsContainingMethodAsync_ShouldReturnProjectInfo
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolIndexTests.GetProjectForFile_WithValidFile_ShouldReturnProjectInfo
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolIndexTests.GetProjectForFile_WithNonexistentFile_ShouldReturnNull
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolIndexTests.RefreshFilesAsync_ShouldUpdateIndex
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolIndexTests.Clear_ShouldResetIndex
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolIndexTests.FindFilesContainingMethodAsync_WithFuzzyMatching_ShouldWork
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolIndexTests.ProjectInfo_Equality_ShouldWorkCorrectly
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolResolutionEngineTests.Constructor_WithNullCompilationManager_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolResolutionEngineTests.Constructor_WithNullLogger_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolResolutionEngineTests.ResolveMethodSymbol_WithNoSemanticModel_ShouldReturnNull
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolResolutionEngineTests.GetFullyQualifiedMethodName_WithNullMethodSymbol_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolResolutionEngineTests.GetFullyQualifiedMethodName_WithStandaloneMethodSymbol_ShouldReturnFullName
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolResolutionEngineTests.ResolveMemberAccess_WithNoSemanticModel_ShouldReturnNull
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolResolutionEngineTests.HandleGenericMethods_WithNonGenericMethod_ShouldReturnSameMethod
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolResolutionEngineTests.HandleGenericMethods_WithNullMethod_ShouldReturnNull
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolResolutionEngineTests.ResolveInterfaceImplementations_WithMockedManager_ShouldReturnEmpty
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolResolutionEngineTests.ResolveInterfaceImplementations_WithNonInterfaceMethod_ShouldReturnEmpty
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolResolutionEngineTests.ResolveVirtualOverrides_WithMockedManager_ShouldReturnEmpty
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolResolutionEngineTests.ResolveVirtualOverrides_WithNonVirtualMethod_ShouldReturnEmpty
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ExecutionTraceControllerTests.TraceTestExecution_WithValidRequest_ReturnsOk
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ExecutionTraceControllerTests.TraceTestExecution_WithEmptyTestMethodId_ReturnsBadRequest
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ExecutionTraceControllerTests.TraceTestExecution_WithMissingSolutionPath_ReturnsBadRequest
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ExecutionTraceControllerTests.TraceMultipleTestsExecution_WithValidRequest_ReturnsOk
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ExecutionTraceControllerTests.GenerateCoverageReport_WithValidRequest_ReturnsOk
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ExecutionTraceControllerTests.GetTestExecutionStatistics_WithValidRequest_ReturnsOk
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ExecutionTraceControllerTests.TraceMultipleTestsExecution_WithInvalidTestMethodIds_ReturnsBadRequest
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryControllerTests.DiscoverTests_WithValidPath_ReturnsTestResults
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryControllerTests.DiscoverTests_WithInvalidPath_ReturnsBadRequest
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryControllerTests.DiscoverTests_WithCategoryFilter_FiltersResults
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryControllerTests.GetTestCategories_ReturnsAllCategories
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryControllerTests.HealthCheck_ReturnsHealthyStatus
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryControllerTests.DiscoverTests_CreatesValidSummary
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryControllerTests.DiscoverTests_PopulatesCategoryBreakdown
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionControllerTests.GetTestPlan_WithValidRequest_ReturnsOkResult
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionControllerTests.GetTestPlan_WithCodeChanges_CallsOptimalTestPlanAsync
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionControllerTests.AnalyzeDiff_WithValidRequest_ReturnsAnalysisResult
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionControllerTests.UpdateExecutionHistory_WithValidResults_ReturnsOk
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionControllerTests.GetTestHistory_WithFilter_ReturnsFilteredResults
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionControllerTests.GetTestPlan_WithException_ReturnsBadRequest
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfidenceLevelTests.GetConfidenceScore_ShouldReturnCorrectScore
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfidenceLevelTests.GetEstimatedDuration_ShouldReturnCorrectTimeSpan
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfidenceLevelTests.GetMaxTestCount_ShouldReturnCorrectLimit
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfidenceLevelTests.GetConfidenceScore_WithInvalidLevel_ShouldThrowArgumentOutOfRangeException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfidenceLevelTests.GetEstimatedDuration_WithInvalidLevel_ShouldThrowArgumentOutOfRangeException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfidenceLevelTests.GetMaxTestCount_WithInvalidLevel_ShouldThrowArgumentOutOfRangeException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionPlanTests.Constructor_WithValidParameters_ShouldCreatePlan
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionPlanTests.Constructor_WithNullTests_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionPlanTests.Constructor_WithEmptyTests_ShouldCreateEmptyPlan
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionPlanTests.TestCategoryBreakdown_ShouldCountTestsByCategory
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionPlanTests.GetTestsByCategory_ShouldReturnFilteredTests
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionPlanTests.CreateExecutionBatches_WithCompatibleTests_ShouldCreateOptimalBatches
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionPlanTests.CreateExecutionBatches_WithIncompatibleTests_ShouldSeparateThem
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionPlanTests.GetOptimizedExecutionTime_WithBatches_ShouldReturnBatchBasedDuration
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionPlanTests.GetOptimizedExecutionTime_WithoutBatches_ShouldReturnEstimatedDuration
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionPlanTests.ToString_ShouldIncludeKeyMetrics
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionBatchTests.Constructor_WithValidParameters_ShouldCreateBatch
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionBatchTests.Constructor_WithNullTests_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionBatchTests.CanExecuteInParallel_WithSingleTest_ShouldReturnFalse
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionBatchTests.CanExecuteInParallel_WithMultipleTests_ShouldReturnTrue
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionBatchTests.ToString_ShouldIncludeBatchInfo
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestInfoTests.Constructor_WithValidParameters_ShouldCreateInstance
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestInfoTests.Constructor_WithNullTestMethod_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestInfoTests.GetUniqueId_ShouldReturnTestMethodUniqueId
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestInfoTests.GetDisplayName_ShouldReturnTestMethodDisplayName
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestInfoTests.CalculateFailureRate_WithNoHistory_ShouldReturnZero
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestInfoTests.CalculateFailureRate_WithMixedResults_ShouldReturnCorrectRate
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestInfoTests.IsFlaky_WithInsufficientHistory_ShouldReturnFalse
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestInfoTests.IsFlaky_WithVariousFailureRates_ShouldDetectFlakyTests
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestInfoTests.GetLastExecutionResult_WithNoHistory_ShouldReturnNull
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestInfoTests.GetLastExecutionResult_WithHistory_ShouldReturnMostRecentResult
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestInfoTests.ToString_ShouldIncludeDisplayNameScoreAndCategory
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionEngineTests.Constructor_WithValidParameters_ShouldCreateInstance
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionEngineTests.Constructor_WithNullLogger_ShouldThrowArgumentNullException
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionEngineTests.GetTestPlanAsync_WithFastConfidence_ShouldCreatePlan
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionEngineTests.GetOptimalTestPlanAsync_WithCodeChanges_ShouldCreatePlan
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionEngineTests.ScoreTestsAsync_WithCandidateTests_ShouldReturnScoredTests
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionEngineTests.UpdateTestExecutionHistoryAsync_WithResults_ShouldUpdateHistory
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionEngineTests.GetTestHistoryAsync_WithoutFilter_ShouldReturnAllTests
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionEngineTests.GetTestHistoryAsync_WithFilter_ShouldReturnFilteredTests
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionEngineTests.GetTestPlanAsync_WithDifferentConfidenceLevels_ShouldRespectLimits
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionEngineTests.GetTestPlanAsync_WithSelectionOptions_ShouldApplyConstraints
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionEngineTests.ScoreTestsAsync_WithMixedTestTypes_ShouldPrioritizeBasedOnCategory
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionEngineTests.ScoreTestsAsync_WithExecutionHistoryContext_ShouldConsiderReliability
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionEngineTests.ScoreTestsAsync_WithDifferentConfidenceLevels_ShouldAdjustScoring
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FullWorkflowE2ETests.FullWorkflow_AnalyzeThenFindTests_WorksEndToEnd
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FullWorkflowE2ETests.FullWorkflow_CallGraphThenFindTests_ShowsConsistentResults
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FullWorkflowE2ETests.FullWorkflow_ErrorHandling_FailsGracefullyWithInvalidInputs
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FullWorkflowE2ETests.FullWorkflow_OutputConsistency_JsonAndTextOutputsAreConsistent
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FullWorkflowE2ETests.FullWorkflow_PerformanceBaseline_CompletesWithinReasonableTime
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AnalyzeCommandE2ETests.Analyze_WithValidSolution_ReturnsAnalysisResults
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AnalyzeCommandE2ETests.Analyze_WithJsonOutput_ReturnsValidJson
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AnalyzeCommandE2ETests.Analyze_WithVerboseOutput_IncludesDetailedInformation
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AnalyzeCommandE2ETests.Analyze_WithOutputFile_WritesToFile
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AnalyzeCommandE2ETests.Analyze_WithJsonOutputFile_WritesValidJsonToFile
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AnalyzeCommandE2ETests.Analyze_WithNonExistentPath_FailsGracefully
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AnalyzeCommandE2ETests.Analyze_CommandExists_InHelpOutput
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCommandE2ETests.CallGraph_WithValidSolution_ReturnsCallGraphResults
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCommandE2ETests.CallGraph_WithJsonOutput_ReturnsValidJson
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCommandE2ETests.CallGraph_WithVerboseOutput_IncludesMethodDetails
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCommandE2ETests.CallGraph_WithMaxMethodsLimit_RespectsLimit
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCommandE2ETests.CallGraph_WithOutputFile_WritesToFile
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCommandE2ETests.CallGraph_WithJsonOutputFile_WritesValidJsonToFile
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCommandE2ETests.CallGraph_WithNonExistentPath_FailsGracefully
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCommandE2ETests.CallGraph_CommandExists_InHelpOutput
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DiffCommandE2ETests.Diff_WithDiffContent_ReturnsImpactAnalysis
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DiffCommandE2ETests.Diff_WithDiffFile_ReadsFileAndAnalyzes
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DiffCommandE2ETests.Diff_WithGitCommand_ExecutesGitAndAnalyzes
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DiffCommandE2ETests.Diff_WithJsonOutput_ReturnsValidJson
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DiffCommandE2ETests.Diff_WithOutputFile_WritesToFile
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DiffCommandE2ETests.Diff_WithMultipleDiffSources_FailsValidation
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DiffCommandE2ETests.Diff_WithNoDiffSource_FailsValidation
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DiffCommandE2ETests.Diff_CommandExists_InHelpOutput
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FindTestsCommandE2ETests.FindTests_WithValidMethod_ReturnsExpectedResults
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FindTestsCommandE2ETests.FindTests_WithJsonOutput_ReturnsValidJson
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FindTestsCommandE2ETests.FindTests_WithVerboseOutput_IncludesCallPaths
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FindTestsCommandE2ETests.FindTests_WithOutputFile_WritesToFile
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FindTestsCommandE2ETests.FindTests_WithNonExistentMethod_ReturnsNoResults
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FindTestsCommandE2ETests.FindTests_WithInvalidSolution_FailsGracefully
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ VersionCommandE2ETests.Version_Command_ReturnsVersionInformation
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ VersionCommandE2ETests.Version_CommandExists_InHelpOutput
++  Score: 0.433 | Category: Unit | Duration: 0s
++  Tags: Unit
++
+diff --git a/select-high.json b/select-high.json
+new file mode 100644
+index 0000000..b253ea3
+--- /dev/null
++++ b/select-high.json
+@@ -0,0 +1,3483 @@
++=== Test Selection Report ===
++Path: TestIntelligence.sln
++Timestamp: 2025-09-04 00:46:16
++Confidence Level: High
++Changed Files: NUnitTestDiscovery.cs
++
++=== Selection Summary ===
++Selected Tests: 866
++Estimated Duration: 1.4m
++Average Score: 0.473
++Optimal Parallelism: 4
++
++=== Category Breakdown ===
++  Unit: 719 tests
++  UI: 75 tests
++  Database: 54 tests
++  Integration: 18 tests
++
++=== Selected Tests ===
++‚Ä¢ CacheInvalidationIntegrationTests.SolutionCacheManager_InvalidatesOnFileChange
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CacheInvalidationIntegrationTests.ProjectCacheManager_InvalidatesOnContentChange
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CacheInvalidationIntegrationTests.CallGraphCache_InvalidatesOnProjectFileChange
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CacheInvalidationIntegrationTests.EndToEndCacheInvalidation_WorksAcrossAllLayers
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CacheInvalidationIntegrationTests.CacheInvalidation_PerformanceTest
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.Resolver_WithCircularDependency_CanBeTestedThroughIntegration
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.TryUnloadAssembly_Integration_ReturnsExpectedValue
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceTestExecutionAsync_WithDeepCallChain_HandlesMaxDepthCorrectly
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceTestExecutionAsync_WithCircularReferences_PreventsInfiniteLoop
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceTestExecutionAsync_WithLargeBreadth_LimitsBreadthCorrectly
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceTestExecutionAsync_WithCachingEnabled_UsesCachedResults
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceMultipleTestsAsync_WithLargeTestSuite_UsesParallelProcessing
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceTestExecutionAsync_WithAsyncMethods_TracesCorrectly
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.GenerateCoverageReportAsync_WithMixedCodebase_GeneratesAccurateReport
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceTestExecutionAsync_WithGenericMethods_HandlesCorrectly
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CompilationCacheIntegrationTests.OptimizedAnalyzer_ShowsPerformanceImprovement
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CompilationCacheIntegrationTests.EnhancedCache_MultiLevelCaching_WorksCorrectly
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CompilationCacheIntegrationTests.SyntaxTreePool_ShowsMemoryOptimization
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.AssemblyLoaded_EventHandlers_ShouldBeInvokable
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.AssemblyLoadFailed_EventHandlers_ShouldBeInvokable
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssembly_ConcurrentCalls_ShouldBeThreadSafe
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_ShouldBeCaseInsensitive
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_ConcurrentCalls_ShouldBeThreadSafe
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ DataConflictTests.Constructor_WithNullTestMethodB_ThrowsArgumentNullException
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ DatabaseFrameworkTests.DatabaseFramework_EnumValues_AreCorrect
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ DatabaseFrameworkTests.DatabaseFramework_ToString_ReturnsCorrectName
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ DatabaseFrameworkTests.DatabaseFramework_AllValuesAreDefined
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.DetectDatabaseOperationsAsync_WithNullTestMethod_ThrowsArgumentNullException
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.DetectDatabaseOperationsAsync_WithValidTestMethod_ReturnsEmptyList
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.DetectDatabaseOperationsAsync_WithCancellationToken_RespectsToken
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.DetectDatabaseOperationsAsync_WithSetupMethods_HandlesNullEnumerable
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.DetectDatabaseOperationsAsync_WithSetupMethods_ReturnsEmptyListForEmptyEnumerable
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.DetectDatabaseOperationsAsync_WithSetupMethods_ProcessesMultipleMethods
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.RequiresExclusiveDbAccess_WithMethodNameIndicatingExclusiveAccess_ReturnsTrue
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.RequiresExclusiveDbAccess_WithNormalTestMethod_ReturnsFalse
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.RequiresExclusiveDbAccess_WithNullTestMethod_ThrowsArgumentNullException
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.SharesDatabaseDependency_WithNullParameters_ThrowsArgumentNullException
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.SharesDatabaseDependency_WithNoDatabaseDependencies_ReturnsFalse
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.SharesDatabaseDependency_WithSameResourceIdentifier_ReturnsTrue
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.SharesDatabaseDependency_WithSharedEntityTypes_ReturnsTrue
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.SharesDatabaseDependency_WithNoSharedDependencies_ReturnsFalse
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.DetectDbContextUsageAsync_WithNullMethod_ThrowsArgumentNullException
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.DetectDbContextUsageAsync_WithValidMethod_ReturnsResult
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.RequiresExclusiveDbAccess_WithExceptionThrown_ReturnsTrue
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectDatabaseOperationsAsync_WithNullTestMethod_ThrowsArgumentNullException
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectDatabaseOperationsAsync_WithValidTestMethod_ReturnsEmptyList
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectDatabaseOperationsAsync_WithCancellationToken_RespectsToken
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectDatabaseOperationsAsync_WithSetupMethods_HandlesNullEnumerable
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectDatabaseOperationsAsync_WithSetupMethods_ReturnsEmptyListForEmptyEnumerable
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectDatabaseOperationsAsync_WithSetupMethods_ProcessesMultipleMethods
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.RequiresExclusiveDbAccess_WithInMemoryDatabase_ReturnsFalse
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.RequiresExclusiveDbAccess_WithNullTestMethod_ThrowsArgumentNullException
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.SharesDatabaseDependency_WithNullParameters_ThrowsArgumentNullException
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.SharesDatabaseDependency_WithNoDatabaseDependencies_ReturnsFalse
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.SharesDatabaseDependency_WithSameInMemoryDatabase_ReturnsTrue
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.SharesDatabaseDependency_WithDifferentInMemoryDatabases_ReturnsFalse
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.SharesDatabaseDependency_WithSameResourceIdentifier_ReturnsTrue
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.SharesDatabaseDependency_WithSharedEntityTypes_ReturnsTrue
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.SharesDatabaseDependency_WithNoSharedDependencies_ReturnsFalse
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectDbContextUsageAsync_WithNullMethod_ThrowsArgumentNullException
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectDbContextUsageAsync_WithValidMethod_ReturnsResult
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectInMemoryDatabaseUsageAsync_WithNullMethod_ThrowsArgumentNullException
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectInMemoryDatabaseUsageAsync_WithValidMethod_ReturnsResult
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.RequiresExclusiveDbAccess_WithExceptionThrown_ReturnsFalse
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.RequiresExclusiveDbAccess_CurrentBehavior_BlocksOnAsyncCall
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.RequiresExclusiveDbAccess_CurrentBehaviorWithException_HandlesGracefully
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ HelperClassTests.InMemoryDatabaseUsage_Constructor_WithValidParameters_SetsProperties
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ HelperClassTests.InMemoryDatabaseUsage_Constructor_WithNullDatabaseName_ThrowsArgumentNullException
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ HelperClassTests.InMemoryDatabaseUsage_Constructor_WithNullContextType_ThrowsArgumentNullException
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ SyntaxTreePoolOptionsTests.Options_ShouldBeConfigurable
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ CancellationHandlingTests.CancellationDuringWorkspaceInitialization_ShouldBeHandledGracefully
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ TestSelectionEngineTests.ScoreTestsAsync_WithCodeChanges_ShouldBoostRelatedTests
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ ConsoleAssemblyLoadLoggerTests.LogDebug_InDebugBuild_ShouldWriteToConsole
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ StreamingTestCoverageAnalyzerTests.FindTestsExercisingMethodStreamAsync_WithCallGraphBuildFailure_ShouldUseFallback
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ TestCoverageAnalyzerTests.BuildTestCoverageMapAsync_WithValidSolution_ReturnsTestCoverageMap
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ BasicRoslynTests.BuildCallGraphAsync_WithEmptyFiles_ReturnsEmptyGraph
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ CancellationHandlingTests.BuildCallGraphAsync_WithPreCancelledToken_ShouldThrowOperationCanceledException
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ CancellationHandlingTests.BuildCallGraphAsync_WithTokenCancelledDuringExecution_ShouldThrowOperationCanceledException
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ CancellationHandlingTests.BuildCallGraphAsync_WithTimeoutToken_ShouldRespectTimeout
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ CancellationHandlingTests.BuildCallGraphAsync_WithVariousTimeouts_ShouldHandleCorrectly
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ EnhancedRoslynAnalyzerTests.BuildCallGraph_WithCrossProjectCalls_ShouldCaptureAllReferences
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.BuildCallGraphForMethodAsync_WithValidMethod_ShouldReturnCallGraph
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.BuildCallGraphForMethodAsync_WithNonexistentMethod_ShouldReturnEmptyGraph
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.BuildCallGraphForMethodAsync_WithMaxDepthLimit_ShouldRespectDepth
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.BuildCallGraphForMethodsAsync_WithMultipleMethods_ShouldCombineResults
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.BuildCallGraphForMethodAsync_WithCachedResult_ShouldUseCacheOnSecondCall
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.BuildCallGraphForMethodAsync_WithCompilationError_ShouldHandleGracefully
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.ClearCaches_ShouldResetInternalCaches
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.BuildCallGraphForMethodAsync_WithCancellation_ShouldRespectCancellationToken
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.BuildCallGraphForMethodsAsync_WithEmptyMethodList_ShouldReturnEmptyResult
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.BuildCallGraphForMethodAsync_WithInvalidMaxDepth_ShouldHandleGracefully
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.InitializeAsync_WithValidSolution_ShouldSucceed
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.InitializeAsync_WithSingleProject_ShouldSucceed
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetOrLoadProjectAsync_WithValidProject_ShouldLoadProject
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetOrLoadProjectAsync_WithSameProjectTwice_ShouldUseCache
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetOrLoadProjectAsync_WithNonexistentProject_ShouldReturnNull
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetCompilationAsync_WithValidProject_ShouldReturnCompilation
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetCompilationAsync_WithSameProjectTwice_ShouldUseCache
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetProjectContainingFileAsync_WithValidFile_ShouldReturnProject
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetProjectContainingFileAsync_WithNonexistentFile_ShouldReturnNull
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetProjectsContainingMethodAsync_WithValidMethod_ShouldReturnProjects
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetAllProjectPathsAsync_ShouldReturnAllProjects
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.PreloadProjectsAsync_ShouldLoadProjectsInBackground
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetStats_ShouldReturnAccurateStatistics
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.ClearCaches_ShouldResetCachedData
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.InitializeAsync_WithInvalidPath_ShouldHandleGracefully
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.WorkspaceStats_LoadedProjectsPercentage_ShouldCalculateCorrectly
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.WorkspaceStats_LoadedProjectsPercentage_WithZeroTotal_ShouldReturnZero
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerCallGraphTests.BuildCallGraphAsync_CapturesConstructorCalls
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerCallGraphTests.BuildCallGraphAsync_CapturesPropertyAccess
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerCallGraphTests.BuildCallGraphAsync_CapturesMethodInvocations
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerCallGraphTests.BuildCallGraphAsync_IdentifiesTestMethods
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerCallGraphTests.BuildCallGraphAsync_HandlesComplexCallChains
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerEdgeCaseTests.BuildCallGraphAsync_WithGenericMethods_ShouldHandleCorrectly
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerEdgeCaseTests.BuildCallGraphAsync_WithInterfaceImplementations_ShouldDetectPolymorphism
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerEdgeCaseTests.BuildCallGraphAsync_WithLambdaExpressions_ShouldHandleCorrectly
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerEdgeCaseTests.BuildCallGraphAsync_WithAsyncAwaitPattern_ShouldHandleCorrectly
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerEdgeCaseTests.BuildCallGraphAsync_WithReflectionCalls_ShouldHandleGracefully
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerEdgeCaseTests.BuildCallGraphAsync_WithCircularReferences_ShouldHandleWithoutInfiniteLoop
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerEdgeCaseTests.BuildCallGraphAsync_WithLargeCodebase_ShouldPerformReasonably
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithLazyWorkspace_ShouldInitializeLazilyOnFirstCall
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithLazyWorkspace_ShouldFallbackToLegacyOnFailure
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithValidSolution_ShouldPreferIncrementalAnalysis
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithMultipleCalls_ShouldReuseInfrastructure
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithCancellation_ShouldHandleGracefully
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithEmptyFileList_ShouldReturnEmptyGraph
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithInvalidSolutionPath_ShouldFallbackGracefully
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithMixedFileTypes_ShouldHandleAppropriately
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithRepeatedCalls_ShouldMaintainPerformance
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithLargeTimeout_ShouldCompleteWithinReasonableTime
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerTests.BuildCallGraphAsync_WithSimpleClass_ShouldReturnCallGraph
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerTests.BuildCallGraphAsync_WithCancellationToken_ShouldRespectCancellation
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.BuildCallGraphAsync_WithNonExistentFiles_ShouldFallbackToFileAnalysis
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.BuildCallGraphAsync_WithMalformedSolutionFile_ShouldFallbackGracefully
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.BuildCallGraphAsync_WithCancellationDuringInitialization_ShouldThrowOperationCanceledException
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.BuildCallGraphAsync_WithMemoryPressure_ShouldHandleGracefully
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynCoreComponentTests.BuildCallGraphAsync_WithEmptyFiles_ShouldReturnEmptyCallGraph
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ SymbolIndexTests.BuildIndexAsync_WithValidSolution_ShouldIndexAllMethods
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ SymbolIndexTests.BuildIndexAsync_WithProjectFile_ShouldWork
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ TestSelectionEngineTests.ScoreTestsAsync_WithLargeTestSuite_ShouldHandlePerformantly
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ AnalyzeCommandE2ETests.Analyze_WithMissingRequiredArguments_ShowsHelp
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ CallGraphCommandE2ETests.CallGraph_WithMissingRequiredArguments_ShowsHelp
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ DiffCommandE2ETests.Diff_WithMissingRequiredArguments_ShowsHelp
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ FindTestsCommandE2ETests.FindTests_WithMissingRequiredArguments_ShowsHelp
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ QuickValidationE2ETests.CLI_Version_Command_Works
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ QuickValidationE2ETests.CLI_Help_Command_Works
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ QuickValidationE2ETests.CLI_InvalidCommand_ShowsError
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ TestCoverageInfoTests.Constructor_WithValidParameters_CreatesInstance
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.Constructor_WithInvalidConfidence_ClampsToValidRange
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.Constructor_WithNullTestMethodId_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.Constructor_WithNullCallPath_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.CallDepth_WithVariousCallPaths_ReturnsCorrectDepth
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.IsDirectCoverage_WithVariousCallPaths_ReturnsCorrectValue
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.GetCallPathDisplay_WithMultipleSteps_ReturnsFormattedPath
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.ToString_ReturnsExpectedFormat
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.Equals_WithSameMethodIdAndCallPath_ReturnsTrue
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.Equals_WithDifferentMethodId_ReturnsFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.GetHashCode_WithSameMethodIdAndCallPath_ReturnsSameValue
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageMapTests.Constructor_WithValidParameters_CreatesInstance
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageMapTests.Constructor_WithNullMethodToTests_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageMapTests.Constructor_WithNullSolutionPath_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageMapTests.GetTestsForMethod_WithExistingMethod_ReturnsTests
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageMapTests.GetTestsForMethod_WithNonExistentMethod_ReturnsEmptyList
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageMapTests.GetCoveredMethods_WithMultipleMethods_ReturnsAllMethodIds
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageMapTests.CoveredMethodCount_ReturnsCorrectCount
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageMapTests.TotalCoverageRelationships_ReturnsCorrectCount
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageStatisticsTests.Constructor_WithValidParameters_CreatesInstance
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageStatisticsTests.CoveragePercentage_WithVariousValues_ReturnsCorrectPercentage
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageStatisticsTests.UncoveredMethods_WithVariousValues_ReturnsCorrectCount
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageStatisticsTests.Constructor_WithNullCoverageByTestType_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.Constructor_WithValidParameters_SetsProperties
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.Constructor_WithNullType_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.Constructor_WithNullAssemblyPath_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.GetUniqueId_ReturnsFullClassName
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.TestMethods_IsInitialized
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.FixtureAttributes_IsInitialized
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.HasSetUpMethods_WithNoSetupMethods_ReturnsFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.HasTearDownMethods_WithNoTearDownMethods_ReturnsFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.HasTests_WithNoTestMethods_ReturnsFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.GetExecutableTests_ReturnsExpectedCollection
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.GetSetUpMethods_ReturnsExpectedCollection
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.GetTearDownMethods_ReturnsExpectedCollection
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.GetCategories_ReturnsExpectedCollection
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.ToString_ReturnsExpectedFormat
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.Constructor_WithValidParameters_SetsProperties
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.Constructor_WithNullMethodInfo_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.Constructor_WithNullDeclaringType_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.Constructor_WithNullAssemblyPath_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.GetUniqueId_ReturnsExpectedFormat
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.GetDisplayName_ReturnsExpectedFormat
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.IsExecutableTest_WithRegularMethod_ReturnsFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.TestAttributes_IsInitialized
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.ToString_ReturnsDisplayName
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.GetTestCaseParameters_WithRegularMethod_ReturnsEmpty
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NUnitTestDiscoveryTests.IsTestFixture_WithNullType_ReturnsFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NUnitTestDiscoveryTests.IsTestFixture_WithNonTestClass_ReturnsFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NUnitTestDiscoveryTests.IsTestMethod_WithNullMethod_ReturnsFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NUnitTestDiscoveryTests.IsTestMethod_WithRegularMethod_ReturnsFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NUnitTestDiscoveryTests.DiscoverTestsAsync_WithNullAssembly_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NUnitTestDiscoveryTests.DiscoverTestsAsync_WithValidAssembly_ReturnsResult
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NUnitTestDiscoveryTests.DiscoverTestsAsync_MultipleAssemblies_WithNullInput_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NUnitTestDiscoveryTests.DiscoverTestsAsync_MultipleAssemblies_ReturnsResults
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryStartedEventArgsTests.Constructor_ShouldSetPropertiesCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryStartedEventArgsTests.Constructor_WithNullAssemblyPath_ShouldSetNullAssemblyPath
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryStartedEventArgsTests.Constructor_WithEmptyAssemblyPath_ShouldSetEmptyAssemblyPath
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryCompletedEventArgsTests.Constructor_ShouldSetPropertiesCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryCompletedEventArgsTests.Constructor_WithNullAssemblyPath_ShouldSetNullAssemblyPath
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryCompletedEventArgsTests.Constructor_WithNullResult_ShouldSetNullResult
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryErrorEventArgsTests.Constructor_ShouldSetPropertiesCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryErrorEventArgsTests.Constructor_WithNullAssemblyPath_ShouldSetNullAssemblyPath
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryErrorEventArgsTests.Constructor_WithNullException_ShouldSetNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryFactoryTests.CreateNUnitTestDiscovery_ShouldReturnNUnitTestDiscoveryInstance
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfigurationServiceTests.LoadConfigurationAsync_WithNonExistentDirectory_ReturnsDefaultConfiguration
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfigurationServiceTests.LoadConfigurationAsync_WithSolutionFile_LoadsFromSolutionDirectory
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfigurationServiceTests.CreateDefaultConfigurationAsync_CreatesValidJsonFile
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfigurationServiceTests.LoadConfigurationFromFileAsync_WithValidJson_LoadsCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfigurationServiceTests.FilterProjects_WithEmptyList_ReturnsEmpty
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfigurationServiceTests.FilterProjects_WithExcludePatterns_FiltersCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfigurationServiceTests.FilterProjects_WithIncludePatterns_FiltersCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfigurationServiceTests.FilterProjects_WithExcludeTypes_FiltersCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfigurationServiceTests.FilterProjects_WithBothIncludeAndExclude_ExcludeTakesPrecedence
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfigurationServiceTests.AnalyzeProjectFilteringAsync_WithNonExistentSolution_ReturnsEmptyResult
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfigurationServiceTests.AnalyzeProjectFilteringAsync_WithMockSolution_AnalyzesCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.GetOrCacheTestDiscoveryAsync_WithNullAssemblyPath_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.GetOrCacheTestDiscoveryAsync_WithNullFactory_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.GetOrCacheTestDiscoveryAsync_WithValidInput_CallsFactory
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.GetOrCacheAssemblyLoadAsync_WithNullAssemblyPath_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.GetOrCacheAssemblyLoadAsync_WithNullFactory_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.GetOrCacheAssemblyLoadAsync_WithValidInput_CallsFactory
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.CacheFrameworkVersionAsync_WithNullAssemblyPath_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.CacheFrameworkVersionAsync_WithValidInput_DoesNotThrow
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.GetCachedFrameworkVersionAsync_WithNullAssemblyPath_ReturnsNull
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.GetCachedFrameworkVersionAsync_WithNonCachedAssembly_ReturnsNull
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.InvalidateAssemblyAsync_WithValidPath_DoesNotThrow
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.ClearAllAsync_DoesNotThrow
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.GetModifiedAssembliesAsync_WithNullInput_ReturnsEmptyList
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyMetadataCacheTests.Dispose_CanBeCalledMultipleTimes
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.CompressAsync_WithValidObject_ReturnsCompressedData
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.CompressAsync_WithNullObject_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.DecompressAsync_WithValidCompressedData_ReturnsOriginalObject
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.DecompressAsync_WithNullCompressedData_ReturnsNull
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.DecompressAsync_WithEmptyCompressedData_ReturnsNull
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.CompressToStreamAsync_WithValidObject_WritesToStream
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.CompressToStreamAsync_WithNullObject_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.CompressToStreamAsync_WithNullStream_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.DecompressFromStreamAsync_WithValidStream_ReturnsOriginalObject
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.DecompressFromStreamAsync_WithNullStream_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.EstimateCompressionRatio_WithValidObject_ReturnsReasonableEstimate
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.EstimateCompressionRatio_WithNullObject_ReturnsZero
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.EstimateCompressionRatio_WithSmallObject_ProcessesDirectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.CompressionRoundTrip_WithComplexObject_MaintainsDataIntegrity
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.CompressAsync_WithDifferentCompressionLevels_ProducesDifferentResults
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CacheCompressionUtilitiesTests.CompressDecompress_WithCancellation_RespectsCancellationToken
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.GetAsync_WithNonExistentKey_ReturnsNull
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.SetAsync_WithValidData_StoresCompressedData
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.SetAsync_WithNullKey_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.SetAsync_WithNullValue_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.GetAsync_WithExpiredEntry_ReturnsNull
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.RemoveAsync_WithExistingKey_RemovesEntry
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.RemoveAsync_WithNonExistentKey_ReturnsFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.GetCompressedSizeAsync_WithExistingEntry_ReturnsSize
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.GetCompressedSizeAsync_WithNonExistentKey_ReturnsNull
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.GetStatsAsync_WithMultipleEntries_ReturnsAccurateStats
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.GetOrSetAsync_WithExistingKey_ReturnsExistingValue
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.GetOrSetAsync_WithNewKey_CallsFactory
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.ClearAsync_RemovesAllEntries
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.PerformMaintenanceAsync_RemovesExpiredEntries
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.StorageLimitEnforcement_EvictsOldestEntries
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.CompressionEffectiveness_AchievesGoodRatio
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.ConcurrentAccess_HandlesMultipleOperations
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompressedCacheProviderTests.CacheResilience_HandlesCorruptedFiles
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.GetAsync_WithNonExistentKey_ReturnsNull
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.GetAsync_WithNullKey_ReturnsNull
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.SetAsync_WithValidKeyAndValue_StoresValue
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.SetAsync_WithNullKey_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.SetAsync_WithNullValue_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.RemoveAsync_WithExistingKey_RemovesValue_ReturnsTrue
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.RemoveAsync_WithNonExistentKey_ReturnsFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.ExistsAsync_WithExistingKey_ReturnsTrue
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.ExistsAsync_WithNonExistentKey_ReturnsFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.ClearAsync_RemovesAllEntries
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.GetOrSetAsync_WithNonExistentKey_CallsFactory
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.GetOrSetAsync_WithExistingKey_DoesNotCallFactory
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.GetOrSetAsync_WithNullKey_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.GetOrSetAsync_WithNullFactory_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.GetStatistics_ReturnsValidStatistics
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MemoryCacheProviderTests.Dispose_CanBeCalledMultipleTimes
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ PersistentCacheProviderTests.GetAsync_WhenKeyDoesNotExist_ReturnsNull
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ PersistentCacheProviderTests.SetAndGetAsync_WhenValueExists_ReturnsValue
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ PersistentCacheProviderTests.GetAsync_WhenEntryExpired_ReturnsNull
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ PersistentCacheProviderTests.ExistsAsync_WhenKeyExists_ReturnsTrue
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ PersistentCacheProviderTests.ExistsAsync_WhenKeyDoesNotExist_ReturnsFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ PersistentCacheProviderTests.RemoveAsync_WhenKeyExists_ReturnsTrue
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ PersistentCacheProviderTests.GetOrSetAsync_WhenKeyDoesNotExist_CreatesAndReturnsValue
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ PersistentCacheProviderTests.GetOrSetAsync_WhenKeyExists_ReturnsExistingValue
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ PersistentCacheProviderTests.ClearAsync_RemovesAllEntries
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ PersistentCacheProviderTests.GetStatisticsAsync_ReturnsAccurateStats
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ PersistentCacheProviderTests.CleanupExpiredAsync_RemovesOnlyExpiredEntries
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ PersistentCacheProviderTests.MultipleThreads_CanAccessCacheConcurrently
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ PersistentCacheProviderTests.Constructor_CreatesDirectoryIfNotExists
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.GetProjectAsync_WithNoCachedEntry_ReturnsNull
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.CreateProjectEntryAsync_WithValidProject_CreatesEntry
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.StoreProjectAsync_WithValidEntry_StoresSuccessfully
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.GetProjectAsync_WithValidCachedEntry_ReturnsEntry
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.GetProjectAsync_WithModifiedProject_InvalidatesCache
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.GetProjectsAsync_WithMultipleProjects_ReturnsValidEntries
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.InvalidateProjectAsync_RemovesProjectEntries
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.GetStatisticsAsync_ReturnsAccurateStatistics
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.ClearAsync_RemovesAllEntries
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.PerformMaintenanceAsync_ExecutesWithoutError
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.CreateProjectEntryAsync_WithProjectReferences_DiscoversReferences
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.StoreProjectAsync_WithNullEntry_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.StoreProjectAsync_WithEmptyProjectPath_ThrowsArgumentException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.CreateProjectEntryAsync_WithNonExistentProject_ThrowsArgumentException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.CompressionEffectiveness_AchievesGoodCompression
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ProjectCacheManagerTests.ConcurrentAccess_HandlesMultipleOperations
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SolutionCacheManagerTests.InitializeAsync_WithNoSnapshot_CreatesNewSnapshot
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SolutionCacheManagerTests.GetOrSetAsync_WithNewKey_CallsFactoryAndCachesResult
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SolutionCacheManagerTests.GetOrSetAsync_WithExistingKey_ReturnsFromCache
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SolutionCacheManagerTests.RegisterFileDependenciesAsync_TracksFileDependencies
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SolutionCacheManagerTests.DetectChangesAsync_WithModifiedFile_DetectsChanges
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SolutionCacheManagerTests.SaveAndLoadSnapshot_PreservesFileState
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SolutionCacheManagerTests.ClearAllAsync_RemovesAllCacheData
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SolutionCacheManagerTests.LargeSolutionSimulation_HandlesManyCacheEntries
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SolutionCacheManagerTests.ConcurrentAccess_HandlesMultipleThreadsSafely
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoaderFactoryTests.CreateDefault_ShouldReturnCrossFrameworkAssemblyLoader
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoaderFactoryTests.CreateWithConsoleLogging_ShouldReturnCrossFrameworkAssemblyLoaderWithConsoleLogger
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoaderFactoryTests.CreateWithLogger_ShouldReturnCrossFrameworkAssemblyLoaderWithCustomLogger
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoaderFactoryTests.CreateSilent_ShouldReturnCrossFrameworkAssemblyLoaderWithNullLogger
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoaderFactoryTests.CreateFrameworkLoader_WithSupportedFramework_ShouldReturnCorrectLoader
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoaderFactoryTests.CreateFrameworkLoader_WithUnsupportedFramework_ShouldThrowNotSupportedException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoaderFactoryTests.TryCreateFrameworkLoader_WithSupportedFramework_ShouldReturnTrueAndLoader
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoaderFactoryTests.TryCreateFrameworkLoader_WithUnsupportedFramework_ShouldReturnFalseAndNullLoader
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoadExceptionTests.DefaultConstructor_ShouldInitializeWithEmptyProperties
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoadExceptionTests.Constructor_WithMessage_ShouldSetMessage
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoadExceptionTests.Constructor_WithMessageAndInnerException_ShouldSetBoth
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoadExceptionTests.Constructor_WithAssemblyPathAndErrors_ShouldSetProperties
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoadExceptionTests.Constructor_WithAssemblyPathAndEmptyErrors_ShouldUseEmptyErrors
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoadExceptionTests.Constructor_WithAssemblyPathErrorsAndInnerException_ShouldSetAllProperties
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoadExceptionTests.CreateMessage_WithAssemblyPathAndErrors_ShouldFormatCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoadExceptionTests.CreateMessage_WithEmptyErrors_ShouldNotIncludeErrorsSection
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.Loader_WithMultipleConcurrentCalls_HandlesThreadSafety
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.CanLoad_WithInvalidAssemblyName_HandlesGracefully
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.CanLoad_WithMalformedPath_ReturnssFalseGracefully
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.LoadAssembly_WithInvalidPath_ThrowsAppropriateException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.LoadAssembly_WithNullPath_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.CanLoad_WithValidPathAndSupportedFramework_IntegratesCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.CanLoad_WithInvalidPath_ReturnsFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.CanLoad_WithNonExistentFile_ReturnsFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.LoadAssembly_WithValidPath_CreatesTestAssemblyWrapper
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.Dispose_CanBeCalledMultipleTimes
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.ThrowIfDisposed_AfterDisposal_ThrowsObjectDisposedException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.LoadAssembly_AfterDisposal_ThrowsObjectDisposedException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConsoleAssemblyLoadLoggerTests.LogInformation_ShouldWriteToConsole
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConsoleAssemblyLoadLoggerTests.LogInformation_WithArguments_ShouldFormatMessage
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConsoleAssemblyLoadLoggerTests.LogWarning_ShouldWriteToConsole
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConsoleAssemblyLoadLoggerTests.LogError_ShouldWriteToConsole
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConsoleAssemblyLoadLoggerTests.LogError_WithException_ShouldWriteErrorAndException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConsoleAssemblyLoadLoggerTests.WriteLog_ShouldIncludeTimestamp
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NullAssemblyLoadLoggerTests.Instance_ShouldReturnSameSingletonInstance
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NullAssemblyLoadLoggerTests.LogInformation_ShouldNotThrow
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NullAssemblyLoadLoggerTests.LogInformation_WithArguments_ShouldNotThrow
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NullAssemblyLoadLoggerTests.LogWarning_ShouldNotThrow
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NullAssemblyLoadLoggerTests.LogError_ShouldNotThrow
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NullAssemblyLoadLoggerTests.LogError_WithException_ShouldNotThrow
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NullAssemblyLoadLoggerTests.LogDebug_ShouldNotThrow
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.Constructor_WithLogger_ShouldInitializeCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.Constructor_WithNullLogger_ShouldUseNullLogger
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.SupportedFrameworks_ShouldContainExpectedFrameworks
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.DetectFrameworkVersion_WithNullPath_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.DetectFrameworkVersion_WithEmptyPath_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.DetectFrameworkVersion_WithWhitespacePath_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.DetectFrameworkVersion_WithNonExistentFile_ShouldThrowFileNotFoundException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.DetectFrameworkVersion_WithValidFile_ShouldCallFrameworkDetector
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssembly_WithNullPath_ShouldReturnFailureResult
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssembly_WithEmptyPath_ShouldReturnFailureResult
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssembly_WithNonExistentFile_ShouldReturnFailureResult
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssembly_WithFrameworkDetectionFailure_ShouldReturnFailureResult
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssembly_SamePath_ShouldReturnCachedResult
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssemblyAsync_WithValidPath_ShouldCallLoadAssembly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssemblyAsync_WithCancellation_ShouldRespectCancellation
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssembliesAsync_WithNullPaths_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssembliesAsync_WithEmptyList_ShouldReturnEmptyDictionary
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssembliesAsync_WithMultiplePaths_ShouldProcessAll
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssembliesAsync_WithCancellation_ShouldRespectCancellation
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.GetLoadedAssemblies_InitialState_ShouldReturnEmptyList
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.TryUnloadAssembly_WithNullAssembly_ShouldReturnFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.TryUnloadAssembly_WithUnknownAssembly_ShouldReturnFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.UnloadAllAssemblies_WithNoLoadedAssemblies_ShouldNotThrow
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.Dispose_ShouldUnloadAllAssemblies
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.Dispose_CalledMultipleTimes_ShouldNotThrow
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssembly_CurrentBehavior_BlocksOnAsyncCall
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssembly_CurrentBehaviorWithMultipleThreads_HandlesBlocking
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssembly_WithCorruptedFrameworkDetection_ShouldHandleGracefully
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoadedEventArgsTests.Constructor_ShouldInitializeAllProperties
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoadFailedEventArgsTests.Constructor_ShouldInitializeAllProperties
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AssemblyLoadFailedEventArgsTests.Constructor_WithoutDetectedFramework_ShouldAcceptNull
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithNullPath_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithEmptyPath_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithWhitespacePath_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithNonExistentFile_ShouldThrowFileNotFoundException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithPathContainingFrameworkInfo_ShouldDetectFromPath
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithGenericPath_ShouldFallbackGracefully
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithCurrentTestAssembly_ShouldDetectFramework
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithSystemAssembly_ShouldDetectFramework
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithCorruptedFile_ShouldFallbackGracefully
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithEmptyFile_ShouldFallbackGracefully
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithBinaryGibberish_ShouldFallbackGracefully
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_ParseTargetFramework_ShouldHandleVariousFormats
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithVeryLongPath_ShouldHandleGracefully
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithSpecialCharactersInPath_ShouldHandleGracefully
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithUnicodeCharactersInPath_ShouldHandleGracefully
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_ShouldTryMultipleStrategies
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_WithMixedContent_ShouldPrioritizeMetadata
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.Constructor_WithValidParameters_ShouldInitializeProperties
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.Constructor_WithNullAssembly_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.Constructor_WithNullAssemblyPath_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.GetTypes_ShouldReturnAllTypes
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.GetTypes_WithPredicate_ShouldReturnFilteredTypes
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.GetTypes_WithNullPredicate_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.GetTestClasses_ShouldReturnTestClasses
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.GetTestMethods_WithValidTestClass_ShouldReturnTestMethods
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.GetTestMethods_WithNullTestClass_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.GetAllTestMethods_ShouldReturnAllTestMethods
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.GetCustomAttributes_ShouldReturnAttributes
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.HasTestFrameworkReference_WithExistingFramework_ShouldReturnTrue
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.HasTestFrameworkReference_WithNonExistingFramework_ShouldReturnFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.HasTestFrameworkReference_WithNullOrWhitespaceFrameworkName_ShouldReturnFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.GetReferencedAssemblies_ShouldReturnReferencedAssemblies
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.TargetFramework_ShouldReturnTargetFrameworkString
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.Dispose_ShouldMarkAsDisposed
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.Dispose_CalledMultipleTimes_ShouldNotThrow
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.AfterDispose_AllMethodsShouldThrowObjectDisposedException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestAssemblyWrapperTests.Properties_AfterDispose_ShouldStillBeAccessible
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.Constructor_WithoutLogger_UsesNullLogger
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.Constructor_WithLogger_UsesProvidedLogger
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.FindDataConflictsAsync_WithNullTestAssembly_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.FindDataConflictsAsync_WithValidAssembly_ReturnsReport
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.FindDataConflictsAsync_WithCancellationToken_RespectsToken
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.CanRunInParallelAsync_WithNullTestA_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.CanRunInParallelAsync_WithNullTestB_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.CanRunInParallelAsync_WithValidTestMethods_ReturnsBoolean
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.CanRunInParallelAsync_WithTestsWithoutConflicts_ReturnsTrue
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.GetParallelExecutionRecommendationsAsync_WithNullTestMethods_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.GetParallelExecutionRecommendationsAsync_WithValidTestMethods_ReturnsRecommendations
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.GetParallelExecutionRecommendationsAsync_WithEmptyTestMethods_ReturnsEmptyRecommendations
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.GetParallelExecutionRecommendationsAsync_WithSingleTestMethod_ReturnsEmptyRecommendations
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.GetParallelExecutionRecommendationsAsync_WithCancellationToken_RespectsToken
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.ParallelExecutionRecommendations_Constructor_WithNullCanRunInParallel_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.ParallelExecutionRecommendations_Constructor_WithNullMustRunSequentially_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.ParallelExecutionRecommendations_Properties_SetCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.ParallelExecutionRecommendations_ParallelExecutionRatio_CalculatesCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.ParallelExecutionRecommendations_WithZeroTotalPairs_ReturnsZeroRatio
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.FindDataConflictsAsync_LogsInformation
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDataDependencyTrackerTests.CanRunInParallelAsync_WithException_ReturnsFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.Constructor_WithValidParameters_SetsPropertiesCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.Constructor_WithNullAssemblyPath_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.Constructor_WithNullConflicts_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.Constructor_WithNullDependencies_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.HighSeverityConflictCount_ReturnsCorrectCount
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.ParallelBlockingConflictCount_ReturnsCorrectCount
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.GetConflictsBySeverity_ReturnsCorrectConflicts
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.GetTestMethodsWithDependencies_ReturnsUniqueTestMethods
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.GetTestMethodsWithDependencies_WithNoDependencies_ReturnsEmptyCollection
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.ToString_ReturnsExpectedFormat
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.Properties_AreImmutable
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.Collections_AreReadOnly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.GeneratedAt_IsSetToCurrentTime
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.Constructor_WithEmptyCollections_AllowsEmptyCollections
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictReportTests.GetConflictsBySeverity_WithNoMatchingConflicts_ReturnsEmptyCollection
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictTests.Constructor_WithValidParameters_SetsPropertiesCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictTests.Constructor_WithNullTestMethodA_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictTests.Constructor_WithNullConflictReason_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictTests.Constructor_WithNullConflictingDependencies_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictTests.Severity_Property_ReturnsCorrectSeverityForConflictType
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictTests.PreventsParallelExecution_Property_ReturnsCorrectValueForConflictType
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictTests.ToString_ReturnsExpectedFormat
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictTests.Properties_AreImmutable
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictTests.ConflictingDependencies_PropertyIsReadOnly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataConflictTests.DetectedAt_IsSetToCurrentTime
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataDependencyTests.Constructor_WithValidParameters_SetsPropertiesCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataDependencyTests.Constructor_WithNullTestMethodId_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataDependencyTests.Constructor_WithNullResourceIdentifier_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataDependencyTests.Constructor_WithNullEntityTypes_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataDependencyTests.DependencyType_Property_AcceptsAllValidValues
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataDependencyTests.AccessType_Property_AcceptsAllValidValues
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataDependencyTests.ToString_ReturnsExpectedFormat
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataDependencyTests.EntityTypes_PropertyIsReadOnly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataDependencyTests.DetectedAt_IsSetToCurrentTime
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataDependencyTests.Constructor_WithEmptyEntityTypes_AllowsEmptyList
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DataDependencyTests.Properties_AreImmutable
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ EF6PatternDetectorTests.SupportedFrameworks_ContainsEntityFramework6
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ EF6PatternDetectorTests.DetectDataSeedingAsync_WithNullMethod_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ EF6PatternDetectorTests.DetectDataSeedingAsync_WithValidMethod_ReturnsResult
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ EFCorePatternDetectorTests.SupportedFrameworks_ContainsEntityFrameworkCore
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ EFCorePatternDetectorTests.DetermineAccessType_BasedOnMethodName_ReturnsCorrectAccessType
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ EFCorePatternDetectorTests.EFCorePatternDetector_StressTest_CurrentPerformance
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ HelperClassTests.EF6ContextUsage_Constructor_WithValidParameters_SetsProperties
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ HelperClassTests.EF6ContextUsage_Constructor_WithNullContextType_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ HelperClassTests.EF6ContextUsage_Constructor_WithNullEntitySets_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ HelperClassTests.EFCoreContextUsage_Constructor_WithValidParameters_SetsProperties
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ HelperClassTests.EFCoreContextUsage_Constructor_WithNullContextType_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ HelperClassTests.EFCoreContextUsage_Constructor_WithNullEntitySets_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ HelperClassTests.DataSeedingOperation_Constructor_WithValidParameters_SetsProperties
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ HelperClassTests.DataSeedingOperation_Constructor_WithNullEntityType_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ HelperClassTests.DataSeedingOperation_Constructor_WithNullOperationType_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ HelperClassTests.DataSeedingOperation_Constructor_WithZeroRecordCount_AllowsZero
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ HelperClassTests.DataSeedingOperation_Constructor_WithNegativeRecordCount_AllowsNegative
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageAnalyzerTests.AnalyzeCoverageAsync_WithValidDiff_ReturnsCorrectCoverageResult
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageAnalyzerTests.AnalyzeCoverageFromFileAsync_WithValidFile_ReturnsCorrectResult
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageAnalyzerTests.AnalyzeCoverageFromGitCommandAsync_WithValidCommand_ReturnsCorrectResult
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageAnalyzerTests.AnalyzeCoverageAsync_WithCompleteTestCoverage_Returns100PercentCoverage
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageAnalyzerTests.AnalyzeCoverageAsync_WithPartialTestCoverage_ReturnsCorrectPercentage
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageAnalyzerTests.AnalyzeCoverageAsync_WithInvalidDiffContent_ThrowsArgumentException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageAnalyzerTests.AnalyzeCoverageAsync_WithNullDiffContent_ThrowsArgumentException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageAnalyzerTests.AnalyzeCoverageFromFileAsync_WithInvalidFilePath_ThrowsArgumentException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageAnalyzerTests.AnalyzeCoverageFromFileAsync_WithNullFilePath_ThrowsArgumentException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageAnalyzerTests.AnalyzeSingleTestCoverageAsync_WithValidInputs_ReturnsCorrectResult
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ StreamingTestCoverageAnalyzerTests.FindTestsExercisingMethodStreamAsync_WithValidMethod_ShouldStreamResults
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ StreamingTestCoverageAnalyzerTests.FindTestsExercisingMethodStreamAsync_WithNullMethodId_ShouldThrowArgumentException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ StreamingTestCoverageAnalyzerTests.FindTestsExercisingMethodStreamAsync_WithNullSolutionPath_ShouldThrowArgumentException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ StreamingTestCoverageAnalyzerTests.FindTestsExercisingMethodStreamAsync_WithCancellationToken_ShouldRespectCancellation
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ StreamingTestCoverageAnalyzerTests.FindTestsExercisingMethodsStreamAsync_WithMultipleMethods_ShouldStreamAllResults
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ StreamingTestCoverageAnalyzerTests.FindTestsExercisingMethodStreamAsync_WithNoTestMethods_ShouldReturnEmpty
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ StreamingTestCoverageAnalyzerTests.FindTestsExercisingMethodStreamAsync_WithTestMethodErrors_ShouldContinueProcessing
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageAnalyzerTests.FindTestsExercisingMethodAsync_WithValidMethodId_ReturnsTestCoverageInfo
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageAnalyzerTests.FindTestsExercisingMethodAsync_WithNullMethodId_ThrowsArgumentException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageAnalyzerTests.FindTestsExercisingMethodAsync_WithEmptyMethodId_ThrowsArgumentException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageAnalyzerTests.FindTestsExercisingMethodAsync_WithNullSolutionPath_ThrowsArgumentException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageAnalyzerTests.FindTestsExercisingMethodsAsync_WithMultipleMethodIds_ReturnsCorrectMapping
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageAnalyzerTests.FindTestsExercisingMethodsAsync_WithEmptyMethodIds_ReturnsEmptyDictionary
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageAnalyzerTests.GetCoverageStatisticsAsync_WithValidSolution_ReturnsStatistics
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageAnalyzerTests.Constructor_WithNullRoslynAnalyzer_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageAnalyzerTests.Constructor_WithNullLogger_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.Constructor_WithNullRoslynAnalyzer_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.Constructor_WithNullLogger_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.TraceTestExecutionAsync_WithNullTestMethodId_ThrowsArgumentException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.TraceTestExecutionAsync_WithEmptyTestMethodId_ThrowsArgumentException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.TraceTestExecutionAsync_WithNullSolutionPath_ThrowsArgumentException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.TraceTestExecutionAsync_WithEmptySolutionPath_ThrowsArgumentException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.TraceTestExecutionAsync_WithNonExistentMethod_ThrowsArgumentException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.TraceTestExecutionAsync_WithNonTestMethod_ThrowsArgumentException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.TraceTestExecutionAsync_WithValidTestMethod_ReturnsExecutionTrace
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.TraceTestExecutionAsync_WithTestMethodCallingTestUtility_FiltersOutTestMethods
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.TraceTestExecutionAsync_WithFrameworkMethods_CategorizesProperly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.TraceMultipleTestsAsync_WithNullTestMethodIds_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.TraceMultipleTestsAsync_WithEmptyList_ReturnsEmptyList
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.TraceMultipleTestsAsync_WithValidTestMethods_ReturnsAllTraces
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.GenerateCoverageReportAsync_WithValidSolution_ReturnsComprehensiveReport
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionTracerTests.TraceTestExecutionAsync_CategorizesMethodsCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerBenchmarks.BenchmarkCompilationCaching_SmallCodebase
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerBenchmarks.BenchmarkCompilationCaching_MediumCodebase
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerBenchmarks.BenchmarkCompilationCaching_LargeCodebase
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerBenchmarks.BenchmarkConcurrentAccess
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerBenchmarks.BenchmarkMemoryUsage
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodClassifierTests.IsTestMethod_WithTestMethodNames_ReturnsTrue
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodClassifierTests.IsTestMethod_WithProductionMethodNames_InProductionCode_ReturnsFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodClassifierTests.IsTestMethod_WithTestMethodNamesInTestPaths_ReturnsTrue
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodClassifierTests.ClassifyTestType_WithSpecificTestPaths_ReturnsCorrectType
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodClassifierTests.ClassifyTestType_WithSpecificMethodNames_ReturnsCorrectType
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodClassifierTests.ClassifyTestType_WithRegularTestMethod_ReturnsUnit
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodClassifierTests.CalculateTestConfidence_WithTestNameInTestPath_ReturnsHighConfidence
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodClassifierTests.CalculateTestConfidence_WithNonTestMethod_ReturnsLowConfidence
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodClassifierTests.GetTestMethods_WithMixedMethods_ReturnsOnlyTestMethods
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodClassifierTests.GroupTestMethodsByType_WithVariousTestTypes_GroupsCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodClassifierTests.IsTestMethod_WithNullMethodInfo_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodClassifierTests.ClassifyTestType_WithNullMethodInfo_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodClassifierTests.CalculateTestConfidence_WithNullMethodInfo_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.GetCallGraphAsync_WithNoCachedEntry_ReturnsNull
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.StoreCallGraphAsync_WithValidData_StoresSuccessfully
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.GetCallGraphAsync_WithValidCachedEntry_ReturnsEntry
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.GetCallGraphAsync_WithChangedAssemblies_InvalidatesCache
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.GetCallGraphAsync_WithModifiedProject_InvalidatesCache
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.GetStatisticsAsync_ReturnsAccurateStatistics
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.ClearAsync_RemovesAllEntries
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.PerformMaintenanceAsync_ExecutesWithoutError
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.InvalidateProjectAsync_InvalidatesSpecificProject
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.CompressionEffectiveness_AchievesGoodCompression
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.CacheEntryValidation_DetectsIntegrityIssues
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.CacheEntryStatistics_ReturnsAccurateMetrics
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.GenerateCacheKey_WithSameInputs_GeneratesSameKey
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.GenerateCacheKey_WithDifferentInputs_GeneratesDifferentKeys
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCacheTests.ConcurrentAccess_HandlesMultipleOperations
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.Constructor_WithNullLogger_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.Constructor_WithValidLogger_ShouldCreateInstance
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.GetOrParse_WithSimpleCode_ShouldReturnSyntaxTree
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.GetOrParse_WithSameContent_ShouldReturnCachedTree
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.GetOrParse_WithDifferentContent_ShouldCreateNewTree
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.Return_WithValidSyntaxTree_ShouldReturnToPool
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.Return_WithNullSyntaxTree_ShouldNotThrow
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.GetOrParse_WithPooledTree_ShouldReuseFromPool
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.GetStatistics_WithMultipleOperations_ShouldTrackCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.Clear_ShouldResetAllStatistics
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.Pool_WithCustomOptions_ShouldRespectLimits
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.Pool_WithManyDifferentFiles_ShouldRespectCacheLimit
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.GetOrParse_WithInvalidOrEmptyCode_ShouldStillReturnTree
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.GetOrParse_WithLargeFile_ShouldHandleGracefully
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.GetStatistics_InitialState_ShouldReturnZeros
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.Dispose_ShouldCleanupResources
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolTests.Pool_UnderHighConcurrency_ShouldRemainThreadSafe
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolOptionsTests.DefaultOptions_ShouldHaveReasonableDefaults
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolStatisticsTests.CacheHitRatio_WithZeroRequests_ShouldReturnZero
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolStatisticsTests.CacheHitRatio_WithRequests_ShouldCalculateCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolStatisticsTests.PoolHitRatio_WithRequests_ShouldCalculateCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SyntaxTreePoolStatisticsTests.ReuseRatio_WithRequests_ShouldCalculateCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BasicRoslynTests.RoslynAnalyzer_CanBeCreated
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BasicRoslynTests.RoslynAnalyzer_Constructor_WithNullLogger_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BasicRoslynTests.RoslynAnalyzer_Constructor_WithNullLoggerFactory_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BasicRoslynTests.RoslynAnalyzer_Dispose_DoesNotThrow
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BasicRoslynTests.RoslynAnalyzer_DoubleDispose_DoesNotThrow
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BasicRoslynTests.ExtractMethodsFromFileAsync_WithEmptyFile_ReturnsEmpty
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BasicRoslynTests.ExtractMethodsFromFileAsync_WithValidClass_ExtractsMethods
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ BasicRoslynTests.GetSemanticModelAsync_WithValidFile_ReturnsSemanticModel
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CancellationHandlingTests.GetAffectedMethodsAsync_WithCancelledToken_ShouldThrowOperationCanceledException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CancellationHandlingTests.GetSemanticModelAsync_WithCancelledToken_ShouldThrowOperationCanceledException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CancellationHandlingTests.AnalyzeTypeUsageAsync_WithCancelledToken_ShouldThrowOperationCanceledException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CancellationHandlingTests.ExtractMethodsFromFileAsync_WithCancelledToken_ShouldThrowOperationCanceledException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CancellationHandlingTests.FindTestsExercisingMethodAsync_WithCancelledToken_ShouldThrowOperationCanceledException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CancellationHandlingTests.CancellationToken_ShouldPropagateToNestedOperations
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CancellationHandlingTests.MultipleOperations_WithSharedCancellationToken_ShouldAllCancel
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CancellationHandlingTests.CancellationToken_WithGracefulFallback_ShouldHandleCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageResultTests.Constructor_WithValidInputs_CalculatesStatisticsCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageResultTests.Constructor_WithFullCoverage_Returns100Percent
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageResultTests.Constructor_WithNoCoverage_ReturnsZeroPercent
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageResultTests.Constructor_WithNoChanges_Returns100Percent
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageResultTests.ConfidenceBreakdown_CalculatesCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageResultTests.CoverageByTestType_CalculatesCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageResultTests.Recommendations_GeneratesCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageResultTests.Constructor_WithNullCodeChanges_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CodeChangeCoverageResultTests.ToString_ReturnsFormattedString
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CoverageByConfidenceTests.Constructor_WithEmptyScores_InitializesCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CoverageByConfidenceTests.Constructor_WithMixedConfidenceScores_CalculatesCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CoverageByConfidenceTests.Constructor_WithBoundaryValues_CalculatesCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompilationManagerTests.Constructor_WithNullLogger_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompilationManagerTests.Constructor_WithNullWorkspace_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompilationManagerTests.Constructor_WithValidParameters_ShouldCreateInstance
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompilationManagerTests.GetSemanticModel_WithMockedWorkspace_ShouldHandleNullGracefully
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompilationManagerTests.GetSemanticModel_WithNullOrEmptyPath_ShouldReturnNull
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompilationManagerTests.ResolveSymbolInfo_WithInvalidFile_ShouldReturnNull
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompilationManagerTests.ResolveTypeInfo_WithInvalidFile_ShouldReturnNull
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CompilationManagerTests.ClearSemanticModelCache_ShouldClearCache
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ EnhancedRoslynAnalyzerTests.FindTestsExercisingMethod_ShouldDetectMoreCoverage_ThanLegacyAnalyzer
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ EnhancedRoslynAnalyzerTests.RoslynAnalyzerFactory_ShouldCreateRoslynAnalyzer
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.Constructor_WithNullLogger_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.Constructor_WithNullRoslynAnalyzer_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.Constructor_WithValidParameters_ShouldInitializeSuccessfully
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithNullContent_ShouldReturnEmptyChangeSet
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithEmptyContent_ShouldReturnEmptyChangeSet
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithWhitespaceContent_ShouldReturnEmptyChangeSet
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithSimpleModification_ShouldParseCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithNewFile_ShouldDetectAddedFile
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithDeletedFile_ShouldDetectDeletedFile
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithMultipleFiles_ShouldParseAllFiles
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithNonCSharpFile_ShouldIgnoreFile
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithComplexMethodSignatures_ShouldDetectMethods
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithNoMethodOrTypeChanges_ShouldReturnEmptyChangeSet
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffFileAsync_WithNonExistentFile_ShouldThrowFileNotFoundException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffFileAsync_WithValidFile_ShouldParseContent
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffFileAsync_WithEmptyFile_ShouldReturnEmptyChangeSet
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffFromCommandAsync_WithNullCommand_ShouldHandleGracefully
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffFromCommandAsync_WithInvalidGitCommand_ShouldThrowInvalidOperationException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffFromCommandAsync_WithValidCommand_ShouldExecuteAndParse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffFromCommandAsync_WithGitPrefix_ShouldRemovePrefix
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithVariousMethodSignatures_ShouldExtractMethodNames
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithVariousTypeDeclarations_ShouldExtractTypeNames
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithInvalidMethodNames_ShouldFilterOutKeywords
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithBinaryFile_ShouldIgnoreBinaryChanges
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithMalformedDiff_ShouldHandleGracefully
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithVeryLargeDiff_ShouldHandleEfficiently
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_ShouldLogAppropriateMessages
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ GitDiffParserTests.ParseDiffAsync_WithEmptyContent_ShouldLogWarning
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerEdgeCaseTests.ExtractMethodsFromFileAsync_WithComplexSyntax_ShouldHandleCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerEdgeCaseTests.FindTestsExercisingMethodAsync_WithComplexTestScenarios_ShouldDetectCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerEdgeCaseTests.AnalyzeTypeUsageAsync_WithNestedGenerics_ShouldHandleCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerTests.GetAffectedMethodsAsync_WithMethodChanges_ShouldReturnTransitiveDependents
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerTests.GetSemanticModelAsync_WithValidFile_ShouldReturnSemanticModel
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerTests.GetSemanticModelAsync_WithNonExistentFile_ShouldThrowFileNotFoundException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerTests.AnalyzeTypeUsageAsync_WithMultipleTypes_ShouldReturnAllUsages
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerTests.ExtractMethodsFromFileAsync_WithMultipleMethods_ShouldReturnAllMethods
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerTests.ExtractMethodsFromFileAsync_WithNonExistentFile_ShouldThrowFileNotFoundException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerTests.AnalyzeTypeUsageAsync_WithEmptyFileArray_ShouldReturnEmptyList
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerTests.AnalyzeTypeUsageAsync_WithDifferentTypeDeclarations_ShouldDetectAll
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerTests.FindTestsExercisingMethodAsync_WithDirectTestCall_ShouldReturnTest
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerTests.FindTestsExercisingMethodAsync_WithIndirectTestCall_ShouldReturnTest
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerTests.FindTestsExercisingMethodAsync_WithNoTestCoverage_ShouldReturnEmpty
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerTests.FindTestsExercisingMethodAsync_WithMultipleTests_ShouldReturnAll
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MethodCallGraphTests.Constructor_WithNullCallGraph_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MethodCallGraphTests.Constructor_WithNullMethodDefinitions_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MethodCallGraphTests.GetMethodCalls_WithExistingMethod_ShouldReturnCalls
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MethodCallGraphTests.GetMethodCalls_WithNonExistentMethod_ShouldReturnEmptySet
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MethodCallGraphTests.GetMethodDependents_WithMethodThatIsCalled_ShouldReturnCallers
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MethodCallGraphTests.GetTransitiveDependents_WithDeepCallChain_ShouldReturnAllTransitiveCallers
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MethodCallGraphTests.GetMethodInfo_WithExistingMethod_ShouldReturnMethodInfo
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MethodCallGraphTests.GetMethodInfo_WithNonExistentMethod_ShouldReturnNull
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MethodCallGraphTests.GetTestMethodsExercisingMethod_WithDirectTestCall_ShouldReturnTestMethod
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MethodCallGraphTests.GetTestCoverageForMethod_WithDirectTestCall_ShouldReturnCoverageResult
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MethodInfoTests.Constructor_WithValidParameters_ShouldCreateInstance
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MethodInfoTests.Constructor_WithNullParameter_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ MethodInfoTests.ToString_ShouldReturnFormattedString
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TypeUsageInfoTests.Constructor_WithValidParameters_ShouldCreateInstance
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TypeUsageInfoTests.Constructor_WithNullParameter_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TypeUsageInfoTests.Constructor_WithNullNamespace_ShouldAllowNullAndConvertToEmpty
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TypeUsageInfoTests.FullTypeName_WithNamespace_ShouldReturnQualifiedName
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TypeUsageInfoTests.FullTypeName_WithEmptyNamespace_ShouldReturnTypeName
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TypeUsageInfoTests.ToString_ShouldReturnFormattedString
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageResultTests.Constructor_WithValidParameters_ShouldCreateInstance
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageResultTests.CallDepth_WithTwoElementPath_ShouldReturnOne
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageResultTests.CallDepth_WithThreeElementPath_ShouldReturnTwo
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageResultTests.CallDepth_ShouldReturnCorrectCount
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageResultTests.ToString_ShouldReturnFormattedString
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageResultTests.Constructor_WithNullParameter_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageResultTests.Constructor_WithNullCallPath_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.GetAffectedMethodsAsync_WithEmptyChanges_ShouldReturnEmptyList
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.GetAffectedMethodsAsync_WithCancellation_ShouldThrowOperationCanceledException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.GetSemanticModelAsync_WithNonExistentFile_ShouldThrowFileNotFoundException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.GetSemanticModelAsync_WithMalformedSourceCode_ShouldHandleGracefully
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.AnalyzeTypeUsageAsync_WithNonExistentFiles_ShouldSkipGracefully
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.AnalyzeTypeUsageAsync_WithMixOfValidAndInvalidFiles_ShouldProcessValidOnes
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.AnalyzeTypeUsageAsync_WithCancellation_ShouldThrowOperationCanceledException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.ExtractMethodsFromFileAsync_WithNonExistentFile_ShouldThrowFileNotFoundException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.ExtractMethodsFromFileAsync_WithEmptyFile_ShouldReturnEmptyList
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.ExtractMethodsFromFileAsync_WithCompilationErrors_ShouldHandleGracefully
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.ExtractMethodsFromFileAsync_WithCancellation_ShouldThrowOperationCanceledException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.FindTestsExercisingMethodAsync_WithNonExistentMethod_ShouldReturnEmpty
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.FindTestsExercisingMethodAsync_WithEmptySolutionFiles_ShouldFallbackGracefully
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.FindTestsExercisingMethodAsync_WithCancellation_ShouldThrowOperationCanceledException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.WorkspaceInitialization_WithCorruptedProjectFile_ShouldFallbackGracefully
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.Dispose_ShouldCleanupResources
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.Dispose_CalledMultipleTimes_ShouldNotThrow
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynCoreComponentTests.RoslynAnalyzer_Constructor_WithValidParameters_ShouldCreateInstance
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynCoreComponentTests.RoslynAnalyzer_Constructor_WithNullLogger_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynCoreComponentTests.RoslynAnalyzer_Constructor_WithNullLoggerFactory_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynCoreComponentTests.RoslynAnalyzer_Dispose_ShouldNotThrow
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynCoreComponentTests.RoslynAnalyzer_DoubleDispose_ShouldNotThrow
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynCoreComponentTests.GetAffectedMethodsAsync_WithEmptyInputs_ShouldReturnEmpty
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynCoreComponentTests.FindTestsExercisingMethodAsync_WithEmptyInputs_ShouldReturnEmpty
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynCoreComponentTests.AnalyzeTypeUsageAsync_WithEmptyFiles_ShouldReturnEmpty
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynCoreComponentTests.ExtractMethodsFromFileAsync_WithNonExistentFile_ShouldThrowFileNotFoundException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynCoreComponentTests.ExtractMethodsFromFileAsync_WithEmptyFile_ShouldReturnEmpty
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynCoreComponentTests.ExtractMethodsFromFileAsync_WithValidCSharpFile_ShouldExtractMethods
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynCoreComponentTests.GetSemanticModelAsync_WithNonExistentFile_ShouldThrowFileNotFoundException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ RoslynCoreComponentTests.GetSemanticModelAsync_WithValidFile_ShouldReturnSemanticModel
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolIndexTests.FindFilesContainingMethodAsync_WithoutIndex_ShouldReturnEmpty
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolIndexTests.FindFilesContainingMethodAsync_WithNonexistentMethod_ShouldReturnEmpty
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolIndexTests.FindFilesContainingTypeAsync_ShouldFindTypes
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolIndexTests.GetFilesInNamespaceAsync_ShouldFindNamespaces
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolIndexTests.FindProjectsContainingMethodAsync_ShouldReturnProjectInfo
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolIndexTests.GetProjectForFile_WithValidFile_ShouldReturnProjectInfo
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolIndexTests.GetProjectForFile_WithNonexistentFile_ShouldReturnNull
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolIndexTests.RefreshFilesAsync_ShouldUpdateIndex
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolIndexTests.Clear_ShouldResetIndex
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolIndexTests.FindFilesContainingMethodAsync_WithFuzzyMatching_ShouldWork
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolIndexTests.ProjectInfo_Equality_ShouldWorkCorrectly
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolResolutionEngineTests.Constructor_WithNullCompilationManager_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolResolutionEngineTests.Constructor_WithNullLogger_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolResolutionEngineTests.ResolveMethodSymbol_WithNoSemanticModel_ShouldReturnNull
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolResolutionEngineTests.GetFullyQualifiedMethodName_WithNullMethodSymbol_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolResolutionEngineTests.GetFullyQualifiedMethodName_WithStandaloneMethodSymbol_ShouldReturnFullName
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolResolutionEngineTests.ResolveMemberAccess_WithNoSemanticModel_ShouldReturnNull
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolResolutionEngineTests.HandleGenericMethods_WithNonGenericMethod_ShouldReturnSameMethod
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolResolutionEngineTests.HandleGenericMethods_WithNullMethod_ShouldReturnNull
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolResolutionEngineTests.ResolveInterfaceImplementations_WithMockedManager_ShouldReturnEmpty
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolResolutionEngineTests.ResolveInterfaceImplementations_WithNonInterfaceMethod_ShouldReturnEmpty
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolResolutionEngineTests.ResolveVirtualOverrides_WithMockedManager_ShouldReturnEmpty
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ SymbolResolutionEngineTests.ResolveVirtualOverrides_WithNonVirtualMethod_ShouldReturnEmpty
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ExecutionTraceControllerTests.TraceTestExecution_WithValidRequest_ReturnsOk
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ExecutionTraceControllerTests.TraceTestExecution_WithEmptyTestMethodId_ReturnsBadRequest
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ExecutionTraceControllerTests.TraceTestExecution_WithMissingSolutionPath_ReturnsBadRequest
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ExecutionTraceControllerTests.TraceMultipleTestsExecution_WithValidRequest_ReturnsOk
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ExecutionTraceControllerTests.GenerateCoverageReport_WithValidRequest_ReturnsOk
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ExecutionTraceControllerTests.GetTestExecutionStatistics_WithValidRequest_ReturnsOk
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ExecutionTraceControllerTests.TraceMultipleTestsExecution_WithInvalidTestMethodIds_ReturnsBadRequest
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryControllerTests.DiscoverTests_WithValidPath_ReturnsTestResults
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryControllerTests.DiscoverTests_WithInvalidPath_ReturnsBadRequest
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryControllerTests.DiscoverTests_WithCategoryFilter_FiltersResults
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryControllerTests.GetTestCategories_ReturnsAllCategories
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryControllerTests.HealthCheck_ReturnsHealthyStatus
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryControllerTests.DiscoverTests_CreatesValidSummary
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestDiscoveryControllerTests.DiscoverTests_PopulatesCategoryBreakdown
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionControllerTests.GetTestPlan_WithValidRequest_ReturnsOkResult
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionControllerTests.GetTestPlan_WithCodeChanges_CallsOptimalTestPlanAsync
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionControllerTests.AnalyzeDiff_WithValidRequest_ReturnsAnalysisResult
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionControllerTests.UpdateExecutionHistory_WithValidResults_ReturnsOk
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionControllerTests.GetTestHistory_WithFilter_ReturnsFilteredResults
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionControllerTests.GetTestPlan_WithException_ReturnsBadRequest
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfidenceLevelTests.GetConfidenceScore_ShouldReturnCorrectScore
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfidenceLevelTests.GetEstimatedDuration_ShouldReturnCorrectTimeSpan
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfidenceLevelTests.GetMaxTestCount_ShouldReturnCorrectLimit
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfidenceLevelTests.GetConfidenceScore_WithInvalidLevel_ShouldThrowArgumentOutOfRangeException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfidenceLevelTests.GetEstimatedDuration_WithInvalidLevel_ShouldThrowArgumentOutOfRangeException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ ConfidenceLevelTests.GetMaxTestCount_WithInvalidLevel_ShouldThrowArgumentOutOfRangeException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionPlanTests.Constructor_WithValidParameters_ShouldCreatePlan
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionPlanTests.Constructor_WithNullTests_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionPlanTests.Constructor_WithEmptyTests_ShouldCreateEmptyPlan
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionPlanTests.TestCategoryBreakdown_ShouldCountTestsByCategory
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionPlanTests.GetTestsByCategory_ShouldReturnFilteredTests
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionPlanTests.CreateExecutionBatches_WithCompatibleTests_ShouldCreateOptimalBatches
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionPlanTests.CreateExecutionBatches_WithIncompatibleTests_ShouldSeparateThem
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionPlanTests.GetOptimizedExecutionTime_WithBatches_ShouldReturnBatchBasedDuration
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionPlanTests.GetOptimizedExecutionTime_WithoutBatches_ShouldReturnEstimatedDuration
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionPlanTests.ToString_ShouldIncludeKeyMetrics
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionBatchTests.Constructor_WithValidParameters_ShouldCreateBatch
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionBatchTests.Constructor_WithNullTests_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionBatchTests.CanExecuteInParallel_WithSingleTest_ShouldReturnFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionBatchTests.CanExecuteInParallel_WithMultipleTests_ShouldReturnTrue
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestExecutionBatchTests.ToString_ShouldIncludeBatchInfo
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestInfoTests.Constructor_WithValidParameters_ShouldCreateInstance
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestInfoTests.Constructor_WithNullTestMethod_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestInfoTests.GetUniqueId_ShouldReturnTestMethodUniqueId
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestInfoTests.GetDisplayName_ShouldReturnTestMethodDisplayName
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestInfoTests.CalculateFailureRate_WithNoHistory_ShouldReturnZero
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestInfoTests.CalculateFailureRate_WithMixedResults_ShouldReturnCorrectRate
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestInfoTests.IsFlaky_WithInsufficientHistory_ShouldReturnFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestInfoTests.IsFlaky_WithVariousFailureRates_ShouldDetectFlakyTests
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestInfoTests.GetLastExecutionResult_WithNoHistory_ShouldReturnNull
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestInfoTests.GetLastExecutionResult_WithHistory_ShouldReturnMostRecentResult
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestInfoTests.ToString_ShouldIncludeDisplayNameScoreAndCategory
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionEngineTests.Constructor_WithValidParameters_ShouldCreateInstance
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionEngineTests.Constructor_WithNullLogger_ShouldThrowArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionEngineTests.GetTestPlanAsync_WithFastConfidence_ShouldCreatePlan
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionEngineTests.GetOptimalTestPlanAsync_WithCodeChanges_ShouldCreatePlan
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionEngineTests.ScoreTestsAsync_WithCandidateTests_ShouldReturnScoredTests
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionEngineTests.UpdateTestExecutionHistoryAsync_WithResults_ShouldUpdateHistory
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionEngineTests.GetTestHistoryAsync_WithoutFilter_ShouldReturnAllTests
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionEngineTests.GetTestHistoryAsync_WithFilter_ShouldReturnFilteredTests
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionEngineTests.GetTestPlanAsync_WithDifferentConfidenceLevels_ShouldRespectLimits
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionEngineTests.GetTestPlanAsync_WithSelectionOptions_ShouldApplyConstraints
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionEngineTests.ScoreTestsAsync_WithMixedTestTypes_ShouldPrioritizeBasedOnCategory
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionEngineTests.ScoreTestsAsync_WithExecutionHistoryContext_ShouldConsiderReliability
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestSelectionEngineTests.ScoreTestsAsync_WithDifferentConfidenceLevels_ShouldAdjustScoring
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FullWorkflowE2ETests.FullWorkflow_AnalyzeThenFindTests_WorksEndToEnd
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FullWorkflowE2ETests.FullWorkflow_CallGraphThenFindTests_ShowsConsistentResults
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FullWorkflowE2ETests.FullWorkflow_ErrorHandling_FailsGracefullyWithInvalidInputs
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FullWorkflowE2ETests.FullWorkflow_OutputConsistency_JsonAndTextOutputsAreConsistent
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FullWorkflowE2ETests.FullWorkflow_PerformanceBaseline_CompletesWithinReasonableTime
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AnalyzeCommandE2ETests.Analyze_WithValidSolution_ReturnsAnalysisResults
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AnalyzeCommandE2ETests.Analyze_WithJsonOutput_ReturnsValidJson
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AnalyzeCommandE2ETests.Analyze_WithVerboseOutput_IncludesDetailedInformation
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AnalyzeCommandE2ETests.Analyze_WithOutputFile_WritesToFile
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AnalyzeCommandE2ETests.Analyze_WithJsonOutputFile_WritesValidJsonToFile
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AnalyzeCommandE2ETests.Analyze_WithNonExistentPath_FailsGracefully
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ AnalyzeCommandE2ETests.Analyze_CommandExists_InHelpOutput
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCommandE2ETests.CallGraph_WithValidSolution_ReturnsCallGraphResults
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCommandE2ETests.CallGraph_WithJsonOutput_ReturnsValidJson
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCommandE2ETests.CallGraph_WithVerboseOutput_IncludesMethodDetails
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCommandE2ETests.CallGraph_WithMaxMethodsLimit_RespectsLimit
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCommandE2ETests.CallGraph_WithOutputFile_WritesToFile
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCommandE2ETests.CallGraph_WithJsonOutputFile_WritesValidJsonToFile
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCommandE2ETests.CallGraph_WithNonExistentPath_FailsGracefully
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ CallGraphCommandE2ETests.CallGraph_CommandExists_InHelpOutput
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DiffCommandE2ETests.Diff_WithDiffContent_ReturnsImpactAnalysis
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DiffCommandE2ETests.Diff_WithDiffFile_ReadsFileAndAnalyzes
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DiffCommandE2ETests.Diff_WithGitCommand_ExecutesGitAndAnalyzes
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DiffCommandE2ETests.Diff_WithJsonOutput_ReturnsValidJson
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DiffCommandE2ETests.Diff_WithOutputFile_WritesToFile
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DiffCommandE2ETests.Diff_WithMultipleDiffSources_FailsValidation
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DiffCommandE2ETests.Diff_WithNoDiffSource_FailsValidation
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ DiffCommandE2ETests.Diff_CommandExists_InHelpOutput
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FindTestsCommandE2ETests.FindTests_WithValidMethod_ReturnsExpectedResults
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FindTestsCommandE2ETests.FindTests_WithJsonOutput_ReturnsValidJson
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FindTestsCommandE2ETests.FindTests_WithVerboseOutput_IncludesCallPaths
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FindTestsCommandE2ETests.FindTests_WithOutputFile_WritesToFile
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FindTestsCommandE2ETests.FindTests_WithNonExistentMethod_ReturnsNoResults
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ FindTestsCommandE2ETests.FindTests_WithInvalidSolution_FailsGracefully
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ VersionCommandE2ETests.Version_Command_ReturnsVersionInformation
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ VersionCommandE2ETests.Version_CommandExists_InHelpOutput
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
+diff --git a/select-medium.json b/select-medium.json
+new file mode 100644
+index 0000000..91f1919
+--- /dev/null
++++ b/select-medium.json
+@@ -0,0 +1,819 @@
++=== Test Selection Report ===
++Path: TestIntelligence.sln
++Timestamp: 2025-09-04 00:45:02
++Confidence Level: Medium
++Changed Files: NUnitTestDiscovery.cs
++
++=== Selection Summary ===
++Selected Tests: 200
++Estimated Duration: 20s
++Average Score: 0.515
++Optimal Parallelism: 4
++
++=== Category Breakdown ===
++  UI: 75 tests
++  Database: 54 tests
++  Unit: 53 tests
++  Integration: 18 tests
++
++=== Selected Tests ===
++‚Ä¢ CacheInvalidationIntegrationTests.SolutionCacheManager_InvalidatesOnFileChange
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CacheInvalidationIntegrationTests.ProjectCacheManager_InvalidatesOnContentChange
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CacheInvalidationIntegrationTests.CallGraphCache_InvalidatesOnProjectFileChange
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CacheInvalidationIntegrationTests.EndToEndCacheInvalidation_WorksAcrossAllLayers
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CacheInvalidationIntegrationTests.CacheInvalidation_PerformanceTest
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.Resolver_WithCircularDependency_CanBeTestedThroughIntegration
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ BaseAssemblyLoaderRegressionTests.TryUnloadAssembly_Integration_ReturnsExpectedValue
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceTestExecutionAsync_WithDeepCallChain_HandlesMaxDepthCorrectly
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceTestExecutionAsync_WithCircularReferences_PreventsInfiniteLoop
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceTestExecutionAsync_WithLargeBreadth_LimitsBreadthCorrectly
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceTestExecutionAsync_WithCachingEnabled_UsesCachedResults
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceMultipleTestsAsync_WithLargeTestSuite_UsesParallelProcessing
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceTestExecutionAsync_WithAsyncMethods_TracesCorrectly
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.GenerateCoverageReportAsync_WithMixedCodebase_GeneratesAccurateReport
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ TestExecutionTracerIntegrationTests.TraceTestExecutionAsync_WithGenericMethods_HandlesCorrectly
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CompilationCacheIntegrationTests.OptimizedAnalyzer_ShowsPerformanceImprovement
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CompilationCacheIntegrationTests.EnhancedCache_MultiLevelCaching_WorksCorrectly
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CompilationCacheIntegrationTests.SyntaxTreePool_ShowsMemoryOptimization
++  Score: 0.660 | Category: Integration | Duration: 0s
++  Tags: Integration
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.AssemblyLoaded_EventHandlers_ShouldBeInvokable
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.AssemblyLoadFailed_EventHandlers_ShouldBeInvokable
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ CrossFrameworkAssemblyLoaderTests.LoadAssembly_ConcurrentCalls_ShouldBeThreadSafe
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_ShouldBeCaseInsensitive
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ FrameworkDetectorTests.DetectFrameworkVersion_ConcurrentCalls_ShouldBeThreadSafe
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ DataConflictTests.Constructor_WithNullTestMethodB_ThrowsArgumentNullException
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ DatabaseFrameworkTests.DatabaseFramework_EnumValues_AreCorrect
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ DatabaseFrameworkTests.DatabaseFramework_ToString_ReturnsCorrectName
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ DatabaseFrameworkTests.DatabaseFramework_AllValuesAreDefined
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.DetectDatabaseOperationsAsync_WithNullTestMethod_ThrowsArgumentNullException
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.DetectDatabaseOperationsAsync_WithValidTestMethod_ReturnsEmptyList
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.DetectDatabaseOperationsAsync_WithCancellationToken_RespectsToken
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.DetectDatabaseOperationsAsync_WithSetupMethods_HandlesNullEnumerable
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.DetectDatabaseOperationsAsync_WithSetupMethods_ReturnsEmptyListForEmptyEnumerable
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.DetectDatabaseOperationsAsync_WithSetupMethods_ProcessesMultipleMethods
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.RequiresExclusiveDbAccess_WithMethodNameIndicatingExclusiveAccess_ReturnsTrue
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.RequiresExclusiveDbAccess_WithNormalTestMethod_ReturnsFalse
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.RequiresExclusiveDbAccess_WithNullTestMethod_ThrowsArgumentNullException
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.SharesDatabaseDependency_WithNullParameters_ThrowsArgumentNullException
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.SharesDatabaseDependency_WithNoDatabaseDependencies_ReturnsFalse
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.SharesDatabaseDependency_WithSameResourceIdentifier_ReturnsTrue
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.SharesDatabaseDependency_WithSharedEntityTypes_ReturnsTrue
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.SharesDatabaseDependency_WithNoSharedDependencies_ReturnsFalse
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.DetectDbContextUsageAsync_WithNullMethod_ThrowsArgumentNullException
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.DetectDbContextUsageAsync_WithValidMethod_ReturnsResult
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EF6PatternDetectorTests.RequiresExclusiveDbAccess_WithExceptionThrown_ReturnsTrue
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectDatabaseOperationsAsync_WithNullTestMethod_ThrowsArgumentNullException
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectDatabaseOperationsAsync_WithValidTestMethod_ReturnsEmptyList
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectDatabaseOperationsAsync_WithCancellationToken_RespectsToken
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectDatabaseOperationsAsync_WithSetupMethods_HandlesNullEnumerable
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectDatabaseOperationsAsync_WithSetupMethods_ReturnsEmptyListForEmptyEnumerable
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectDatabaseOperationsAsync_WithSetupMethods_ProcessesMultipleMethods
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.RequiresExclusiveDbAccess_WithInMemoryDatabase_ReturnsFalse
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.RequiresExclusiveDbAccess_WithNullTestMethod_ThrowsArgumentNullException
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.SharesDatabaseDependency_WithNullParameters_ThrowsArgumentNullException
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.SharesDatabaseDependency_WithNoDatabaseDependencies_ReturnsFalse
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.SharesDatabaseDependency_WithSameInMemoryDatabase_ReturnsTrue
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.SharesDatabaseDependency_WithDifferentInMemoryDatabases_ReturnsFalse
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.SharesDatabaseDependency_WithSameResourceIdentifier_ReturnsTrue
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.SharesDatabaseDependency_WithSharedEntityTypes_ReturnsTrue
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.SharesDatabaseDependency_WithNoSharedDependencies_ReturnsFalse
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectDbContextUsageAsync_WithNullMethod_ThrowsArgumentNullException
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectDbContextUsageAsync_WithValidMethod_ReturnsResult
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectInMemoryDatabaseUsageAsync_WithNullMethod_ThrowsArgumentNullException
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.DetectInMemoryDatabaseUsageAsync_WithValidMethod_ReturnsResult
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.RequiresExclusiveDbAccess_WithExceptionThrown_ReturnsFalse
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.RequiresExclusiveDbAccess_CurrentBehavior_BlocksOnAsyncCall
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ EFCorePatternDetectorTests.RequiresExclusiveDbAccess_CurrentBehaviorWithException_HandlesGracefully
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ HelperClassTests.InMemoryDatabaseUsage_Constructor_WithValidParameters_SetsProperties
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ HelperClassTests.InMemoryDatabaseUsage_Constructor_WithNullDatabaseName_ThrowsArgumentNullException
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ HelperClassTests.InMemoryDatabaseUsage_Constructor_WithNullContextType_ThrowsArgumentNullException
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ SyntaxTreePoolOptionsTests.Options_ShouldBeConfigurable
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ CancellationHandlingTests.CancellationDuringWorkspaceInitialization_ShouldBeHandledGracefully
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ TestSelectionEngineTests.ScoreTestsAsync_WithCodeChanges_ShouldBoostRelatedTests
++  Score: 0.540 | Category: Database | Duration: 0s
++  Tags: Database
++
++‚Ä¢ ConsoleAssemblyLoadLoggerTests.LogDebug_InDebugBuild_ShouldWriteToConsole
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ StreamingTestCoverageAnalyzerTests.FindTestsExercisingMethodStreamAsync_WithCallGraphBuildFailure_ShouldUseFallback
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ TestCoverageAnalyzerTests.BuildTestCoverageMapAsync_WithValidSolution_ReturnsTestCoverageMap
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ BasicRoslynTests.BuildCallGraphAsync_WithEmptyFiles_ReturnsEmptyGraph
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ CancellationHandlingTests.BuildCallGraphAsync_WithPreCancelledToken_ShouldThrowOperationCanceledException
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ CancellationHandlingTests.BuildCallGraphAsync_WithTokenCancelledDuringExecution_ShouldThrowOperationCanceledException
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ CancellationHandlingTests.BuildCallGraphAsync_WithTimeoutToken_ShouldRespectTimeout
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ CancellationHandlingTests.BuildCallGraphAsync_WithVariousTimeouts_ShouldHandleCorrectly
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ EnhancedRoslynAnalyzerTests.BuildCallGraph_WithCrossProjectCalls_ShouldCaptureAllReferences
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.BuildCallGraphForMethodAsync_WithValidMethod_ShouldReturnCallGraph
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.BuildCallGraphForMethodAsync_WithNonexistentMethod_ShouldReturnEmptyGraph
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.BuildCallGraphForMethodAsync_WithMaxDepthLimit_ShouldRespectDepth
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.BuildCallGraphForMethodsAsync_WithMultipleMethods_ShouldCombineResults
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.BuildCallGraphForMethodAsync_WithCachedResult_ShouldUseCacheOnSecondCall
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.BuildCallGraphForMethodAsync_WithCompilationError_ShouldHandleGracefully
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.ClearCaches_ShouldResetInternalCaches
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.BuildCallGraphForMethodAsync_WithCancellation_ShouldRespectCancellationToken
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.BuildCallGraphForMethodsAsync_WithEmptyMethodList_ShouldReturnEmptyResult
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ IncrementalCallGraphBuilderTests.BuildCallGraphForMethodAsync_WithInvalidMaxDepth_ShouldHandleGracefully
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.InitializeAsync_WithValidSolution_ShouldSucceed
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.InitializeAsync_WithSingleProject_ShouldSucceed
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetOrLoadProjectAsync_WithValidProject_ShouldLoadProject
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetOrLoadProjectAsync_WithSameProjectTwice_ShouldUseCache
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetOrLoadProjectAsync_WithNonexistentProject_ShouldReturnNull
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetCompilationAsync_WithValidProject_ShouldReturnCompilation
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetCompilationAsync_WithSameProjectTwice_ShouldUseCache
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetProjectContainingFileAsync_WithValidFile_ShouldReturnProject
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetProjectContainingFileAsync_WithNonexistentFile_ShouldReturnNull
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetProjectsContainingMethodAsync_WithValidMethod_ShouldReturnProjects
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetAllProjectPathsAsync_ShouldReturnAllProjects
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.PreloadProjectsAsync_ShouldLoadProjectsInBackground
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.GetStats_ShouldReturnAccurateStatistics
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.ClearCaches_ShouldResetCachedData
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.InitializeAsync_WithInvalidPath_ShouldHandleGracefully
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.WorkspaceStats_LoadedProjectsPercentage_ShouldCalculateCorrectly
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ LazyWorkspaceBuilderTests.WorkspaceStats_LoadedProjectsPercentage_WithZeroTotal_ShouldReturnZero
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerCallGraphTests.BuildCallGraphAsync_CapturesConstructorCalls
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerCallGraphTests.BuildCallGraphAsync_CapturesPropertyAccess
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerCallGraphTests.BuildCallGraphAsync_CapturesMethodInvocations
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerCallGraphTests.BuildCallGraphAsync_IdentifiesTestMethods
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerCallGraphTests.BuildCallGraphAsync_HandlesComplexCallChains
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerEdgeCaseTests.BuildCallGraphAsync_WithGenericMethods_ShouldHandleCorrectly
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerEdgeCaseTests.BuildCallGraphAsync_WithInterfaceImplementations_ShouldDetectPolymorphism
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerEdgeCaseTests.BuildCallGraphAsync_WithLambdaExpressions_ShouldHandleCorrectly
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerEdgeCaseTests.BuildCallGraphAsync_WithAsyncAwaitPattern_ShouldHandleCorrectly
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerEdgeCaseTests.BuildCallGraphAsync_WithReflectionCalls_ShouldHandleGracefully
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerEdgeCaseTests.BuildCallGraphAsync_WithCircularReferences_ShouldHandleWithoutInfiniteLoop
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerEdgeCaseTests.BuildCallGraphAsync_WithLargeCodebase_ShouldPerformReasonably
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithLazyWorkspace_ShouldInitializeLazilyOnFirstCall
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithLazyWorkspace_ShouldFallbackToLegacyOnFailure
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithValidSolution_ShouldPreferIncrementalAnalysis
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithMultipleCalls_ShouldReuseInfrastructure
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithCancellation_ShouldHandleGracefully
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithEmptyFileList_ShouldReturnEmptyGraph
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithInvalidSolutionPath_ShouldFallbackGracefully
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithMixedFileTypes_ShouldHandleAppropriately
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithRepeatedCalls_ShouldMaintainPerformance
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerLazyLoadingTests.BuildCallGraphAsync_WithLargeTimeout_ShouldCompleteWithinReasonableTime
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerTests.BuildCallGraphAsync_WithSimpleClass_ShouldReturnCallGraph
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerTests.BuildCallGraphAsync_WithCancellationToken_ShouldRespectCancellation
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.BuildCallGraphAsync_WithNonExistentFiles_ShouldFallbackToFileAnalysis
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.BuildCallGraphAsync_WithMalformedSolutionFile_ShouldFallbackGracefully
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.BuildCallGraphAsync_WithCancellationDuringInitialization_ShouldThrowOperationCanceledException
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynAnalyzerErrorPathTests.BuildCallGraphAsync_WithMemoryPressure_ShouldHandleGracefully
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ RoslynCoreComponentTests.BuildCallGraphAsync_WithEmptyFiles_ShouldReturnEmptyCallGraph
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ SymbolIndexTests.BuildIndexAsync_WithValidSolution_ShouldIndexAllMethods
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ SymbolIndexTests.BuildIndexAsync_WithProjectFile_ShouldWork
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ TestSelectionEngineTests.ScoreTestsAsync_WithLargeTestSuite_ShouldHandlePerformantly
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ AnalyzeCommandE2ETests.Analyze_WithMissingRequiredArguments_ShowsHelp
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ CallGraphCommandE2ETests.CallGraph_WithMissingRequiredArguments_ShowsHelp
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ DiffCommandE2ETests.Diff_WithMissingRequiredArguments_ShowsHelp
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ FindTestsCommandE2ETests.FindTests_WithMissingRequiredArguments_ShowsHelp
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ QuickValidationE2ETests.CLI_Version_Command_Works
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ QuickValidationE2ETests.CLI_Help_Command_Works
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ QuickValidationE2ETests.CLI_InvalidCommand_ShowsError
++  Score: 0.500 | Category: UI | Duration: 0s
++  Tags: UI
++
++‚Ä¢ TestCoverageInfoTests.Constructor_WithValidParameters_CreatesInstance
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.Constructor_WithInvalidConfidence_ClampsToValidRange
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.Constructor_WithNullTestMethodId_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.Constructor_WithNullCallPath_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.CallDepth_WithVariousCallPaths_ReturnsCorrectDepth
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.IsDirectCoverage_WithVariousCallPaths_ReturnsCorrectValue
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.GetCallPathDisplay_WithMultipleSteps_ReturnsFormattedPath
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.ToString_ReturnsExpectedFormat
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.Equals_WithSameMethodIdAndCallPath_ReturnsTrue
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.Equals_WithDifferentMethodId_ReturnsFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageInfoTests.GetHashCode_WithSameMethodIdAndCallPath_ReturnsSameValue
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageMapTests.Constructor_WithValidParameters_CreatesInstance
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageMapTests.Constructor_WithNullMethodToTests_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageMapTests.Constructor_WithNullSolutionPath_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageMapTests.GetTestsForMethod_WithExistingMethod_ReturnsTests
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageMapTests.GetTestsForMethod_WithNonExistentMethod_ReturnsEmptyList
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageMapTests.GetCoveredMethods_WithMultipleMethods_ReturnsAllMethodIds
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageMapTests.CoveredMethodCount_ReturnsCorrectCount
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageMapTests.TotalCoverageRelationships_ReturnsCorrectCount
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageStatisticsTests.Constructor_WithValidParameters_CreatesInstance
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageStatisticsTests.CoveragePercentage_WithVariousValues_ReturnsCorrectPercentage
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageStatisticsTests.UncoveredMethods_WithVariousValues_ReturnsCorrectCount
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestCoverageStatisticsTests.Constructor_WithNullCoverageByTestType_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.Constructor_WithValidParameters_SetsProperties
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.Constructor_WithNullType_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.Constructor_WithNullAssemblyPath_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.GetUniqueId_ReturnsFullClassName
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.TestMethods_IsInitialized
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.FixtureAttributes_IsInitialized
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.HasSetUpMethods_WithNoSetupMethods_ReturnsFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.HasTearDownMethods_WithNoTearDownMethods_ReturnsFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.HasTests_WithNoTestMethods_ReturnsFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.GetExecutableTests_ReturnsExpectedCollection
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.GetSetUpMethods_ReturnsExpectedCollection
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.GetTearDownMethods_ReturnsExpectedCollection
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.GetCategories_ReturnsExpectedCollection
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestFixtureTests.ToString_ReturnsExpectedFormat
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.Constructor_WithValidParameters_SetsProperties
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.Constructor_WithNullMethodInfo_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.Constructor_WithNullDeclaringType_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.Constructor_WithNullAssemblyPath_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.GetUniqueId_ReturnsExpectedFormat
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.GetDisplayName_ReturnsExpectedFormat
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.IsExecutableTest_WithRegularMethod_ReturnsFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.TestAttributes_IsInitialized
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.ToString_ReturnsDisplayName
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ TestMethodTests.GetTestCaseParameters_WithRegularMethod_ReturnsEmpty
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NUnitTestDiscoveryTests.IsTestFixture_WithNullType_ReturnsFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NUnitTestDiscoveryTests.IsTestFixture_WithNonTestClass_ReturnsFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NUnitTestDiscoveryTests.IsTestMethod_WithNullMethod_ReturnsFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NUnitTestDiscoveryTests.IsTestMethod_WithRegularMethod_ReturnsFalse
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NUnitTestDiscoveryTests.DiscoverTestsAsync_WithNullAssembly_ThrowsArgumentNullException
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
++‚Ä¢ NUnitTestDiscoveryTests.DiscoverTestsAsync_WithValidAssembly_ReturnsResult
++  Score: 0.460 | Category: Unit | Duration: 0s
++  Tags: Unit
++
+diff --git a/src/TestIntelligence.CLI/Services/SelectionService.cs b/src/TestIntelligence.CLI/Services/SelectionService.cs
+index ee04395..8749eed 100644
+--- a/src/TestIntelligence.CLI/Services/SelectionService.cs
++++ b/src/TestIntelligence.CLI/Services/SelectionService.cs
+@@ -1,6 +1,8 @@
+ using Microsoft.Extensions.Logging;
++using Microsoft.Extensions.Logging.Abstractions;
+ using TestIntelligence.CLI.Models;
+ using TestIntelligence.ImpactAnalyzer.Models;
++using TestIntelligence.SelectionEngine.Engine;
+ using TestIntelligence.SelectionEngine.Interfaces;
+ using TestIntelligence.SelectionEngine.Models;
+ 
+@@ -12,16 +14,13 @@ namespace TestIntelligence.CLI.Services;
+ public class SelectionService : ISelectionService
+ {
+     private readonly ILogger<SelectionService> _logger;
+-    private readonly ITestSelectionEngine _selectionEngine;
+     private readonly IOutputFormatter _outputFormatter;
+ 
+     public SelectionService(
+         ILogger<SelectionService> logger,
+-        ITestSelectionEngine selectionEngine,
+         IOutputFormatter outputFormatter)
+     {
+         _logger = logger ?? throw new ArgumentNullException(nameof(logger));
+-        _selectionEngine = selectionEngine ?? throw new ArgumentNullException(nameof(selectionEngine));
+         _outputFormatter = outputFormatter ?? throw new ArgumentNullException(nameof(outputFormatter));
+     }
+ 
+@@ -35,17 +34,20 @@ public class SelectionService : ISelectionService
+ 
+             var confidenceLevel = ParseConfidenceLevel(confidence);
+             var options = CreateSelectionOptions(maxTests, maxTime);
++
++            // Create a TestSelectionEngine instance with the solution path
++            var selectionEngine = new TestSelectionEngine(_logger as ILogger<TestSelectionEngine> ?? NullLogger<TestSelectionEngine>.Instance, solutionPath: path);
+             
+             TestExecutionPlan executionPlan;
+ 
+             if (changes.Length > 0)
+             {
+                 var codeChangeSet = CreateCodeChangeSet(changes);
+-                executionPlan = await _selectionEngine.GetOptimalTestPlanAsync(codeChangeSet, confidenceLevel);
++                executionPlan = await selectionEngine.GetOptimalTestPlanAsync(codeChangeSet, confidenceLevel);
+             }
+             else
+             {
+-                executionPlan = await _selectionEngine.GetTestPlanAsync(confidenceLevel, options);
++                executionPlan = await selectionEngine.GetTestPlanAsync(confidenceLevel, options);
+             }
+ 
+             var selectionResult = ConvertToSelectionResult(executionPlan, path, changes, confidence);
+diff --git a/src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs b/src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
+index 8c033b7..b469c5f 100644
+--- a/src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
++++ b/src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
+@@ -249,5 +249,14 @@ namespace TestIntelligence.Core.Discovery
+         {
+             DiscoveryError?.Invoke(this, new TestDiscoveryErrorEventArgs(assemblyPath, exception));
+         }
++        
++        /// <summary>
++        /// Test method to validate coverage analysis functionality.
++        /// </summary>
++        public virtual bool ValidateTestMethod(MethodInfo method)
++        {
++            return IsTestMethod(method);
++        }
+     }
+-}
+\ No newline at end of file
++}        // Test fix for select command - artificial modification
++// Test change for coverage analysis
+diff --git a/src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs.backup b/src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs.backup
+new file mode 100644
+index 0000000..188cf78
+--- /dev/null
++++ b/src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs.backup
+@@ -0,0 +1,261 @@
++using System;
++using System.Collections.Concurrent;
++using System.Collections.Generic;
++using System.Linq;
++using System.Reflection;
++using System.Threading;
++using System.Threading.Tasks;
++using TestIntelligence.Core.Assembly;
++using TestIntelligence.Core.Models;
++
++namespace TestIntelligence.Core.Discovery
++{
++    /// <summary>
++    /// NUnit-specific test discovery implementation that identifies test fixtures and methods.
++    /// </summary>
++    public class NUnitTestDiscovery : ITestDiscovery
++    {
++        private static readonly HashSet<string> TestFixtureAttributeNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
++        {
++            "TestFixtureAttribute",
++            "NUnit.Framework.TestFixtureAttribute",
++            "TestClassAttribute",
++            "Microsoft.VisualStudio.TestTools.UnitTesting.TestClassAttribute"
++        };
++
++        private static readonly HashSet<string> TestMethodAttributeNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
++        {
++            "TestAttribute",
++            "TestCaseAttribute", 
++            "NUnit.Framework.TestAttribute",
++            "NUnit.Framework.TestCaseAttribute",
++            "FactAttribute",
++            "TheoryAttribute",
++            "Xunit.FactAttribute",
++            "Xunit.TheoryAttribute"
++        };
++
++        private static readonly HashSet<string> SetupAttributeNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
++        {
++            "SetUpAttribute",
++            "OneTimeSetUpAttribute",
++            "TearDownAttribute", 
++            "OneTimeTearDownAttribute",
++            "NUnit.Framework.SetUpAttribute",
++            "NUnit.Framework.OneTimeSetUpAttribute",
++            "NUnit.Framework.TearDownAttribute",
++            "NUnit.Framework.OneTimeTearDownAttribute"
++        };
++
++        /// <inheritdoc />
++        public event EventHandler<TestDiscoveryStartedEventArgs>? DiscoveryStarted;
++
++        /// <inheritdoc />
++        public event EventHandler<TestDiscoveryCompletedEventArgs>? DiscoveryCompleted;
++
++        /// <inheritdoc />
++        public event EventHandler<TestDiscoveryErrorEventArgs>? DiscoveryError;
++
++        /// <inheritdoc />
++        public async Task<TestDiscoveryResult> DiscoverTestsAsync(ITestAssembly testAssembly, CancellationToken cancellationToken = default)
++        {
++            if (testAssembly == null)
++                throw new ArgumentNullException(nameof(testAssembly));
++
++            var assemblyPath = testAssembly.AssemblyPath;
++            var errors = new List<string>();
++
++            try
++            {
++                OnDiscoveryStarted(assemblyPath);
++
++                var testFixtures = await Task.Run(() => DiscoverTestFixturesInAssembly(testAssembly, errors), cancellationToken)
++                    .ConfigureAwait(false);
++
++                var result = new TestDiscoveryResult(
++                    assemblyPath,
++                    testAssembly.FrameworkVersion,
++                    testFixtures,
++                    errors);
++
++                OnDiscoveryCompleted(assemblyPath, result);
++                return result;
++            }
++            catch (Exception ex)
++            {
++                errors.Add($"Fatal error during discovery: {ex.Message}");
++                OnDiscoveryError(assemblyPath, ex);
++                
++                return new TestDiscoveryResult(
++                    assemblyPath,
++                    testAssembly.FrameworkVersion,
++                    Array.Empty<TestFixture>(),
++                    errors);
++            }
++        }
++
++        /// <inheritdoc />
++        public async Task<IReadOnlyDictionary<string, TestDiscoveryResult>> DiscoverTestsAsync(
++            IEnumerable<ITestAssembly> testAssemblies, 
++            CancellationToken cancellationToken = default)
++        {
++            if (testAssemblies == null)
++                throw new ArgumentNullException(nameof(testAssemblies));
++
++            var assemblies = testAssemblies.ToList();
++            var results = new ConcurrentDictionary<string, TestDiscoveryResult>();
++
++            // Process assemblies in parallel for better performance
++            var tasks = assemblies.Select(async assembly =>
++            {
++                var result = await DiscoverTestsAsync(assembly, cancellationToken).ConfigureAwait(false);
++                results.TryAdd(assembly.AssemblyPath, result);
++            });
++
++            await Task.WhenAll(tasks).ConfigureAwait(false);
++            return results;
++        }
++
++        /// <inheritdoc />
++        public bool IsTestFixture(Type type)
++        {
++            if (type == null)
++                return false;
++
++            // Check for explicit TestFixture attribute
++            var hasTestFixtureAttribute = type.GetCustomAttributes(inherit: false)
++                .Any(attr => TestFixtureAttributeNames.Contains(attr.GetType().Name) ||
++                           TestFixtureAttributeNames.Contains(attr.GetType().FullName ?? ""));
++
++            if (hasTestFixtureAttribute)
++                return true;
++
++            // Check for test methods (NUnit allows fixtures without explicit [TestFixture] if they have test methods)
++            var methods = type.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static);
++            return methods.Any(IsTestMethod);
++        }
++
++        /// <inheritdoc />
++        public bool IsTestMethod(MethodInfo method)
++        {
++            if (method == null)
++                return false;
++
++            // Added enhanced attribute checking for test coverage analysis
++            var attributes = method.GetCustomAttributes(inherit: false);
++            var isTestMethod = attributes.Any(attr => 
++                TestMethodAttributeNames.Contains(attr.GetType().Name) ||
++                TestMethodAttributeNames.Contains(attr.GetType().FullName ?? "") ||
++                SetupAttributeNames.Contains(attr.GetType().Name) ||
++                SetupAttributeNames.Contains(attr.GetType().FullName ?? ""));
++                
++            return isTestMethod;
++        }
++
++        /// <summary>
++        /// Discovers all test fixtures in the given assembly.
++        /// </summary>
++        private IReadOnlyList<TestFixture> DiscoverTestFixturesInAssembly(ITestAssembly testAssembly, List<string> errors)
++        {
++            var fixtures = new List<TestFixture>();
++
++            try
++            {
++                var assembly = testAssembly.UnderlyingAssembly;
++                var types = GetTypesFromAssembly(assembly, errors);
++
++                foreach (var type in types)
++                {
++                    try
++                    {
++                        if (IsTestFixture(type))
++                        {
++                            var fixture = new TestFixture(type, testAssembly.AssemblyPath, testAssembly.FrameworkVersion);
++                            
++                            // Only include fixtures that actually have tests
++                            if (fixture.HasTests || fixture.HasSetUpMethods || fixture.HasTearDownMethods)
++                            {
++                                fixtures.Add(fixture);
++                            }
++                        }
++                    }
++                    catch (Exception ex)
++                    {
++                        errors.Add($"Error processing type '{type.FullName}': {ex.Message}");
++                    }
++                }
++            }
++            catch (Exception ex)
++            {
++                errors.Add($"Error discovering fixtures in assembly: {ex.Message}");
++            }
++
++            return fixtures.AsReadOnly();
++        }
++
++        /// <summary>
++        /// Safely gets all types from an assembly, handling ReflectionTypeLoadException.
++        /// </summary>
++        private IEnumerable<Type> GetTypesFromAssembly(System.Reflection.Assembly assembly, List<string> errors)
++        {
++            try
++            {
++                return assembly.GetTypes();
++            }
++            catch (ReflectionTypeLoadException ex)
++            {
++                // Log loader exceptions but continue with successfully loaded types
++                if (ex.LoaderExceptions != null)
++                {
++                    foreach (var loaderException in ex.LoaderExceptions)
++                    {
++                        if (loaderException != null)
++                        {
++                            errors.Add($"Type load error: {loaderException.Message}");
++                        }
++                    }
++                }
++
++                // Return the types that did load successfully
++                return ex.Types.Where(t => t != null)!;
++            }
++            catch (Exception ex)
++            {
++                errors.Add($"Error getting types from assembly: {ex.Message}");
++                return Enumerable.Empty<Type>();
++            }
++        }
++
++        /// <summary>
++        /// Raises the DiscoveryStarted event.
++        /// </summary>
++        protected virtual void OnDiscoveryStarted(string assemblyPath)
++        {
++            DiscoveryStarted?.Invoke(this, new TestDiscoveryStartedEventArgs(assemblyPath));
++        }
++
++        /// <summary>
++        /// Raises the DiscoveryCompleted event.
++        /// </summary>
++        protected virtual void OnDiscoveryCompleted(string assemblyPath, TestDiscoveryResult result)
++        {
++            DiscoveryCompleted?.Invoke(this, new TestDiscoveryCompletedEventArgs(assemblyPath, result));
++        }
++
++        /// <summary>
++        /// Raises the DiscoveryError event.
++        /// </summary>
++        protected virtual void OnDiscoveryError(string assemblyPath, Exception exception)
++        {
++            DiscoveryError?.Invoke(this, new TestDiscoveryErrorEventArgs(assemblyPath, exception));
++        }
++        
++        /// <summary>
++        /// Test method to validate coverage analysis functionality.
++        /// </summary>
++        public virtual bool ValidateTestMethod(MethodInfo method)
++        {
++            return IsTestMethod(method);
++        }
++    }
++}
+\ No newline at end of file
+diff --git a/src/TestIntelligence.DataTracker/TestDataDependencyTracker.cs b/src/TestIntelligence.DataTracker/TestDataDependencyTracker.cs
+index 9d88644..f7cf6a1 100644
+--- a/src/TestIntelligence.DataTracker/TestDataDependencyTracker.cs
++++ b/src/TestIntelligence.DataTracker/TestDataDependencyTracker.cs
+@@ -412,5 +412,10 @@ namespace TestIntelligence.DataTracker
+ 
+         public int TotalTestPairs => CanRunInParallel.Count + MustRunSequentially.Count;
+         public double ParallelExecutionRatio => TotalTestPairs > 0 ? (double)CanRunInParallel.Count / TotalTestPairs : 0;
++        
++        /// <summary>
++        /// Test method to validate coverage analysis functionality.
++        /// </summary>
++        public bool HasConflicts() => MustRunSequentially.Count > 0;
+     }
+ }
+\ No newline at end of file
+diff --git a/src/TestIntelligence.ImpactAnalyzer/Analysis/RoslynAnalyzer.cs b/src/TestIntelligence.ImpactAnalyzer/Analysis/RoslynAnalyzer.cs
+index 9a182a8..85667de 100644
+--- a/src/TestIntelligence.ImpactAnalyzer/Analysis/RoslynAnalyzer.cs
++++ b/src/TestIntelligence.ImpactAnalyzer/Analysis/RoslynAnalyzer.cs
+@@ -1139,4 +1139,4 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
+             _callGraphBuilder = null;
+         }
+     }
+-}
+\ No newline at end of file
++}// Test change for coverage analysis
+diff --git a/src/TestIntelligence.SelectionEngine/Engine/TestSelectionEngine.cs b/src/TestIntelligence.SelectionEngine/Engine/TestSelectionEngine.cs
+index 7347f64..af7da18 100644
+--- a/src/TestIntelligence.SelectionEngine/Engine/TestSelectionEngine.cs
++++ b/src/TestIntelligence.SelectionEngine/Engine/TestSelectionEngine.cs
+@@ -1,9 +1,12 @@
+ using System;
+ using System.Collections.Generic;
++using System.IO;
+ using System.Linq;
+ using System.Threading;
+ using System.Threading.Tasks;
+ using Microsoft.Extensions.Logging;
++using TestIntelligence.Core.Assembly;
++using TestIntelligence.Core.Discovery;
+ using TestIntelligence.ImpactAnalyzer.Models;
+ using TestIntelligence.SelectionEngine.Interfaces;
+ using TestIntelligence.SelectionEngine.Models;
+@@ -20,6 +23,7 @@ namespace TestIntelligence.SelectionEngine.Engine
+         private readonly List<ITestScoringAlgorithm> _scoringAlgorithms;
+         private readonly ITestCategorizer? _testCategorizer;
+         private readonly IImpactAnalyzer? _impactAnalyzer;
++        private readonly string? _solutionPath;
+ 
+         // In-memory storage for demonstration - in production this would be a database
+         private readonly Dictionary<string, TestInfo> _testRepository;
+@@ -29,11 +33,13 @@ namespace TestIntelligence.SelectionEngine.Engine
+             ILogger<TestSelectionEngine> logger,
+             IEnumerable<ITestScoringAlgorithm>? scoringAlgorithms = null,
+             ITestCategorizer? testCategorizer = null,
+-            IImpactAnalyzer? impactAnalyzer = null)
++            IImpactAnalyzer? impactAnalyzer = null,
++            string? solutionPath = null)
+         {
+             _logger = logger ?? throw new ArgumentNullException(nameof(logger));
+             _testCategorizer = testCategorizer;
+             _impactAnalyzer = impactAnalyzer;
++            _solutionPath = solutionPath;
+             _testRepository = new Dictionary<string, TestInfo>();
+             _executionHistory = new List<TestExecutionResult>();
+ 
+@@ -198,12 +204,33 @@ namespace TestIntelligence.SelectionEngine.Engine
+             TestSelectionOptions options,
+             CancellationToken cancellationToken)
+         {
+-            // In production, this would query a test repository/database
+-            // For now, return mock tests for demonstration
+             var candidates = new List<TestInfo>();
+ 
+-            // This is a simplified mock - in production, we'd have a proper test discovery service
+-            await Task.CompletedTask;
++            try
++            {
++                // If we have a solution path, discover tests from it
++                if (!string.IsNullOrEmpty(_solutionPath))
++                {
++                    candidates = await DiscoverTestsFromSolution(_solutionPath, cancellationToken);
++                }
++                // If we don't have a solution path but have changes, try to infer from the first change path
++                else if (changes?.Changes.Count > 0)
++                {
++                    var firstChangePath = changes.Changes.First().FilePath;
++                    var solutionPath = FindSolutionFile(firstChangePath);
++                    if (!string.IsNullOrEmpty(solutionPath))
++                    {
++                        _logger.LogInformation("Inferred solution path from changes: {SolutionPath}", solutionPath);
++                        candidates = await DiscoverTestsFromSolution(solutionPath, cancellationToken);
++                    }
++                }
++
++                _logger.LogInformation("Discovered {CandidateCount} candidate tests", candidates.Count);
++            }
++            catch (Exception ex)
++            {
++                _logger.LogWarning(ex, "Error discovering candidate tests");
++            }
+ 
+             return candidates;
+         }
+@@ -313,6 +340,241 @@ namespace TestIntelligence.SelectionEngine.Engine
+                 _ => 0.3
+             };
+         }
++
++        private async Task<List<TestInfo>> DiscoverTestsFromSolution(string solutionPath, CancellationToken cancellationToken)
++        {
++            var testInfos = new List<TestInfo>();
++
++            try
++            {
++                // Find test assemblies in the solution
++                var assemblyPaths = await FindTestAssembliesInSolution(solutionPath);
++                
++                _logger.LogInformation("Found {AssemblyCount} test assemblies in solution", assemblyPaths.Count);
++                foreach (var path in assemblyPaths)
++                {
++                    _logger.LogInformation("  Test assembly: {Assembly}", path);
++                }
++
++                // Use shared loader for efficiency
++                using var loader = new CrossFrameworkAssemblyLoader();
++                var discovery = TestDiscoveryFactory.CreateNUnitTestDiscovery();
++
++                foreach (var assemblyPath in assemblyPaths)
++                {
++                    try
++                    {
++                        var loadResult = await loader.LoadAssemblyAsync(assemblyPath);
++                        if (!loadResult.IsSuccess || loadResult.Assembly == null)
++                        {
++                            _logger.LogWarning("Failed to load assembly: {Assembly} - {Errors}", 
++                                assemblyPath, string.Join(", ", loadResult.Errors));
++                            continue;
++                        }
++
++                        var discoveryResult = await discovery.DiscoverTestsAsync(loadResult.Assembly, cancellationToken);
++                        
++                        // Convert discovered tests to TestInfo objects
++                        foreach (var testMethod in discoveryResult.GetAllTestMethods())
++                        {
++                            var testInfo = ConvertToTestInfo(testMethod);
++                            testInfos.Add(testInfo);
++                        }
++
++                        _logger.LogDebug("Discovered {TestCount} tests from {Assembly}", 
++                            discoveryResult.TestMethodCount, Path.GetFileName(assemblyPath));
++                    }
++                    catch (Exception ex)
++                    {
++                        _logger.LogWarning(ex, "Error discovering tests from assembly: {Assembly}", assemblyPath);
++                    }
++                }
++            }
++            catch (Exception ex)
++            {
++                _logger.LogError(ex, "Error discovering tests from solution: {Solution}", solutionPath);
++            }
++
++            return testInfos;
++        }
++
++        private async Task<List<string>> FindTestAssembliesInSolution(string solutionPath)
++        {
++            var assemblies = new List<string>();
++
++            try
++            {
++                var solutionDir = Path.GetDirectoryName(solutionPath)!;
++                var projectPaths = await FindTestProjectsInSolution(solutionPath);
++                
++                _logger.LogInformation("Found {ProjectCount} test projects", projectPaths.Count);
++
++                foreach (var projectPath in projectPaths)
++                {
++                    var assemblyPath = GetAssemblyPathFromProject(projectPath);
++                    _logger.LogDebug("Checking assembly path: {Assembly} (exists: {Exists})", assemblyPath, File.Exists(assemblyPath));
++                    if (File.Exists(assemblyPath))
++                    {
++                        assemblies.Add(assemblyPath);
++                    }
++                }
++            }
++            catch (Exception ex)
++            {
++                _logger.LogWarning(ex, "Error finding test assemblies in solution: {Solution}", solutionPath);
++            }
++
++            return assemblies;
++        }
++
++        private async Task<List<string>> FindTestProjectsInSolution(string solutionPath)
++        {
++            var testProjects = new List<string>();
++
++            try
++            {
++                var solutionContent = await File.ReadAllTextAsync(solutionPath);
++                var solutionDir = Path.GetDirectoryName(solutionPath)!;
++
++                // Parse solution file properly
++                // Format: Project("{GUID}") = "ProjectName", "RelativePath", "{ProjectGUID}"
++                var lines = solutionContent.Split('\n');
++                foreach (var line in lines)
++                {
++                    if (line.StartsWith("Project(") && line.Contains(".csproj"))
++                    {
++                        // Extract project path from solution line
++                        var parts = line.Split(',');
++                        if (parts.Length >= 2)
++                        {
++                            var relativePath = parts[1].Trim().Trim('"');
++                            
++                            // Only include test projects (in tests directory or with "Test" in path/name)
++                            if (relativePath.Contains("test", StringComparison.OrdinalIgnoreCase) || 
++                                relativePath.StartsWith("tests", StringComparison.OrdinalIgnoreCase))
++                            {
++                                var fullPath = Path.Combine(solutionDir, relativePath).Replace('\\', Path.DirectorySeparatorChar);
++                                if (File.Exists(fullPath))
++                                {
++                                    testProjects.Add(fullPath);
++                                    _logger.LogDebug("Found test project: {Project}", fullPath);
++                                }
++                            }
++                        }
++                    }
++                }
++            }
++            catch (Exception ex)
++            {
++                _logger.LogWarning(ex, "Error parsing solution file: {Solution}", solutionPath);
++            }
++
++            return testProjects;
++        }
++
++        private string GetAssemblyPathFromProject(string projectPath)
++        {
++            var projectDir = Path.GetDirectoryName(projectPath)!;
++            var projectName = Path.GetFileNameWithoutExtension(projectPath);
++            
++            // Try common output paths
++            var possiblePaths = new[]
++            {
++                Path.Combine(projectDir, "bin", "Debug", "net8.0", $"{projectName}.dll"),
++                Path.Combine(projectDir, "bin", "Release", "net8.0", $"{projectName}.dll"),
++                Path.Combine(projectDir, "bin", "Debug", $"{projectName}.dll"),
++                Path.Combine(projectDir, "bin", "Release", $"{projectName}.dll")
++            };
++
++            foreach (var path in possiblePaths)
++            {
++                if (File.Exists(path))
++                {
++                    return path;
++                }
++            }
++
++            // Default to Debug net8.0 path even if it doesn't exist yet
++            return Path.Combine(projectDir, "bin", "Debug", "net8.0", $"{projectName}.dll");
++        }
++
++        private TestInfo ConvertToTestInfo(Core.Models.TestMethod testMethod)
++        {
++            var category = CategorizeTest(testMethod);
++            var averageTime = TimeSpan.FromMilliseconds(100); // Default estimate
++            
++            var testInfo = new TestInfo(testMethod, category, averageTime);
++
++            // Add tags to the test info
++            var tags = ExtractTestTags(testMethod);
++            foreach (var tag in tags)
++            {
++                testInfo.Tags.Add(tag);
++            }
++
++            return testInfo;
++        }
++
++        private TestCategory CategorizeTest(Core.Models.TestMethod testMethod)
++        {
++            var methodName = testMethod.MethodInfo.Name.ToLower();
++            var className = testMethod.MethodInfo.DeclaringType?.Name.ToLower() ?? "";
++
++            if (methodName.Contains("database") || methodName.Contains("db") || 
++                className.Contains("database") || className.Contains("db"))
++                return TestCategory.Database;
++
++            if (methodName.Contains("api") || methodName.Contains("http") ||
++                className.Contains("api") || className.Contains("http"))
++                return TestCategory.API;
++
++            if (methodName.Contains("integration") || className.Contains("integration"))
++                return TestCategory.Integration;
++
++            if (methodName.Contains("ui") || methodName.Contains("selenium") ||
++                className.Contains("ui") || className.Contains("selenium"))
++                return TestCategory.UI;
++
++            return TestCategory.Unit;
++        }
++
++        private List<string> ExtractTestTags(Core.Models.TestMethod testMethod)
++        {
++            var tags = new List<string>();
++            
++            // Add category as a tag
++            var category = CategorizeTest(testMethod);
++            tags.Add(category.ToString());
++
++            // You could add more sophisticated tag extraction from attributes here
++            
++            return tags;
++        }
++
++        private string? FindSolutionFile(string filePath)
++        {
++            try
++            {
++                var directory = Path.GetDirectoryName(Path.GetFullPath(filePath));
++                
++                while (directory != null)
++                {
++                    var solutionFiles = Directory.GetFiles(directory, "*.sln");
++                    if (solutionFiles.Length > 0)
++                    {
++                        return solutionFiles.First(); // Return the first solution file found
++                    }
++                    
++                    directory = Path.GetDirectoryName(directory);
++                }
++            }
++            catch (Exception ex)
++            {
++                _logger.LogWarning(ex, "Error finding solution file for path: {FilePath}", filePath);
++            }
++
++            return null;
++        }
+     }
+ 
+     /// <summary>
+diff --git a/test-changes-v2.patch b/test-changes-v2.patch
+new file mode 100644
+index 0000000..5d4297b
+--- /dev/null
++++ b/test-changes-v2.patch
+@@ -0,0 +1,2181 @@
++diff --git a/src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs b/src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
++index 8c033b7..188cf78 100644
++--- a/src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
+++++ b/src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
++@@ -249,5 +249,13 @@ namespace TestIntelligence.Core.Discovery
++         {
++             DiscoveryError?.Invoke(this, new TestDiscoveryErrorEventArgs(assemblyPath, exception));
 +         }
-+ 
+++        
 ++        /// <summary>
-++        /// Prints usage hint for the current command.
+++        /// Test method to validate coverage analysis functionality.
 ++        /// </summary>
-++        protected virtual void PrintUsageHint(CommandContext context)
-++        {
-++            Console.Error.WriteLine("üí° Use --help to see available options and usage examples.");
-++        }
-++
-+         /// <summary>
-+         /// Executes the command-specific logic. Override this in derived classes.
-+         /// </summary>
-+diff --git a/src/TestIntelligence.CLI/Commands/FindTestsCommandHandler.cs b/src/TestIntelligence.CLI/Commands/FindTestsCommandHandler.cs
-+index 615231e..3ba1564 100644
-+--- a/src/TestIntelligence.CLI/Commands/FindTestsCommandHandler.cs
-++++ b/src/TestIntelligence.CLI/Commands/FindTestsCommandHandler.cs
-+@@ -1,4 +1,5 @@
-+ using System;
-++using System.Collections.Generic;
-+ using System.IO;
-+ using System.Linq;
-+ using System.Text;
-+@@ -7,6 +8,7 @@ using System.Threading.Tasks;
-+ using Microsoft.Extensions.Logging;
-+ using TestIntelligence.CLI.Services;
-+ using TestIntelligence.Core.Services;
-++using TestIntelligence.Core.Models;
-+ 
-+ namespace TestIntelligence.CLI.Commands;
-+ 
-+@@ -32,27 +34,61 @@ public class FindTestsCommandHandler : BaseCommandHandler
-+         var format = context.GetParameter<string>("format") ?? "text";
-+         var verbose = context.GetParameter<bool>("verbose");
-+ 
-++        // Additional validation
-++        ValidateInputs(method!, solution!, output, format);
-++
-+         Logger.LogInformation("Finding tests that exercise method: {Method} in solution: {Solution}", method, solution);
-+         
-+         // Get services from DI
-+         var testCoverageAnalyzer = context.GetService<ITestCoverageAnalyzer>();
-+         var outputFormatter = context.GetService<IOutputFormatter>();
-+         
-++        if (testCoverageAnalyzer == null)
-++        {
-++            throw new InvalidOperationException("Test coverage analyzer service is not available. Please check the application configuration.");
-++        }
-++        
-++        if (outputFormatter == null)
+++        public virtual bool ValidateTestMethod(MethodInfo method)
 ++        {
-++            throw new InvalidOperationException("Output formatter service is not available. Please check the application configuration.");
-++        }
-++        
-+         Console.WriteLine($"Finding tests that exercise method: {method}");
-+         Console.WriteLine($"Solution path: {solution}");
-+         Console.WriteLine();
-+ 
-+-        var tests = await testCoverageAnalyzer.FindTestsExercisingMethodAsync(method!, solution!);
-+-        
-+-        if (!tests.Any())
-++        IReadOnlyList<TestCoverageInfo> tests;
-++        try
-+         {
-+-            Console.WriteLine("No tests found that exercise this method.");
-++            tests = await testCoverageAnalyzer.FindTestsExercisingMethodAsync(method!, solution!, cancellationToken);
-++            
-++            if (tests == null || !tests.Any())
-++            {
-++                Console.WriteLine("No tests found that exercise this method.");
-++                Console.WriteLine();
-++                Console.WriteLine("üí° This could mean:");
-++                Console.WriteLine("   ‚Ä¢ The method name/signature is incorrect");
-++                Console.WriteLine("   ‚Ä¢ No tests actually exercise this method");
-++                Console.WriteLine("   ‚Ä¢ The method is not public or accessible");
-++                Console.WriteLine("   ‚Ä¢ There are compilation errors preventing analysis");
-++                return 0;
-++            }
-++
-++            Console.WriteLine($"Found {tests.Count} test(s) exercising this method:");
-++            Console.WriteLine();
+++            return IsTestMethod(method);
 ++        }
-++        catch (ArgumentException)
-++        {
-++            // Re-throw argument exceptions to be handled by base class
-++            throw;
-++        }
-++        catch (Exception ex) when (ex.Message.Contains("No test methods found"))
-++        {
-++            Console.WriteLine("No test methods found in the solution.");
-++            Console.WriteLine("üí° Make sure the solution builds successfully and contains test projects.");
-+             return 0;
-+         }
-+ 
-+-        Console.WriteLine($"Found {tests.Count} test(s) exercising this method:");
-+-        Console.WriteLine();
-+-
-+         if (format == "json")
-+         {
-+             var json = outputFormatter.FormatAsJson(tests);
-+@@ -100,4 +136,45 @@ public class FindTestsCommandHandler : BaseCommandHandler
-+         
-+         return 0;
 +     }
-++
-++    /// <summary>
-++    /// Validates the input parameters for the find-tests command.
-++    /// </summary>
-++    private void ValidateInputs(string method, string solution, string? output, string format)
-++    {
-++        // Validate solution file exists
-++        if (!File.Exists(solution))
-++        {
-++            throw new FileNotFoundException($"Solution file not found: {solution}");
-++        }
-++
-++        // Validate method format (basic validation)
-++        if (!method.Contains('.'))
-++        {
-++            throw new ArgumentException($"Method parameter should be in format 'Namespace.Class.Method', got: {method}");
-++        }
-++
-++        // Validate output format
-++        if (!string.Equals(format, "json", StringComparison.OrdinalIgnoreCase) && 
-++            !string.Equals(format, "text", StringComparison.OrdinalIgnoreCase))
-++        {
-++            throw new ArgumentException($"Format must be 'json' or 'text', got: {format}");
-++        }
-++
-++        // Validate output path if provided
-++        if (!string.IsNullOrWhiteSpace(output))
-++        {
-++            var outputDir = Path.GetDirectoryName(Path.GetFullPath(output));
-++            if (!string.IsNullOrEmpty(outputDir) && !Directory.Exists(outputDir))
-++            {
-++                throw new DirectoryNotFoundException($"Output directory does not exist: {outputDir}");
-++            }
-++        }
-++    }
-++
-++    protected override void PrintUsageHint(CommandContext context)
-++    {
-++        Console.Error.WriteLine("üí° Usage: find-tests --method \"Namespace.Class.Method\" --solution \"path/to/solution.sln\"");
-++        Console.Error.WriteLine("   Example: find-tests --method \"MyApp.Services.UserService.GetUser\" --solution \"MyApp.sln\"");
-++    }
 + }
 +\ No newline at end of file
-+diff --git a/src/TestIntelligence.CLI/TestIntelligence.CLI.csproj b/src/TestIntelligence.CLI/TestIntelligence.CLI.csproj
-+index c25bbd3..259c88d 100644
-+--- a/src/TestIntelligence.CLI/TestIntelligence.CLI.csproj
-++++ b/src/TestIntelligence.CLI/TestIntelligence.CLI.csproj
-+@@ -27,6 +27,8 @@
-+     <PackageReference Include="Microsoft.Extensions.Logging" Version="8.0.0" />
-+     <PackageReference Include="Microsoft.Extensions.Logging.Console" Version="8.0.0" />
-+     <PackageReference Include="Microsoft.Build.Locator" Version="1.6.10" />
-++    <!-- Explicit reference to resolve conflicts -->
-++    <PackageReference Include="Microsoft.Bcl.AsyncInterfaces" Version="8.0.0" />
-+   </ItemGroup>
-+ 
-+   <ItemGroup>
-+diff --git a/src/TestIntelligence.Core/Models/TestCoverageInfo.cs b/src/TestIntelligence.Core/Models/TestCoverageInfo.cs
-+index a7b865a..0f50511 100644
-+--- a/src/TestIntelligence.Core/Models/TestCoverageInfo.cs
-++++ b/src/TestIntelligence.Core/Models/TestCoverageInfo.cs
-+@@ -192,10 +192,15 @@ namespace TestIntelligence.Core.Models
-+             if (fullMethodId.Equals(pattern, StringComparison.OrdinalIgnoreCase))
-+                 return true;
-+ 
-+-            // Extract method name without parameters from full ID
-++            // Remove global:: prefix if present for comparison
-++            var normalizedMethodId = fullMethodId.StartsWith("global::", StringComparison.OrdinalIgnoreCase) 
-++                ? fullMethodId.Substring(8) // Remove "global::" prefix
-++                : fullMethodId;
-++
-++            // Extract method name without parameters from normalized ID
-+             // Format: Namespace.Class.Method(params)
-+-            var parenIndex = fullMethodId.IndexOf('(');
-+-            var methodWithoutParams = parenIndex > 0 ? fullMethodId.Substring(0, parenIndex) : fullMethodId;
-++            var parenIndex = normalizedMethodId.IndexOf('(');
-++            var methodWithoutParams = parenIndex > 0 ? normalizedMethodId.Substring(0, parenIndex) : normalizedMethodId;
-+ 
-+             // Check if pattern matches the method without parameters
-+             if (methodWithoutParams.Equals(pattern, StringComparison.OrdinalIgnoreCase))
-+diff --git a/src/TestIntelligence.Core/TestIntelligence.Core.csproj b/src/TestIntelligence.Core/TestIntelligence.Core.csproj
-+index 1cbbd22..3c05933 100644
-+--- a/src/TestIntelligence.Core/TestIntelligence.Core.csproj
-++++ b/src/TestIntelligence.Core/TestIntelligence.Core.csproj
-+@@ -23,7 +23,7 @@
-+     <PackageReference Include="System.Reflection.Metadata" Version="8.0.0" />
-+     <PackageReference Include="System.Runtime.Loader" Version="4.3.0" />
-+     <PackageReference Include="System.Reflection.MetadataLoadContext" Version="8.0.0" />
-+-    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="6.0.4" />
-++    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="8.0.0" />
-+     <PackageReference Include="System.Text.Json" Version="8.0.5" />
-+   </ItemGroup>
-+ 
-+diff --git a/src/TestIntelligence.DataTracker/TestIntelligence.DataTracker.csproj b/src/TestIntelligence.DataTracker/TestIntelligence.DataTracker.csproj
-+index 5440411..dfbdb37 100644
-+--- a/src/TestIntelligence.DataTracker/TestIntelligence.DataTracker.csproj
-++++ b/src/TestIntelligence.DataTracker/TestIntelligence.DataTracker.csproj
-+@@ -19,7 +19,7 @@
-+   </PropertyGroup>
-+ 
-+   <ItemGroup>
-+-    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="6.0.4" />
-++    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="8.0.0" />
-+     <!-- Entity Framework packages for database pattern detection -->
-+     <PackageReference Include="Microsoft.EntityFrameworkCore" Version="3.1.32" />
-+     <PackageReference Include="EntityFramework" Version="6.4.4" />
-+diff --git a/src/TestIntelligence.ImpactAnalyzer/Analysis/LazyWorkspaceBuilder.cs b/src/TestIntelligence.ImpactAnalyzer/Analysis/LazyWorkspaceBuilder.cs
-+index d91c774..40a3d3c 100644
-+--- a/src/TestIntelligence.ImpactAnalyzer/Analysis/LazyWorkspaceBuilder.cs
-++++ b/src/TestIntelligence.ImpactAnalyzer/Analysis/LazyWorkspaceBuilder.cs
-+@@ -138,23 +138,50 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
-+         {
-+             return await _projectCache.GetOrAdd(projectPath, async path =>
-+             {
-++                CancellationTokenSource? timeoutCts = null;
-++                CancellationTokenSource? combinedCts = null;
-++                
-+                 try
-+                 {
-+                     _logger.LogDebug("Loading project on-demand: {ProjectPath}", path);
-+                     var startTime = DateTime.UtcNow;
-+ 
-+-                    var project = await _workspace.OpenProjectAsync(path);
-++                    // Add timeout to prevent hanging on project loading
-++                    timeoutCts = new CancellationTokenSource(TimeSpan.FromSeconds(15));
-++                    combinedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, timeoutCts.Token);
-++
-++                    var projectTask = _workspace.OpenProjectAsync(path);
-++                    var timeoutTask = Task.Delay(TimeSpan.FromSeconds(15), combinedCts.Token);
-++                    
-++                    var completedTask = await Task.WhenAny(projectTask, timeoutTask);
-++                    if (completedTask == timeoutTask)
-++                    {
-++                        _logger.LogWarning("Project loading timed out after 15 seconds: {ProjectPath}", path);
-++                        return null;
-++                    }
-++                    
-++                    var project = await projectTask;
-+                     
-+                     var elapsed = DateTime.UtcNow - startTime;
-+                     _logger.LogDebug("Project loaded in {ElapsedMs}ms: {ProjectName}", elapsed.TotalMilliseconds, project.Name);
-+ 
-+                     return project;
-+                 }
-++                catch (OperationCanceledException) when (timeoutCts?.Token.IsCancellationRequested == true)
-++                {
-++                    _logger.LogWarning("Project loading timed out after 15 seconds: {ProjectPath}", path);
-++                    return null;
-++                }
-+                 catch (Exception ex)
-+                 {
-+                     _logger.LogError(ex, "Failed to load project: {ProjectPath}", path);
-+                     return null;
-+                 }
-++                finally
-++                {
-++                    timeoutCts?.Dispose();
-++                    combinedCts?.Dispose();
-++                }
-+             });
-+         }
++diff --git a/src/TestIntelligence.DataTracker/TestDataDependencyTracker.cs b/src/TestIntelligence.DataTracker/TestDataDependencyTracker.cs
++index 9d88644..f7cf6a1 100644
++--- a/src/TestIntelligence.DataTracker/TestDataDependencyTracker.cs
+++++ b/src/TestIntelligence.DataTracker/TestDataDependencyTracker.cs
++@@ -412,5 +412,10 @@ namespace TestIntelligence.DataTracker
 + 
-+@@ -291,8 +318,32 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
-+         {
-+             _logger.LogDebug("Loading solution metadata: {SolutionPath}", solutionPath);
-+             
-+-            // Load solution directly - we'll manage project loading separately
-+-            _solution = await _workspace.OpenSolutionAsync(solutionPath);
-++            // Load solution directly with timeout to prevent hanging
-++            using var timeoutCts = new CancellationTokenSource(TimeSpan.FromSeconds(30));
-++            using var combinedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, timeoutCts.Token);
-++            
-++            try
-++            {
-++                var solutionTask = _workspace.OpenSolutionAsync(solutionPath);
-++                var timeoutTask = Task.Delay(TimeSpan.FromSeconds(30), combinedCts.Token);
-++                
-++                var completedTask = await Task.WhenAny(solutionTask, timeoutTask);
-++                if (completedTask == timeoutTask)
-++                {
-++                    _logger.LogWarning("Solution loading timed out after 30 seconds, falling back to manual solution parsing");
-++                    await InitializeFromSolutionManuallyAsync(solutionPath, cancellationToken);
-++                    return;
-++                }
-++                
-++                _solution = await solutionTask;
-++            }
-++            catch (OperationCanceledException) when (timeoutCts.Token.IsCancellationRequested)
-++            {
-++                _logger.LogWarning("Solution loading timed out after 30 seconds, falling back to manual solution parsing");
-++                await InitializeFromSolutionManuallyAsync(solutionPath, cancellationToken);
-++                return;
-++            }
-++            
-+             var solutionInfo = _solution;
-+ 
-+             // Build file-to-project mapping from solution
-+@@ -336,6 +387,70 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
-+             }
-+         }
-+ 
-++        /// <summary>
-++        /// Manual solution parsing fallback when MSBuild workspace fails
-++        /// </summary>
-++        private async Task InitializeFromSolutionManuallyAsync(string solutionPath, CancellationToken cancellationToken)
-++        {
-++            try
-++            {
-++                _logger.LogInformation("Using manual solution parsing for: {SolutionPath}", solutionPath);
-++                
-++                // Parse solution file manually to get project paths
-++                var solutionDir = Path.GetDirectoryName(solutionPath)!;
-++                var solutionLines = await File.ReadAllLinesAsync(solutionPath, cancellationToken);
-++                
-++                var projectPaths = new List<string>();
-++                foreach (var line in solutionLines)
-++                {
-++                    // Look for project lines: Project("{...}") = "ProjectName", "RelativePath", "{...}"
-++                    if (line.StartsWith("Project(") && line.Contains(".csproj"))
-++                    {
-++                        var parts = line.Split(',');
-++                        if (parts.Length >= 2)
-++                        {
-++                            var relativePath = parts[1].Trim().Trim('"');
-++                            var fullPath = Path.GetFullPath(Path.Combine(solutionDir, relativePath));
-++                            if (File.Exists(fullPath))
-++                            {
-++                                projectPaths.Add(fullPath);
-++                            }
-++                        }
-++                    }
-++                }
-++                
-++                _logger.LogInformation("Found {ProjectCount} projects via manual parsing", projectPaths.Count);
-++                
-++                // Build file-to-project mapping using file system scanning
-++                foreach (var projectPath in projectPaths)
-++                {
-++                    try
-++                    {
-++                        var projectDir = Path.GetDirectoryName(projectPath)!;
-++                        var csFiles = Directory.GetFiles(projectDir, "*.cs", SearchOption.AllDirectories)
-++                            .Where(f => !f.Contains("bin") && !f.Contains("obj") && !f.Contains("packages"));
-++                        
-++                        foreach (var file in csFiles)
-++                        {
-++                            _fileToProjectMap[file] = projectPath;
-++                        }
-++                    }
-++                    catch (Exception ex)
-++                    {
-++                        _logger.LogDebug(ex, "Failed to scan project directory: {ProjectPath}", projectPath);
-++                    }
-++                }
-++                
-++                _logger.LogInformation("Manual solution parsing completed: {ProjectCount} projects, {FileCount} file mappings", 
-++                    projectPaths.Count, _fileToProjectMap.Count);
-++            }
-++            catch (Exception ex)
-++            {
-++                _logger.LogError(ex, "Manual solution parsing failed for: {SolutionPath}", solutionPath);
-++                throw;
-++            }
-++        }
-++
-+         private void OnWorkspaceFailed(object? sender, WorkspaceDiagnosticEventArgs e)
-+         {
-+             _logger.LogDebug("Workspace diagnostic: {Kind} - {Message}", e.Diagnostic.Kind, e.Diagnostic.Message);
-+diff --git a/src/TestIntelligence.ImpactAnalyzer/Analysis/RoslynAnalyzer.cs b/src/TestIntelligence.ImpactAnalyzer/Analysis/RoslynAnalyzer.cs
-+index 9648e81..9a182a8 100644
-+--- a/src/TestIntelligence.ImpactAnalyzer/Analysis/RoslynAnalyzer.cs
-++++ b/src/TestIntelligence.ImpactAnalyzer/Analysis/RoslynAnalyzer.cs
-+@@ -62,7 +62,9 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
-+                 // Initialize lazy workspace for much better performance
-+                 await InitializeLazyWorkspaceAsync(solutionFile, cancellationToken).ConfigureAwait(false);
-+ 
-+-                if (_incrementalCallGraphBuilder != null)
-++                // TEMPORARY FIX: Disable incremental call graph builder due to placeholder implementation
-++                // The GetMethodIdsFromFile method returns empty lists, causing 0 methods to be analyzed
-++                if (false && _incrementalCallGraphBuilder != null)
-+                 {
-+                     _logger.LogInformation("Using high-performance incremental call graph builder");
-+                     // For full solution analysis, we still need to analyze all files, but incrementally
-+@@ -71,6 +73,7 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
-+                 }
-+                 
-+                 // Fallback to legacy full analysis
-++                _logger.LogInformation("Using legacy call graph builder (incremental builder temporarily disabled)");
-+                 await InitializeWorkspaceAsync(solutionFile, cancellationToken).ConfigureAwait(false);
-+ 
-+                 if (_callGraphBuilder == null)
-+diff --git a/src/TestIntelligence.ImpactAnalyzer/Analysis/SolutionWorkspaceBuilder.cs b/src/TestIntelligence.ImpactAnalyzer/Analysis/SolutionWorkspaceBuilder.cs
-+index eb69959..b30e8e6 100644
-+--- a/src/TestIntelligence.ImpactAnalyzer/Analysis/SolutionWorkspaceBuilder.cs
-++++ b/src/TestIntelligence.ImpactAnalyzer/Analysis/SolutionWorkspaceBuilder.cs
-+@@ -168,24 +168,37 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
-+             try
-+             {
-+                 _logger.LogDebug("Loading solution using MSBuild workspace: {SolutionPath}", solutionPath);
-+-                var solution = await workspace.OpenSolutionAsync(solutionPath, cancellationToken: cancellationToken);
-+                 
-+-                _logger.LogInformation("Solution loaded with {ProjectCount} projects", solution.Projects.Count());
-++                // Apply timeout to prevent hanging - MSBuild operations can hang indefinitely
-++                using var timeoutCts = new CancellationTokenSource(TimeSpan.FromMinutes(2)); // 2 minute timeout for solution loading
-++                using var combinedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, timeoutCts.Token);
-+                 
-+-                // Log any diagnostics
-+-                foreach (var diagnostic in workspace.Diagnostics)
-++                try
-+                 {
-+-                    if (diagnostic.Kind == WorkspaceDiagnosticKind.Failure)
-+-                    {
-+-                        _logger.LogWarning("Workspace diagnostic: {Message}", diagnostic.Message);
-+-                    }
-+-                    else
-++                    var solution = await workspace.OpenSolutionAsync(solutionPath, cancellationToken: combinedCts.Token);
-++                    
-++                    _logger.LogInformation("Solution loaded with {ProjectCount} projects", solution.Projects.Count());
-++                    
-++                    // Log any diagnostics
-++                    foreach (var diagnostic in workspace.Diagnostics)
-+                     {
-+-                        _logger.LogDebug("Workspace diagnostic: {Message}", diagnostic.Message);
-++                        if (diagnostic.Kind == WorkspaceDiagnosticKind.Failure)
-++                        {
-++                            _logger.LogWarning("Workspace diagnostic: {Message}", diagnostic.Message);
-++                        }
-++                        else
-++                        {
-++                            _logger.LogDebug("Workspace diagnostic: {Message}", diagnostic.Message);
-++                        }
-+                     }
-++                    
-++                    return solution;
-++                }
-++                catch (OperationCanceledException) when (timeoutCts.Token.IsCancellationRequested)
-++                {
-++                    _logger.LogError("Solution loading timed out after 2 minutes: {SolutionPath}", solutionPath);
-++                    throw new TimeoutException($"Solution loading timed out after 2 minutes. This may indicate MSBuild version conflicts or complex solution structure: {solutionPath}");
-+                 }
-+-                
-+-                return solution;
-+             }
-+             catch (Exception ex)
-+             {
-+diff --git a/src/TestIntelligence.ImpactAnalyzer/Analysis/SymbolIndex.cs b/src/TestIntelligence.ImpactAnalyzer/Analysis/SymbolIndex.cs
-+index aa9727c..12a61fa 100644
-+--- a/src/TestIntelligence.ImpactAnalyzer/Analysis/SymbolIndex.cs
-++++ b/src/TestIntelligence.ImpactAnalyzer/Analysis/SymbolIndex.cs
-+@@ -283,12 +283,13 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
-+                     var solutionContent = File.ReadAllText(solutionPath);
-+                     
-+                     // Simple regex to find project references in solution file
-+-                    var projectPattern = new Regex(@"Project\(.+\)\s*=\s*"".+"",\s*""([^""]+\.(?:cs|vb|fs)proj)""", RegexOptions.Compiled);
-++                    var projectPattern = new Regex(@"Project\(.+\)\s*=\s*"".+"",\s*""([^""]+\.(?:csproj|vbproj|fsproj))""", RegexOptions.Compiled);
-+                     var matches = projectPattern.Matches(solutionContent);
-+                     
-+                     foreach (Match match in matches)
-+                     {
-+-                        var projectPath = Path.Combine(solutionDir, match.Groups[1].Value);
-++                        var relativePath = match.Groups[1].Value.Replace('\\', Path.DirectorySeparatorChar);
-++                        var projectPath = Path.Combine(solutionDir, relativePath);
-+                         if (File.Exists(projectPath))
-+                         {
-+                             var projectFiles = await GetSourceFilesFromProjectAsync(projectPath, cancellationToken);
-+diff --git a/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs b/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs
-+index b96e163..d7f075c 100644
-+--- a/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs
-++++ b/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs
-+@@ -85,14 +85,39 @@ namespace TestIntelligence.ImpactAnalyzer.Services
-+                 // Try to build call graph with MSBuild workspace first, fallback to assembly analysis
-+                 try 
-+                 {
-++                    // Apply timeout to prevent hanging during call graph building
-++                    using var timeoutCts = new CancellationTokenSource(TimeSpan.FromMinutes(3)); // 3 minute timeout
-++                    using var combinedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, timeoutCts.Token);
-++                    
-+                     // Build the complete call graph using the solution path
-+                     // The Roslyn analyzer will handle finding source files and prefer MSBuild workspace if .sln is provided
-+-                    callGraph = await _roslynAnalyzer.BuildCallGraphAsync(new[] { solutionPath }, cancellationToken);
-++                    callGraph = await _roslynAnalyzer.BuildCallGraphAsync(new[] { solutionPath }, combinedCts.Token);
-+                     
-+                     // Cache the result
-+                     _cachedCallGraph = callGraph;
-+                     _cachedSolutionPath = solutionPath;
-+                 }
-++                catch (TimeoutException ex)
-++                {
-++                    _logger.LogWarning(ex, "Call graph building timed out after 3 minutes, falling back to assembly-based analysis");
-++                    
-++                    // Fallback: Try to analyze compiled assemblies instead
-++                    var assemblyPaths = FindTestAssembliesInSolution(solutionPath);
-++                    if (assemblyPaths.Any())
-++                    {
-++                        _logger.LogInformation("Found {AssemblyCount} test assemblies for fallback analysis", assemblyPaths.Count);
-++                        callGraph = await _roslynAnalyzer.BuildCallGraphAsync(assemblyPaths.ToArray(), cancellationToken);
-++                        
-++                        // Cache the result
-++                        _cachedCallGraph = callGraph;
-++                        _cachedSolutionPath = solutionPath;
-++                    }
-++                    else
-++                    {
-++                        _logger.LogWarning("No assemblies found for fallback analysis");
-++                        return new TestCoverageMap(new Dictionary<string, List<TestCoverageInfo>>(), DateTime.UtcNow, solutionPath);
-++                    }
-++                }
-+                 catch (InvalidOperationException ex) when (ex.Message.Contains("System.CodeDom") || ex.Message.Contains("MSBuild workspace"))
-+                 {
-+                     _logger.LogWarning(ex, "MSBuild workspace failed, falling back to assembly-based analysis");
-+@@ -536,6 +561,16 @@ namespace TestIntelligence.ImpactAnalyzer.Services
-+ 
-+             var testMethods = _testClassifier.GetTestMethods(allMethods);
-+             _logger.LogInformation("Found {TestMethodCount} test methods for streaming analysis", testMethods.Count);
-++            
-++            // Find actual method IDs that match the user's pattern
-++            var targetMethodIds = FindMatchingMethodIds(methodId, allMethods);
-++            _logger.LogDebug("Found {Count} target method IDs matching pattern: {Pattern}", targetMethodIds.Count, methodId);
-++            
-++            if (targetMethodIds.Count == 0)
-++            {
-++                _logger.LogWarning("No methods found matching pattern: {MethodId}", methodId);
-++                yield break;
-++            }
-+ 
-+             // Process test methods and yield results as we find them
-+             foreach (var testMethod in testMethods)
-+@@ -545,10 +580,23 @@ namespace TestIntelligence.ImpactAnalyzer.Services
-+                 TestCoverageInfo? result = null;
-+                 try
-+                 {
-+-                    var callPath = FindCallPath(testMethod.Id, methodId, callGraph);
-+-                    if (callPath != null && callPath.Any())
-++                    // Try to find call paths to any of the matching target methods
-++                    string[]? callPath = null;
-++                    string? matchedTargetMethodId = null;
-++                    
-++                    foreach (var targetId in targetMethodIds)
-+                     {
-+-                        var confidence = CalculateConfidence(callPath, testMethod, callGraph.GetMethodInfo(methodId)!);
-++                        callPath = FindCallPath(testMethod.Id, targetId, callGraph);
-++                        if (callPath != null && callPath.Any())
-++                        {
-++                            matchedTargetMethodId = targetId;
-++                            break;
-++                        }
-++                    }
-++                    if (callPath != null && callPath.Any() && matchedTargetMethodId != null)
-++                    {
-++                        var targetMethodInfo = callGraph.GetMethodInfo(matchedTargetMethodId)!;
-++                        var confidence = CalculateConfidence(callPath, testMethod, targetMethodInfo);
-+                         var testType = _testClassifier.ClassifyTestType(testMethod);
-+ 
-+                         result = new TestCoverageInfo(
-+@@ -616,5 +664,63 @@ namespace TestIntelligence.ImpactAnalyzer.Services
-+             _pathCache.Clear();
-+             _logger.LogDebug("Cleared all caches");
-+         }
-++
-++        /// <summary>
-++        /// Find all method IDs in the call graph that match the given pattern.
-++        /// Handles global:: prefix and parameter variations.
-++        /// </summary>
-++        private List<string> FindMatchingMethodIds(string pattern, IReadOnlyList<MethodInfo> allMethods)
-++        {
-++            var matchingIds = new List<string>();
-++            
-++            foreach (var method in allMethods)
-++            {
-++                if (IsMethodPatternMatch(method.Id, pattern))
-++                {
-++                    matchingIds.Add(method.Id);
-++                }
-++            }
-++            
-++            return matchingIds;
-++        }
-++
++         public int TotalTestPairs => CanRunInParallel.Count + MustRunSequentially.Count;
++         public double ParallelExecutionRatio => TotalTestPairs > 0 ? (double)CanRunInParallel.Count / TotalTestPairs : 0;
+++        
 ++        /// <summary>
-++        /// Determines if a method ID matches the given pattern.
-++        /// Supports pattern matching like the TestCoverageMap.IsMethodMatch method.
+++        /// Test method to validate coverage analysis functionality.
 ++        /// </summary>
-++        private static bool IsMethodPatternMatch(string fullMethodId, string pattern)
-++        {
-++            if (string.IsNullOrEmpty(fullMethodId) || string.IsNullOrEmpty(pattern))
-++                return false;
-++
-++            // Exact match
-++            if (fullMethodId.Equals(pattern, StringComparison.OrdinalIgnoreCase))
-++                return true;
-++
-++            // Remove global:: prefix if present for comparison
-++            var normalizedMethodId = fullMethodId.StartsWith("global::", StringComparison.OrdinalIgnoreCase) 
-++                ? fullMethodId.Substring(8) // Remove "global::" prefix
-++                : fullMethodId;
-++
-++            // Extract method name without parameters from normalized ID
-++            // Format: Namespace.Class.Method(params)
-++            var parenIndex = normalizedMethodId.IndexOf('(');
-++            var methodWithoutParams = parenIndex > 0 ? normalizedMethodId.Substring(0, parenIndex) : normalizedMethodId;
-++
-++            // Check if pattern matches the method without parameters
-++            if (methodWithoutParams.Equals(pattern, StringComparison.OrdinalIgnoreCase))
-++                return true;
-++
-++            // Check if pattern is just the method name (last part after final dot)
-++            var lastDotIndex = methodWithoutParams.LastIndexOf('.');
-++            if (lastDotIndex >= 0 && lastDotIndex < methodWithoutParams.Length - 1)
-++            {
-++                var methodNameOnly = methodWithoutParams.Substring(lastDotIndex + 1);
-++                if (methodNameOnly.Equals(pattern, StringComparison.OrdinalIgnoreCase))
-++                    return true;
-++            }
-++
-++            return false;
-++        }
-+     }
-+ }
-+\ No newline at end of file
-+diff --git a/src/TestIntelligence.ImpactAnalyzer/TestIntelligence.ImpactAnalyzer.csproj b/src/TestIntelligence.ImpactAnalyzer/TestIntelligence.ImpactAnalyzer.csproj
-+index 66261c7..1cb2408 100644
-+--- a/src/TestIntelligence.ImpactAnalyzer/TestIntelligence.ImpactAnalyzer.csproj
-++++ b/src/TestIntelligence.ImpactAnalyzer/TestIntelligence.ImpactAnalyzer.csproj
-+@@ -1,7 +1,7 @@
-+ <Project Sdk="Microsoft.NET.Sdk">
-+ 
-+   <PropertyGroup>
-+-    <TargetFramework>netstandard2.0</TargetFramework>
-++    <TargetFramework>netstandard2.1</TargetFramework>
-+     <LangVersion>latest</LangVersion>
-+     <Nullable>enable</Nullable>
-+     <PackageId>TestIntelligence.ImpactAnalyzer</PackageId>
-+@@ -28,6 +28,8 @@
-+     <!-- Other dependencies provided by Directory.Build.props: Microsoft.CodeAnalysis.CSharp, Newtonsoft.Json, System.Collections.Immutable, System.CodeDom -->
-+     <PackageReference Include="System.Reflection.Metadata" Version="8.0.0" />
-+     <PackageReference Include="System.Text.Json" Version="8.0.5" />
-++    <!-- Add explicit reference to fix MSBuild conflicts -->
-++    <PackageReference Include="Microsoft.Build.Framework" Version="17.9.5" ExcludeAssets="runtime" />
-+   </ItemGroup>
-+ 
-+   <ItemGroup>
-+diff --git a/src/TestIntelligence.SelectionEngine/TestIntelligence.SelectionEngine.csproj b/src/TestIntelligence.SelectionEngine/TestIntelligence.SelectionEngine.csproj
-+index 41ee1d0..3a1d337 100644
-+--- a/src/TestIntelligence.SelectionEngine/TestIntelligence.SelectionEngine.csproj
-++++ b/src/TestIntelligence.SelectionEngine/TestIntelligence.SelectionEngine.csproj
-+@@ -1,7 +1,7 @@
-+ <Project Sdk="Microsoft.NET.Sdk">
-+ 
-+   <PropertyGroup>
-+-    <TargetFramework>netstandard2.0</TargetFramework>
-++    <TargetFramework>netstandard2.1</TargetFramework>
-+     <LangVersion>latest</LangVersion>
-+     <Nullable>enable</Nullable>
-+     <PackageId>TestIntelligence.SelectionEngine</PackageId>
-+diff --git a/tests/TestIntelligence.SelectionEngine.Tests/Engine/TestSelectionEngineTests.cs b/tests/TestIntelligence.SelectionEngine.Tests/Engine/TestSelectionEngineTests.cs
-+index d4d4c36..55b8911 100644
-+--- a/tests/TestIntelligence.SelectionEngine.Tests/Engine/TestSelectionEngineTests.cs
-++++ b/tests/TestIntelligence.SelectionEngine.Tests/Engine/TestSelectionEngineTests.cs
-+@@ -205,5 +205,222 @@ namespace TestIntelligence.SelectionEngine.Tests.Engine
-+         {
-+             // Sample method for reflection
-+         }
-++
-++        #region Integration Tests for ScoreTestsAsync
-++
-++        [Fact]
-++        public async Task ScoreTestsAsync_WithMixedTestTypes_ShouldPrioritizeBasedOnCategory()
-++        {
-++            var tests = new[]
-++            {
-++                CreateTestInfo("FastUnitTest", TestCategory.Unit, TimeSpan.FromMilliseconds(50), 0.0),
-++                CreateTestInfo("SlowIntegrationTest", TestCategory.Integration, TimeSpan.FromSeconds(2), 0.0),
-++                CreateTestInfo("DatabaseTest", TestCategory.Database, TimeSpan.FromSeconds(5), 0.0),
-++                CreateTestInfo("UITest", TestCategory.UI, TimeSpan.FromSeconds(10), 0.0)
-++            };
-++
-++            var engine = new TestSelectionEngine(_mockLogger.Object, new[] { _mockScoringAlgorithm.Object });
-++            
-++            // Configure mock to return different scores based on category
-++            _mockScoringAlgorithm.Setup(x => x.CalculateScoreAsync(It.IsAny<TestInfo>(), It.IsAny<TestScoringContext>(), It.IsAny<CancellationToken>()))
-++                .Returns<TestInfo, TestScoringContext, CancellationToken>((test, context, ct) => test.Category switch
-++                {
-++                    TestCategory.Unit => Task.FromResult(0.9), // Highest priority for unit tests
-++                    TestCategory.Integration => Task.FromResult(0.7),
-++                    TestCategory.Database => Task.FromResult(0.5),
-++                    TestCategory.UI => Task.FromResult(0.3), // Lowest priority for UI tests
-++                    _ => Task.FromResult(0.1)
-++                });
-++
-++            var scoredTests = await engine.ScoreTestsAsync(tests);
-++
-++            scoredTests.Should().HaveCount(4);
-++            scoredTests[0].TestMethod.GetDisplayName().Should().Contain("FastUnitTest");
-++            scoredTests[1].TestMethod.GetDisplayName().Should().Contain("SlowIntegrationTest");
-++            scoredTests[2].TestMethod.GetDisplayName().Should().Contain("DatabaseTest");
-++            scoredTests[3].TestMethod.GetDisplayName().Should().Contain("UITest");
-++        }
-++
-++        [Fact]
-++        public async Task ScoreTestsAsync_WithCodeChanges_ShouldBoostRelatedTests()
-++        {
-++            var changes = CreateCodeChangeSet();
-++            var tests = new[]
-++            {
-++                CreateTestInfo("UnrelatedTest", TestCategory.Unit, TimeSpan.FromMilliseconds(100)),
-++                CreateTestInfo("RelatedTest_MyMethod", TestCategory.Unit, TimeSpan.FromMilliseconds(100)),
-++                CreateTestInfo("RelatedTest_MyClass", TestCategory.Integration, TimeSpan.FromMilliseconds(500))
-++            };
-++
-++            var engine = new TestSelectionEngine(_mockLogger.Object, new[] { _mockScoringAlgorithm.Object });
-++            
-++            // Configure mock to boost scores for related tests
-++            _mockScoringAlgorithm.Setup(x => x.CalculateScoreAsync(It.IsAny<TestInfo>(), It.IsAny<TestScoringContext>(), It.IsAny<CancellationToken>()))
-++                .Returns<TestInfo, TestScoringContext, CancellationToken>((test, context, ct) =>
-++                {
-++                    if (test.TestMethod.GetDisplayName().Contains("Related"))
-++                        return Task.FromResult(0.9); // High score for related tests
-++                    return Task.FromResult(0.3); // Lower score for unrelated tests
-++                });
-++
-++            var scoredTests = await engine.ScoreTestsAsync(tests, changes);
-++
-++            scoredTests.Should().HaveCount(3);
-++            // Related tests should be scored higher and appear first
-++            scoredTests.Take(2).All(t => t.TestMethod.GetDisplayName().Contains("Related")).Should().BeTrue();
-++            scoredTests.Last().TestMethod.GetDisplayName().Should().Contain("UnrelatedTest");
-++        }
-++
-++        [Fact]
-++        public async Task ScoreTestsAsync_WithExecutionHistoryContext_ShouldConsiderReliability()
-++        {
-++            var tests = new[]
-++            {
-++                CreateTestInfo("FlakeyTest", TestCategory.Unit, TimeSpan.FromMilliseconds(100)),
-++                CreateTestInfo("ReliableTest", TestCategory.Unit, TimeSpan.FromMilliseconds(150)),
-++                CreateTestInfo("NewTest", TestCategory.Unit, TimeSpan.FromMilliseconds(80))
-++            };
-++
-++            // Simulate execution history for the tests
-++            var flakeyTest = tests[0];
-++            foreach(var result in new[]
-++            {
-++                new TestExecutionResult(false, TimeSpan.FromMilliseconds(100), DateTimeOffset.UtcNow.AddDays(-1)), // Failed
-++                new TestExecutionResult(true, TimeSpan.FromMilliseconds(95), DateTimeOffset.UtcNow.AddHours(-12)), // Passed
-++                new TestExecutionResult(false, TimeSpan.FromMilliseconds(110), DateTimeOffset.UtcNow.AddHours(-6)) // Failed
-++            }) { flakeyTest.ExecutionHistory.Add(result); }
-++
-++            var reliableTest = tests[1];
-++            foreach(var result in new[]
-++            {
-++                new TestExecutionResult(true, TimeSpan.FromMilliseconds(150), DateTimeOffset.UtcNow.AddDays(-1)), // Passed
-++                new TestExecutionResult(true, TimeSpan.FromMilliseconds(145), DateTimeOffset.UtcNow.AddHours(-12)), // Passed
-++                new TestExecutionResult(true, TimeSpan.FromMilliseconds(155), DateTimeOffset.UtcNow.AddHours(-6)) // Passed
-++            }) { reliableTest.ExecutionHistory.Add(result); }
-++
-++            var engine = new TestSelectionEngine(_mockLogger.Object, new[] { _mockScoringAlgorithm.Object });
-++            
-++            // Configure mock to factor in reliability
-++            _mockScoringAlgorithm.Setup(x => x.CalculateScoreAsync(It.IsAny<TestInfo>(), It.IsAny<TestScoringContext>(), It.IsAny<CancellationToken>()))
-++                .Returns<TestInfo, TestScoringContext, CancellationToken>((test, context, ct) =>
-++                {
-++                    if (test.TestMethod.GetDisplayName().Contains("Reliable"))
-++                        return Task.FromResult(0.9); // High score for reliable tests
-++                    if (test.TestMethod.GetDisplayName().Contains("Flakey"))
-++                        return Task.FromResult(0.4); // Lower score for flakey tests
-++                    return Task.FromResult(0.7); // Medium score for new tests
-++                });
-++
-++            var scoredTests = await engine.ScoreTestsAsync(tests);
-++
-++            scoredTests.Should().HaveCount(3);
-++            scoredTests[0].TestMethod.GetDisplayName().Should().Contain("ReliableTest");
-++            scoredTests[1].TestMethod.GetDisplayName().Should().Contain("NewTest");
-++            scoredTests[2].TestMethod.GetDisplayName().Should().Contain("FlakeyTest");
-++        }
-++
-++        [Fact]
-++        public async Task ScoreTestsAsync_WithLargeTestSuite_ShouldHandlePerformantly()
-++        {
-++            // Create a large number of tests to verify performance
-++            var tests = Enumerable.Range(1, 1000)
-++                .Select(i => CreateTestInfo($"Test_{i:D4}", 
-++                    (TestCategory)(i % 4), // Distribute across categories
-++                    TimeSpan.FromMilliseconds(50 + (i % 200)), // Vary execution times
-++                    0.0))
-++                .ToArray();
-++
-++            var engine = new TestSelectionEngine(_mockLogger.Object, new[] { _mockScoringAlgorithm.Object });
-++            
-++            _mockScoringAlgorithm.Setup(x => x.CalculateScoreAsync(It.IsAny<TestInfo>(), It.IsAny<TestScoringContext>(), It.IsAny<CancellationToken>()))
-++                .Returns<TestInfo, TestScoringContext, CancellationToken>((test, context, ct) =>
-++                {
-++                    // Simulate varying scoring based on test name hash
-++                    var hash = test.TestMethod.GetDisplayName().GetHashCode();
-++                    var score = (Math.Abs(hash) % 100) / 100.0; // Score between 0.0 and 1.0
-++                    return Task.FromResult(score);
-++                });
-++
-++            var stopwatch = System.Diagnostics.Stopwatch.StartNew();
-++            var scoredTests = await engine.ScoreTestsAsync(tests);
-++            stopwatch.Stop();
-++
-++            scoredTests.Should().HaveCount(1000);
-++            scoredTests.Should().BeInDescendingOrder(t => t.SelectionScore);
-++            
-++            // Performance assertion - should complete within reasonable time
-++            stopwatch.ElapsedMilliseconds.Should().BeLessThan(5000, "scoring 1000 tests should complete within 5 seconds");
-++            
-++            // Verify all tests have been scored
-++            scoredTests.All(t => t.SelectionScore > 0).Should().BeTrue();
-++        }
-++
-++        [Theory]
-++        [InlineData(ConfidenceLevel.Fast)]
-++        [InlineData(ConfidenceLevel.Medium)]
-++        [InlineData(ConfidenceLevel.High)]
-++        [InlineData(ConfidenceLevel.Full)]
-++        public async Task ScoreTestsAsync_WithDifferentConfidenceLevels_ShouldAdjustScoring(ConfidenceLevel confidence)
-++        {
-++            var tests = new[]
-++            {
-++                CreateTestInfo("UnitTest", TestCategory.Unit, TimeSpan.FromMilliseconds(50)),
-++                CreateTestInfo("IntegrationTest", TestCategory.Integration, TimeSpan.FromSeconds(1)),
-++                CreateTestInfo("E2ETest", TestCategory.UI, TimeSpan.FromSeconds(10))
-++            };
-++
-++            var changes = CreateCodeChangeSet();
-++            var engine = new TestSelectionEngine(_mockLogger.Object, new[] { _mockScoringAlgorithm.Object });
-++            
-++            // Configure scoring based on confidence level
-++            _mockScoringAlgorithm.Setup(x => x.CalculateScoreAsync(It.IsAny<TestInfo>(), It.IsAny<TestScoringContext>(), It.IsAny<CancellationToken>()))
-++                .Returns<TestInfo, TestScoringContext, CancellationToken>((test, context, ct) =>
-++                {
-++                    var baseScore = test.Category switch
-++                    {
-++                        TestCategory.Unit => 0.8,
-++                        TestCategory.Integration => 0.6,
-++                        TestCategory.UI => 0.4,
-++                        _ => 0.2
-++                    };
-++
-++                    // Boost score based on confidence level
-++                    var confidenceMultiplier = context.ConfidenceLevel switch
-++                    {
-++                        ConfidenceLevel.Fast => test.Category == TestCategory.Unit ? 1.2 : 0.8,
-++                        ConfidenceLevel.Medium => test.Category <= TestCategory.Integration ? 1.1 : 0.9,
-++                        ConfidenceLevel.High => 1.0,
-++                        ConfidenceLevel.Full => 1.0,
-++                        _ => 1.0
-++                    };
-++
-++                    return Task.FromResult(baseScore * confidenceMultiplier);
-++                });
-++
-++            var scoredTests = await engine.ScoreTestsAsync(tests, changes);
-++
-++            scoredTests.Should().HaveCount(3);
-++            scoredTests.Should().BeInDescendingOrder(t => t.SelectionScore);
-++            
-++            // Verify confidence-specific behavior
-++            switch (confidence)
-++            {
-++                case ConfidenceLevel.Fast:
-++                    // Should prioritize unit tests
-++                    scoredTests[0].Category.Should().Be(TestCategory.Unit);
-++                    break;
-++                case ConfidenceLevel.Medium:
-++                    // Should include unit and integration tests with good scores
-++                    scoredTests.Take(2).All(t => t.Category <= TestCategory.Integration).Should().BeTrue();
-++                    break;
-++                case ConfidenceLevel.High:
-++                case ConfidenceLevel.Full:
-++                    // Should include all test types
-++                    scoredTests.Should().Contain(t => t.Category == TestCategory.UI);
-++                    break;
-++            }
-++        }
-++
-++        #endregion
+++        public bool HasConflicts() => MustRunSequentially.Count > 0;
 +     }
 + }
 +\ No newline at end of file
-diff --git a/src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs b/src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
-index 410eadf..dc9ed54 100644
---- a/src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
-+++ b/src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
-@@ -247,4 +247,4 @@ namespace TestIntelligence.Core.Discovery
-             DiscoveryError?.Invoke(this, new TestDiscoveryErrorEventArgs(assemblyPath, exception));
-         }
-     }
--}
-\ No newline at end of file
-+}// Test change for coverage analysis
-diff --git a/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs b/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs
-index d7f075c..7b686cd 100644
---- a/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs
-+++ b/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs
-@@ -723,4 +723,4 @@ namespace TestIntelligence.ImpactAnalyzer.Services
-             return false;
-         }
-     }
--}
-\ No newline at end of file
-+}// Test change for coverage analysis
++diff --git a/test-changes.patch b/test-changes.patch
++index 11bbfa0..4549ffa 100644
++--- a/test-changes.patch
+++++ b/test-changes.patch
++@@ -1,2130 +1,22 @@
++-diff --git a/recent-changes.patch b/recent-changes.patch
++-new file mode 100644
++-index 0000000..6d0dbc7
++---- /dev/null
++-+++ b/recent-changes.patch
++-@@ -0,0 +1,2102 @@
++-+diff --git a/.claude/commands/debug-find-tests.md b/.claude/commands/debug-find-tests.md
++-+new file mode 100644
++-+index 0000000..10c1e5e
++-+--- /dev/null
++-++++ b/.claude/commands/debug-find-tests.md
++-+@@ -0,0 +1,454 @@
++-++# Debug Find-Tests Command
++-++
++-++Debug version of find-tests testing with enhanced tracing to troubleshoot issues we've been experiencing with the find-tests command accuracy.
++-++
++-++## Known Issues to Investigate
++-++- Potential false positives in test detection
++-++- Missing tests that should be found
++-++- Incorrect confidence scoring
++-++- Call graph traversal problems
++-++- Assembly loading or reflection issues
++-++
++-++## Debug Testing Protocol
++-++
++-++### Step 1: Select Target Method with Debug Context
++-++1. **Choose a well-known method** with clear test relationships:
++-++   ```bash
++-++   # Example: Pick a method we know is tested
++-++   echo "üîç Selecting target method for debug analysis..."
++-++   grep -r "DiscoverTestsAsync\|AnalyzeAssembly\|ProcessDependencies" src/ --include="*.cs" -n | head -5
++-++   ```
++-++
++-++2. **Document expected behavior**:
++-++   ```bash
++-++   echo "üìù Documenting what we expect to find..."
++-++   # Manually identify tests that should be found
++-++   grep -r "TargetMethodName" tests/ --include="*.cs" -l
++-++   ```
++-++
++-++### Step 2: Add Debug Tracing to Source Code
++-++
++-++Before running the command, temporarily add debug statements to trace execution:
++-++
++-++```bash
++-++# Backup original files
++-++cp src/TestIntelligence.CLI/Commands/FindTestsCommand.cs src/TestIntelligence.CLI/Commands/FindTestsCommand.cs.debug-backup
++-++cp src/TestIntelligence.Core/Services/TestMethodMapper.cs src/TestIntelligence.Core/Services/TestMethodMapper.cs.debug-backup
++-++```
++-++
++-++#### Add debug statements to key files:
++-++
++-++**1. FindTestsCommand.cs - Entry point tracing**:
++-++```csharp
++-++// Add after method signature
++-++Console.WriteLine($"üîç DEBUG: Starting find-tests for method: {methodName}");
++-++Console.WriteLine($"üîç DEBUG: Solution path: {solutionPath}");
++-++Console.WriteLine($"üîç DEBUG: Output format: {format}");
++-++```
++-++
++-++**2. TestMethodMapper.cs - Core logic tracing**:
++-++```csharp
++-++// Add in FindTestsForMethod
++-++Console.WriteLine($"üîç DEBUG: Loading solution: {solutionPath}");
++-++Console.WriteLine($"üîç DEBUG: Target method: {targetMethod}");
++-++Console.WriteLine($"üîç DEBUG: Found {projects.Count} projects to analyze");
++-++
++-++// Add in call graph traversal
++-++Console.WriteLine($"üîç DEBUG: Building call graph for method: {method.Name}");
++-++Console.WriteLine($"üîç DEBUG: Found {callers.Count} direct callers");
++-++
++-++// Add in test discovery
++-++Console.WriteLine($"üîç DEBUG: Discovered {testMethods.Count} total test methods");
++-++Console.WriteLine($"üîç DEBUG: Filtering tests that call target method...");
++-++```
++-++
++-++**3. Assembly loading tracing**:
++-++```csharp
++-++// Add assembly loading debug info
++-++Console.WriteLine($"üîç DEBUG: Loading assembly: {assemblyPath}");
++-++Console.WriteLine($"üîç DEBUG: Assembly loaded successfully: {assembly.FullName}");
++-++Console.WriteLine($"üîç DEBUG: Found {types.Length} types in assembly");
++-++```
++-++
++-++### Step 3: Run Debug-Enhanced Find-Tests Command
++-++
++-++```bash
++-++# Clear cache to ensure fresh analysis
++-++dotnet run --project src/TestIntelligence.CLI cache \
++-++  --solution TestIntelligence.sln \
++-++  --action clear
++-++
++-++echo "üöÄ Running debug find-tests command..."
++-++dotnet run --project src/TestIntelligence.CLI find-tests \
++-++  --method "TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync" \
++-++  --solution TestIntelligence.sln \
++-++  --format json \
++-++  --output debug-find-tests-result.json \
++-++  --verbose 2>&1 | tee debug-find-tests-trace.log
++-++```
++-++
++-++### Step 4: Enhanced Debug Analysis
++-++
++-++#### 4.1 Trace Analysis
++-++```bash
++-++echo "üìä Analyzing debug trace..."
++-++
++-++# Check if solution loaded correctly
++-++grep "Loading solution" debug-find-tests-trace.log
++-++grep "Found.*projects" debug-find-tests-trace.log
++-++
++-++# Check assembly loading
++-++grep "Loading assembly" debug-find-tests-trace.log
++-++grep "Assembly loaded successfully" debug-find-tests-trace.log
++-++
++-++# Check call graph construction
++-++grep "Building call graph" debug-find-tests-trace.log
++-++grep "Found.*callers" debug-find-tests-trace.log
++-++
++-++# Check test discovery
++-++grep "Discovered.*test methods" debug-find-tests-trace.log
++-++grep "Filtering tests" debug-find-tests-trace.log
++-++```
++-++
++-++#### 4.2 Validate Each Step
++-++```bash
++-++echo "üîç Step-by-step validation..."
++-++
++-++# 1. Verify target method exists
++-++echo "1. Checking if target method exists in codebase:"
++-++grep -r "DiscoverTestsAsync" src/ --include="*.cs" -A 2 -B 2
++-++
++-++# 2. Verify test methods that should be found
++-++echo "2. Manual search for tests that should be found:"
++-++grep -r "DiscoverTestsAsync\|NUnitTestDiscovery" tests/ --include="*.cs" -n
++-++
++-++# 3. Check for false positives in results
++-++echo "3. Examining found tests for false positives:"
++-++jq '.foundTests[].testName' debug-find-tests-result.json
++-++
++-++# 4. Cross-reference with actual test code
++-++echo "4. Cross-referencing with actual test implementations:"
++-++for test in $(jq -r '.foundTests[].testName' debug-find-tests-result.json); do
++-++  echo "Examining test: $test"
++-++  # Find the test file and examine it
++-++  grep -r "$test" tests/ --include="*.cs" -A 10 -B 2
++-++done
++-++```
++-++
++-++### Step 5: Deep Dive Debugging
++-++
++-++#### 5.1 Call Graph Debugging
++-++```bash
++-++echo "üï∏Ô∏è Deep dive into call graph construction..."
++-++
++-++# Generate call graph for target method
++-++dotnet run --project src/TestIntelligence.CLI callgraph \
++-++  --path TestIntelligence.sln \
++-++  --format json \
++-++  --output debug-callgraph.json \
++-++  --verbose
++-++
++-++# Compare call graph with find-tests results
++-++echo "Comparing call graph with find-tests results..."
++-++jq '.methods[] | select(.name | contains("DiscoverTestsAsync"))' debug-callgraph.json
++-++```
++-++
++-++#### 5.2 Assembly Reflection Debugging
++-++Add deeper assembly inspection:
++-++```csharp
++-++// Add to assembly loading section
++-++Console.WriteLine($"üîç DEBUG: Assembly types found:");
++-++foreach (var type in assembly.GetTypes())
++-++{
++-++    Console.WriteLine($"  - {type.FullName}");
++-++    if (type.Name.Contains("Test"))
++-++    {
++-++        var methods = type.GetMethods().Where(m => m.GetCustomAttributes().Any());
++-++        Console.WriteLine($"    Test methods: {methods.Count()}");
++-++        foreach (var method in methods)
++-++        {
++-++            Console.WriteLine($"      - {method.Name}");
++-++        }
++-++    }
++-++}
++-++```
++-++
++-++### Step 6: Issue Classification and Reporting
++-++
++-++#### 6.1 Categorize Issues Found
++-++```bash
++-++echo "üìã Categorizing issues found during debug session..."
++-++
++-++# False Positives Analysis
++-++echo "‚ùå FALSE POSITIVES:"
++-++echo "Tests that were found but don't actually call the target method:"
++-++# Manual analysis based on code examination
++-++
++-++# False Negatives Analysis  
++-++echo "‚ùå FALSE NEGATIVES:"
++-++echo "Tests that should have been found but weren't:"
++-++# Compare manual grep results with CLI output
++-++
++-++# Confidence Score Issues
++-++echo "‚ö†Ô∏è CONFIDENCE SCORE ISSUES:"
++-++echo "Tests with inappropriate confidence scores:"
++-++# Analyze if scores match call depth/complexity
++-++```
++-++
++-++#### 6.2 Root Cause Analysis
++-++Based on debug output, identify likely causes:
++-++
++-++**Common Issues to Look For**:
++-++- **Assembly Loading**: Are all test assemblies being loaded?
++-++- **Reflection Issues**: Are test attributes being detected correctly?
++-++- **Call Graph**: Is method call traversal working correctly?
++-++- **Name Matching**: Are there namespace or overload resolution issues?
++-++- **Caching**: Are cached results stale or incorrect?
++-++
++-++### Step 7: Debug Report Format
++-++
++-++```
++-++## Debug Find-Tests Analysis Report
++-++
++-++**Target Method**: TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync
++-++**Debug Session Date**: [Current Date]
++-++**Known Issues Being Investigated**: False positives, missing integration tests
++-++
++-++### Debug Trace Summary
++-++- ‚úÖ Solution loaded: 15 projects found
++-++- ‚úÖ Target method located in: TestIntelligence.Core.dll
++-++- ‚ö†Ô∏è Assembly loading: 2 warnings about dependency versions
++-++- ‚úÖ Call graph construction: 45 direct callers found
++-++- ‚ùå Test discovery: Only 12 test methods found (expected ~20)
++-++
++-++### Execution Flow Analysis
++-++
++-++#### 1. Solution Loading (‚úÖ Working)
++-++```
++-++üîç DEBUG: Loading solution: TestIntelligence.sln
++-++üîç DEBUG: Found 15 projects to analyze
++-++```
++-++
++-++#### 2. Target Method Resolution (‚úÖ Working)
++-++```
++-++üîç DEBUG: Target method: TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync
++-++üîç DEBUG: Method located in assembly: TestIntelligence.Core
++-++```
++-++
++-++#### 3. Call Graph Construction (‚ö†Ô∏è Partial Issue)
++-++```
++-++üîç DEBUG: Building call graph for method: DiscoverTestsAsync
++-++üîç DEBUG: Found 45 direct callers
++-++Issue: Missing some integration test callers due to indirect invocation
++-++```
++-++
++-++#### 4. Test Discovery (‚ùå Major Issue)
++-++```
++-++üîç DEBUG: Discovered 89 total test methods
++-++üîç DEBUG: Filtering tests that call target method...
++-++Issue: Filter logic excluding valid tests with indirect calls
++-++```
++-++
++-++### Issues Identified
++-++
++-++#### ‚ùå Issue #1: Missing Integration Tests
++-++**Problem**: Integration tests that call TestAnalyzer.AnalyzeAssembly (which calls DiscoverTestsAsync) are not being found
++-++**Root Cause**: Call graph depth limit or indirect call resolution
++-++**Evidence**: Manual grep found 8 integration tests, CLI found only 2
++-++**Debug Trace**: 
++-++```
++-++Manual: grep -r "AnalyzeAssembly" tests/ found 8 matches
++-++CLI Result: Only 2 tests with confidence scores > 0.5
++-++```
++-++
++-++#### ‚ùå Issue #2: False Positive Detection
++-++**Problem**: Test "SomeUnrelatedTest" was found with 0.3 confidence
++-++**Root Cause**: Name collision or incorrect dependency analysis
++-++**Evidence**: Test code shows no actual calls to target method
++-++**Debug Trace**:
++-++```
++-++Test code analysis: Only calls DatabaseHelper.Setup() and Assert methods
++-++No path to DiscoverTestsAsync found in manual trace
++-++```
++-++
++-++#### ‚ö†Ô∏è Issue #3: Confidence Score Inaccuracy
++-++**Problem**: Direct test has confidence 0.7, indirect test has 0.8
++-++**Root Cause**: Scoring algorithm may be inverted or considering other factors
++-++**Evidence**: NUnitTestDiscoveryTests.DirectTest should have higher confidence than IntegrationTests.IndirectTest
++-++
++-++### Recommended Fixes
++-++
++-++1. **Call Graph Depth**: Increase traversal depth for integration tests
++-++2. **Filter Logic**: Review test filtering criteria to include indirect callers
++-++3. **Name Resolution**: Improve method name matching to avoid false positives
++-++4. **Confidence Scoring**: Review algorithm to properly weight direct vs indirect calls
++-++
++-++### Next Steps
++-++1. Apply debug fixes to core components
++-++2. Re-run debug session to validate improvements
++-++3. Add unit tests for edge cases discovered
++-++4. Update documentation with known limitations
++-++```
++-++
++-++### Step 8: Fix Issues Found
++-++
++-++**CRITICAL**: After identifying issues through debugging, you MUST implement fixes for all problems discovered.
++-++
++-++#### 8.1 Apply Fixes Based on Root Cause Analysis
++-++
++-++Based on the issues identified in the debug report, implement the following fixes:
++-++
++-++**Fix #1: Call Graph Depth Issues**
++-++```bash
++-++echo "üîß Fixing call graph traversal depth..."
++-++
++-++# Edit the call graph construction to increase depth limit
++-++# Look for depth limiting code in TestMethodMapper or CallGraphBuilder
++-++grep -r "depth\|limit" src/TestIntelligence.Core/ --include="*.cs" -n
++-++
++-++# Implement fix - example:
++-++# Change: const int MAX_DEPTH = 3;
++-++# To:     const int MAX_DEPTH = 5;
++-++```
++-++
++-++**Fix #2: Test Filtering Logic**
++-++```bash
++-++echo "üîß Fixing test filtering to include indirect callers..."
++-++
++-++# Find and fix the test filtering logic
++-++# Look for filtering criteria that might be too restrictive
++-++grep -r "filter\|where.*confidence\|threshold" src/TestIntelligence.Core/ --include="*.cs" -A 3 -B 3
++-++```
++-++
++-++**Fix #3: Confidence Score Algorithm**
++-++```bash
++-++echo "üîß Fixing confidence scoring algorithm..."
++-++
++-++# Locate confidence scoring logic
++-++grep -r "confidence.*score\|calculateConfidence" src/TestIntelligence.Core/ --include="*.cs" -n
++-++
++-++# Review and fix scoring to properly weight:
++-++# - Direct calls: Higher confidence (0.8-1.0)
++-++# - One-hop indirect: Medium confidence (0.6-0.8)  
++-++# - Multi-hop indirect: Lower confidence (0.3-0.6)
++-++# - No relation: Very low confidence (0.0-0.2)
++-++```
++-++
++-++**Fix #4: False Positive Prevention**
++-++```bash
++-++echo "üîß Implementing false positive detection..."
++-++
++-++# Add stricter validation for method relationships
++-++# Implement additional verification steps before including tests
++-++```
++-++
++-++#### 8.2 Implement Specific Code Changes
++-++
++-++For each identified issue, make the actual code changes:
++-++
++-++```bash
++-++echo "üìù Implementing code fixes..."
++-++
++-++# Example fix for call graph depth
++-++# Find the relevant file and implement the change
++-++# Use Edit tool to modify the source code with the fix
++-++```
++-++
++-++#### 8.3 Validate Fixes
++-++
++-++After implementing fixes, validate they work:
++-++
++-++```bash
++-++echo "‚úÖ Validating fixes..."
++-++
++-++# Rebuild the solution
++-++dotnet build
++-++
++-++# Clear cache to ensure fresh analysis
++-++dotnet run --project src/TestIntelligence.CLI cache \
++-++  --solution TestIntelligence.sln \
++-++  --action clear
++-++
++-++# Re-run the find-tests command to verify improvements
++-++dotnet run --project src/TestIntelligence.CLI find-tests \
++-++  --method "TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync" \
++-++  --solution TestIntelligence.sln \
++-++  --format json \
++-++  --output fixed-find-tests-result.json \
++-++  --verbose
++-++
++-++echo "üîç Comparing before/after results..."
++-++# Compare original debug results with fixed results
++-++echo "Before fix - tests found: $(jq '.foundTests | length' debug-find-tests-result.json)"
++-++echo "After fix - tests found: $(jq '.foundTests | length' fixed-find-tests-result.json)"
++-++
++-++# Verify specific issues were resolved:
++-++echo "Checking if missing integration tests are now found..."
++-++echo "Checking if false positives were eliminated..."
++-++echo "Checking if confidence scores are more accurate..."
++-++```
++-++
++-++#### 8.4 Run Comprehensive Tests
++-++
++-++Ensure fixes don't break other functionality:
++-++
++-++```bash
++-++echo "üß™ Running comprehensive tests after fixes..."
++-++
++-++# Run all relevant tests
++-++dotnet test tests/TestIntelligence.Core.Tests/ -v normal
++-++dotnet test tests/TestIntelligence.ImpactAnalyzer.Tests/ -v normal
++-++
++-++# Test with different target methods to ensure general improvement
++-++dotnet run --project src/TestIntelligence.CLI find-tests \
++-++  --method "TestIntelligence.Core.TestAnalyzer.AnalyzeAssembly" \
++-++  --solution TestIntelligence.sln \
++-++  --output validation-test-2.json
++-++
++-++dotnet run --project src/TestIntelligence.CLI find-tests \
++-++  --method "TestIntelligence.DataTracker.DatabaseAnalyzer.AnalyzeDependencies" \
++-++  --solution TestIntelligence.sln \
++-++  --output validation-test-3.json
++-++```
++-++
++-++### Step 9: Cleanup and Restoration
++-++
++-++```bash
++-++echo "üßπ Cleaning up debug modifications..."
++-++
++-++# Restore original files (debug tracing code)
++-++mv src/TestIntelligence.CLI/Commands/FindTestsCommand.cs.debug-backup src/TestIntelligence.CLI/Commands/FindTestsCommand.cs
++-++mv src/TestIntelligence.Core/Services/TestMethodMapper.cs.debug-backup src/TestIntelligence.Core/Services/TestMethodMapper.cs
++-++
++-++# Keep debug logs and results for reference
++-++mkdir -p debug-logs
++-++mv debug-find-tests-trace.log debug-logs/
++-++mv debug-find-tests-result.json debug-logs/
++-++mv fixed-find-tests-result.json debug-logs/
++-++mv debug-callgraph.json debug-logs/
++-++mv validation-test-*.json debug-logs/
++-++
++-++echo "‚úÖ Debug session complete with fixes applied. Logs saved to debug-logs/"
++-++```
++-++
++-++## Usage Instructions for Claude
++-++
++-++When running this debug command, you MUST:
++-++
++-++1. **Be systematic** - Follow each debug step to identify the exact failure point
++-++2. **Preserve evidence** - Save all debug output and manual verification results
++-++3. **Compare exhaustively** - Cross-reference CLI results with manual code analysis
++-++4. **Focus on root causes** - Don't just identify symptoms, trace to underlying issues
++-++5. **Document thoroughly** - Create detailed reports to help fix the underlying problems
++-++6. **IMPLEMENT FIXES** - Actually modify the source code to resolve identified issues
++-++7. **Validate fixes** - Re-run debug session and tests after applying fixes
++-++8. **Test comprehensively** - Ensure fixes don't break other functionality
++-++
++-++**CRITICAL REQUIREMENT**: This command is not complete until you have:
++-++- ‚úÖ Identified all issues through debugging
++-++- ‚úÖ Implemented code fixes for each identified problem
++-++- ‚úÖ Validated that fixes resolve the issues
++-++- ‚úÖ Confirmed no regressions were introduced
++-++- ‚úÖ Updated any relevant tests or documentation
++-++
++-++This debug-and-fix approach will not only identify where the find-tests command is failing but will also resolve those issues to improve the overall accuracy and reliability of the TestIntelligence library.
++-+\ No newline at end of file
++-+diff --git a/.claude/commands/test-analyze-coverage.md b/.claude/commands/test-analyze-coverage.md
++-+new file mode 100644
++-+index 0000000..9eb3bdc
++-+--- /dev/null
++-++++ b/.claude/commands/test-analyze-coverage.md
++-+@@ -0,0 +1,187 @@
++-++# Test Analyze Coverage Command
++-++
++-++Instructions for Claude to test the analyze-coverage command by selecting test methods and verifying how well they cover code changes.
++-++
++-++## Testing Protocol
++-++
++-++### Step 1: Create Test Scenario
++-++1. **Select Target Tests**: Choose 2-3 test methods from different test projects:
++-++   - Pick tests that exercise different parts of the codebase
++-++   - Include both unit tests and integration tests
++-++   - Choose tests you can manually trace through
++-++
++-++2. **Create Mock Changes**: Generate a git diff to analyze:
++-++   ```bash
++-++   # Option A: Create actual changes and diff them
++-++   echo "// Test change" >> src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
++-++   git add -A
++-++   git diff --cached > test-changes.patch
++-++   git reset HEAD
++-++   
++-++   # Option B: Use existing git history
++-++   git diff HEAD~1 > recent-changes.patch
++-++   ```
++-++
++-++### Step 2: Run the Analyze-Coverage Command
++-++```bash
++-++dotnet run --project src/TestIntelligence.CLI analyze-coverage \
++-++  --solution TestIntelligence.sln \
++-++  --tests "TestClass1.TestMethod1" "TestClass2.TestMethod2" "TestClass3.TestMethod3" \
++-++  --git-command "diff HEAD~1" \
++-++  --verbose \
++-++  --output coverage-analysis.json
++-++```
++-++
++-++Alternative with diff file:
++-++```bash
++-++dotnet run --project src/TestIntelligence.CLI analyze-coverage \
++-++  --solution TestIntelligence.sln \
++-++  --tests "TestClass1.TestMethod1" "TestClass2.TestMethod2" \
++-++  --diff-file test-changes.patch \
++-++  --verbose \
++-++  --output coverage-analysis.json
++-++```
++-++
++-++### Step 3: Manual Verification Process
++-++
++-++#### 3.1 Analyze the Output
++-++1. **Read Coverage Report**: Examine JSON results for:
++-++   - Coverage percentage for each test
++-++   - List of changed methods/classes covered by each test
++-++   - Uncovered changes identified
++-++   - Overall coverage metrics
++-++
++-++2. **Understand Change Set**: Review the git diff to identify:
++-++   - Which files were modified
++-++   - Which methods/classes were changed
++-++   - Nature of changes (new code, modifications, deletions)
++-++
++-++#### 3.2 Manual Coverage Verification
++-++For each test method:
++-++
++-++1. **Trace Test Execution**:
++-++   - Read the test method source code
++-++   - Follow all method calls made by the test
++-++   - Map the execution path through the codebase
++-++
++-++2. **Match Against Changes**:
++-++   - Compare test execution path with changed code
++-++   - Identify which changed methods/classes the test actually exercises
++-++   - Note any changed code the test doesn't reach
++-++
++-++3. **Validate Coverage Calculation**:
++-++   - Count changed methods covered vs. total changed methods
++-++   - Verify the coverage percentage is mathematically correct
++-++   - Check if the analysis missed any coverage or overcounted
++-++
++-++#### 3.3 Gap Analysis
++-++1. **Identify Uncovered Changes**:
++-++   - Find changed code not exercised by any of the selected tests
++-++   - Verify these are truly uncovered (not false negatives)
++-++
++-++2. **Find Coverage Gaps**:
++-++   - Look for changed code that should be covered but isn't
++-++   - Search for additional tests that might cover the gaps
++-++
++-++### Step 4: Verification Commands
++-++
++-++```bash
++-++# Search for tests that might cover a specific changed class
++-++grep -r "ChangedClassName" tests/ --include="*.cs" -l
++-++
++-++# Look at specific changed file to understand modifications
++-++git show HEAD~1:src/path/to/ChangedFile.cs | diff - src/path/to/ChangedFile.cs
++-++
++-++# Find all tests in a specific test class
++-++grep -n "\[Test\]\|\[Fact\]\|\[TestMethod\]" tests/path/to/TestClass.cs
++-++
++-++# Trace method usage across the codebase
++-++grep -r "ChangedMethodName" src/ --include="*.cs"
++-++```
++-++
++-++### Step 5: Sample Verification Report Format
++-++
++-++```
++-++## Analyze-Coverage Verification Report
++-++
++-++**Test Scenario**:
++-++- Selected Tests: 3 tests from Core and DataTracker projects
++-++- Change Set: Modified NUnitTestDiscovery.cs and TestAnalyzer.cs (8 methods changed)
++-++- Git Command: `diff HEAD~1`
++-++
++-++**CLI Output Summary**:
++-++- Test1 Coverage: 75% (6/8 changed methods)
++-++- Test2 Coverage: 25% (2/8 changed methods)  
++-++- Test3 Coverage: 0% (0/8 changed methods)
++-++- Overall Coverage: 87.5% (7/8 changed methods covered by at least one test)
++-++
++-++**Manual Verification**:
++-++
++-++‚úÖ **Test1: NUnitTestDiscoveryTests.DiscoverTestsAsync_ValidAssembly**
++-++   - Claimed Coverage: 75% (6/8 methods)
++-++   - Manual Trace: Calls NUnitTestDiscovery.DiscoverTestsAsync ‚Üí LoadAssembly ‚Üí ProcessTypes ‚Üí ExtractAttributes
++-++   - Actually Covers: NUnitTestDiscovery.DiscoverTestsAsync, LoadAssembly, ProcessTypes, ExtractAttributes, ValidateTest, FormatResults (6/8) ‚úÖ
++-++   - Coverage calculation: Correct
++-++
++-++‚úÖ **Test2: TestAnalyzerTests.AnalyzeFullSolution**  
++-++   - Claimed Coverage: 25% (2/8 methods)
++-++   - Manual Trace: Calls TestAnalyzer.AnalyzeAssembly ‚Üí NUnitTestDiscovery.DiscoverTestsAsync ‚Üí LoadAssembly
++-++   - Actually Covers: AnalyzeAssembly, DiscoverTestsAsync (2/8) ‚úÖ
++-++   - Coverage calculation: Correct
++-++
++-++‚ö†Ô∏è **Test3: DataTrackerTests.SomeUnrelatedTest**
++-++   - Claimed Coverage: 0% (0/8 methods)
++-++   - Manual Trace: Only exercises database tracking functionality
++-++   - Actually Covers: None of the changed methods ‚úÖ
++-++   - Coverage calculation: Correct (true negative)
++-++
++-++**Uncovered Changes Verification**:
++-++‚úÖ **TestAnalyzer.ValidateConfiguration** - Correctly identified as uncovered
++-++   - No selected tests call this method
++-++   - Manually confirmed by searching test codebase
++-++
++-++‚ùå **Missing Coverage Detection**:
++-++   - Found integration test `FullPipelineTests.CompleteAnalysis` that exercises ValidateConfiguration
++-++   - This test wasn't in the selected set but would provide coverage
++-++   - CLI correctly reported method as uncovered for the selected tests
++-++
++-++**Overall Accuracy**: 100% - All coverage calculations verified as correct
++-++**Coverage Gap Analysis**: 1/8 methods uncovered by selected tests (12.5% gap)
++-++
++-++**Recommendations**: 
++-++- Coverage analysis is mathematically accurate
++-++- Consider expanding test selection to include integration tests for better coverage
++-++- The uncovered method has tests available but weren't in the analyzed set
++-++```
++-++
++-++### Additional Verification Scenarios
++-++
++-++#### Scenario A: High Coverage Test Set
++-++Select tests known to exercise broad functionality:
++-++- Integration tests
++-++- End-to-end workflow tests  
++-++- Tests that call multiple components
++-++
++-++#### Scenario B: Low Coverage Test Set
++-++Select very focused unit tests:
++-++- Tests that only exercise one method
++-++- Isolated component tests
++-++- Mock-heavy tests with limited real code execution
++-++
++-++#### Scenario C: Mixed Framework Changes
++-++Create changes spanning multiple projects:
++-++- Core library changes
++-++- CLI command changes
++-++- Test framework changes
++-++
++-++## Usage Instructions for Claude
++-++
++-++When running this command:
++-++1. **Be methodical** - actually trace through test execution paths
++-++2. **Verify math** - check that coverage percentages are calculated correctly
++-++3. **Look for edge cases** - tests that might have unexpected coverage patterns
++-++4. **Consider test types** - unit vs integration tests may have different coverage patterns
++-++5. **Cross-reference** - use grep/search to validate coverage claims
++-++6. **Report thoroughly** - document both correct results and any discrepancies found
++-++
++-++This testing ensures the analyze-coverage command accurately maps test execution to code changes, which is critical for intelligent test selection and impact analysis.
++-+\ No newline at end of file
++-+diff --git a/.claude/commands/test-and-commit.md b/.claude/commands/test-and-commit.md
++-+new file mode 100644
++-+index 0000000..9db3c91
++-+--- /dev/null
++-++++ b/.claude/commands/test-and-commit.md
++-+@@ -0,0 +1,39 @@
++-++# Test and Commit
++-++
++-++Run all non-E2E tests, fix any issues found, and commit/push if all tests pass.
++-++
++-++## Command
++-++
++-++```bash
++-++# Run all tests except E2E tests
++-++dotnet test --filter "Category!=E2E" --verbosity normal
++-++
++-++# If tests fail, Claude will analyze and fix the issues
++-++# If all tests pass, commit and push changes
++-++if [ $? -eq 0 ]; then
++-++  echo "All tests passed! Committing and pushing changes..."
++-++  git add .
++-++  git commit -m "$(cat <<'EOF'
++-++Fix test issues and update codebase
++-++
++-++All non-E2E tests are now passing.
++-++
++-++ü§ñ Generated with [Claude Code](https://claude.ai/code)
++-++
++-++Co-Authored-By: Claude <noreply@anthropic.com>
++-++EOF
++-++)"
++-++  git push
++-++else
++-++  echo "Tests failed. Claude will analyze and fix the issues."
++-++fi
++-++```
++-++
++-++## Usage
++-++
++-++Run this command when you want to:
++-++1. Execute all tests except E2E tests
++-++2. Have Claude automatically fix any test failures
++-++3. Commit and push changes if all tests pass
++-++
++-++This command ensures your codebase maintains test quality while automating the commit process for successful test runs.
++-+\ No newline at end of file
++-+diff --git a/.claude/commands/test-find-tests.md b/.claude/commands/test-find-tests.md
++-+new file mode 100644
++-+index 0000000..89bb827
++-+--- /dev/null
++-++++ b/.claude/commands/test-find-tests.md
++-+@@ -0,0 +1,103 @@
++-++# Test Find-Tests Command
++-++
++-++Instructions for Claude to test the find-tests command by selecting a random method and verifying the output accuracy.
++-++
++-++## Testing Protocol
++-++
++-++### Step 1: Select a Random Method
++-++1. Use `find` or `grep` to discover methods in the src/ directory
++-++2. Pick a method from a Core, Categorizer, DataTracker, ImpactAnalyzer, or SelectionEngine class
++-++3. Choose a method that's likely to be tested (public methods, important functionality)
++-++
++-++### Step 2: Run the Find-Tests Command
++-++```bash
++-++dotnet run --project src/TestIntelligence.CLI find-tests \
++-++  --method "FullNamespace.ClassName.MethodName" \
++-++  --solution TestIntelligence.sln \
++-++  --format json \
++-++  --output find-tests-result.json \
++-++  --verbose
++-++```
++-++
++-++### Step 3: Manual Verification Process
++-++1. **Read the Output**: Examine the JSON results for:
++-++   - List of test methods that allegedly exercise the target method
++-++   - Confidence scores for each test
++-++   - Call path depth information
++-++
++-++2. **Code Analysis**: For each test found:
++-++   - Read the test method source code
++-++   - Trace through the test execution path
++-++   - Verify the test actually calls (directly or indirectly) the target method
++-++   - Check if the confidence score seems reasonable based on call depth
++-++
++-++3. **Completeness Check**: 
++-++   - Search the test codebase for the target method name
++-++   - Look for any tests that should have been found but weren't
++-++   - Verify no false positives (tests that don't actually exercise the method)
++-++
++-++4. **Report Results**:
++-++   - Summarize accuracy: "X out of Y tests correctly identified"
++-++   - Note any false positives or missed tests
++-++   - Comment on confidence score appropriateness
++-++   - Highlight any patterns or issues discovered
++-++
++-++### Step 4: Sample Commands to Help with Verification
++-++
++-++```bash
++-++# Search for direct method calls in tests
++-++grep -r "MethodName" tests/ --include="*.cs"
++-++
++-++# Search for class usage in tests
++-++grep -r "ClassName" tests/ --include="*.cs"
++-++
++-++# Look at specific test file
++-++cat tests/path/to/TestClass.cs
++-++```
++-++
++-++### Example Verification Report Format
++-++
++-++```
++-++## Find-Tests Verification Report
++-++
++-++**Target Method**: TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync
++-++
++-++**CLI Output Summary**:
++-++- Found: 5 tests
++-++- Confidence scores: High(2), Medium(2), Low(1)
++-++
++-++**Manual Verification**:
++-++‚úÖ TestIntelligence.Core.Tests.Discovery.NUnitTestDiscoveryTests.DiscoverTestsAsync_ValidAssembly_ReturnsTests
++-++   - Directly calls target method
++-++   - Confidence: High (appropriate)
++-++
++-++‚úÖ TestIntelligence.Core.Tests.TestAnalyzerTests.AnalyzeAssembly_WithNUnitTests_IncludesNUnitTests  
++-++   - Calls TestAnalyzer.AnalyzeAssembly which calls target method
++-++   - Confidence: Medium (appropriate for 1-hop call)
++-++
++-++‚ùå TestIntelligence.SelectionEngine.Tests.SomeUnrelatedTest
++-++   - False positive - doesn't actually call target method
++-++   - Issue: Possible name collision or incorrect call graph
++-++
++-++**Missing Tests**:
++-++- TestIntelligence.Core.Tests.Integration.FullAnalysisTests.CompleteAnalysis
++-++  - This test exercises the full pipeline including the target method
++-++  - Should have been found with Low confidence
++-++
++-++**Overall Accuracy**: 4/5 correct (80%)
++-++**Recommendations**: 
++-++- Investigate false positive detection
++-++- Review call graph completeness for integration tests
++-++```
++-++
++-++## Usage Instructions for Claude
++-++
++-++When running this command:
++-++1. Be thorough in your verification - actually read the test code
++-++2. Don't just trust the CLI output - verify by examining source code
++-++3. Look for both false positives and false negatives
++-++4. Consider the appropriateness of confidence scores
++-++5. Report your findings in a clear, structured format
++-++6. If you find issues, suggest potential causes or improvements
++-++
++-++This testing helps ensure the find-tests command is working accurately and can be trusted for real-world usage.
++-+\ No newline at end of file
++-+diff --git a/.claude/commands/test-select.md b/.claude/commands/test-select.md
++-+new file mode 100644
++-+index 0000000..dcb866c
++-+--- /dev/null
++-++++ b/.claude/commands/test-select.md
++-+@@ -0,0 +1,278 @@
++-++# Test Select Command
++-++
++-++Instructions for Claude to test the select command by creating code changes and verifying intelligent test selection accuracy across different confidence levels.
++-++
++-++## Testing Protocol
++-++
++-++### Step 1: Create Test Scenarios
++-++
++-++#### Scenario A: Single File Change (Core Component)
++-++```bash
++-++# Make a targeted change to a core component
++-++cp src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs.backup
++-++echo "        // Test change for select command validation" >> src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
++-++```
++-++
++-++#### Scenario B: Multi-File Change (Cross-Component)
++-++```bash
++-++# Make changes across multiple components
++-++echo "        // Cross-component change test" >> src/TestIntelligence.Core/TestAnalyzer.cs
++-++echo "        // Related CLI change" >> src/TestIntelligence.CLI/Commands/AnalyzeCommand.cs
++-++```
++-++
++-++#### Scenario C: Interface/Contract Change
++-++```bash
++-++# Modify an interface or base class that affects multiple implementations
++-++echo "        // Interface change affecting multiple implementations" >> src/TestIntelligence.Core/Interfaces/ITestDiscovery.cs
++-++```
++-++
++-++### Step 2: Test Different Confidence Levels
++-++
++-++#### 2.1 Fast Confidence (30 sec, 70% confidence)
++-++```bash
++-++dotnet run --project src/TestIntelligence.CLI select \
++-++  --path TestIntelligence.sln \
++-++  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" \
++-++  --confidence Fast \
++-++  --max-tests 20 \
++-++  --output select-fast.json \
++-++  --verbose
++-++```
++-++
++-++#### 2.2 Medium Confidence (5 min, 85% confidence)  
++-++```bash
++-++dotnet run --project src/TestIntelligence.CLI select \
++-++  --path TestIntelligence.sln \
++-++  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" \
++-++  --confidence Medium \
++-++  --max-tests 50 \
++-++  --output select-medium.json \
++-++  --verbose
++-++```
++-++
++-++#### 2.3 High Confidence (15 min, 95% confidence)
++-++```bash
++-++dotnet run --project src/TestIntelligence.CLI select \
++-++  --path TestIntelligence.sln \
++-++  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" \
++-++  --confidence High \
++-++  --max-tests 100 \
++-++  --output select-high.json \
++-++  --verbose
++-++```
++-++
++-++#### 2.4 Full Confidence (Complete suite, 100% confidence)
++-++```bash
++-++dotnet run --project src/TestIntelligence.CLI select \
++-++  --path TestIntelligence.sln \
++-++  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" \
++-++  --confidence Full \
++-++  --output select-full.json \
++-++  --verbose
++-++```
++-++
++-++### Step 3: Manual Verification Process
++-++
++-++#### 3.1 Analyze Selection Results
++-++For each confidence level, examine:
++-++1. **Number of tests selected**
++-++2. **Test categories included** (Unit, Integration, Database, API, UI)
++-++3. **Confidence scores** for each selected test
++-++4. **Execution time estimates**
++-++5. **Tests organized by priority/relevance**
++-++
++-++#### 3.2 Validate Test Selection Logic
++-++
++-++**Direct Impact Tests (Should be in Fast)**:
++-++```bash
++-++# Find tests that directly test the changed class
++-++grep -r "NUnitTestDiscovery" tests/ --include="*.cs" -l
++-++# These should appear in Fast confidence with high scores
++-++```
++-++
++-++**Indirect Impact Tests (Should be in Medium)**:
++-++```bash
++-++# Find tests that use classes that depend on the changed class
++-++grep -r "TestAnalyzer\|Discovery" tests/ --include="*.cs" -l
++-++# These should appear in Medium confidence with medium scores
++-++```
++-++
++-++**Integration Tests (Should be in High)**:
++-++```bash
++-++# Find integration tests that exercise the full pipeline
++-++grep -r "Integration\|EndToEnd\|FullPipeline" tests/ --include="*.cs" -l
++-++# These should appear in High confidence with lower scores
++-++```
++-++
++-++#### 3.3 Confidence Level Validation
++-++
++-++Verify that each confidence level follows the expected pattern:
++-++- **Fast ‚äÇ Medium ‚äÇ High ‚äÇ Full** (each level includes previous levels)
++-++- **Decreasing relevance scores** as confidence level increases
++-++- **Appropriate test count limits** respected
++-++- **Time estimates** align with confidence level targets
++-++
++-++### Step 4: Cross-Reference with Other Commands
++-++
++-++#### 4.1 Verify Against Find-Tests
++-++```bash
++-++# For each selected test, verify it actually relates to the changed code
++-++dotnet run --project src/TestIntelligence.CLI find-tests \
++-++  --method "TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync" \
++-++  --solution TestIntelligence.sln \
++-++  --output find-tests-cross-check.json
++-++```
++-++
++-++#### 4.2 Verify Against Coverage Analysis
++-++```bash
++-++# Check if selected tests actually provide good coverage of changes
++-++dotnet run --project src/TestIntelligence.CLI analyze-coverage \
++-++  --solution TestIntelligence.sln \
++-++  --tests $(jq -r '.selectedTests[].testName' select-medium.json | tr '\n' ' ') \
++-++  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" \
++-++  --output coverage-cross-check.json
++-++```
++-++
++-++### Step 5: Sample Verification Report Format
++-++
++-++```
++-++## Select Command Verification Report
++-++
++-++**Test Scenario**: Modified NUnitTestDiscovery.cs (single method change)
++-++**Change Type**: Core component modification affecting test discovery logic
++-++
++-++### Confidence Level Analysis
++-++
++-++#### Fast Confidence (Target: 30 sec, 70% confidence)
++-++- **Selected**: 8 tests
++-++- **Time Estimate**: 25 seconds ‚úÖ
++-++- **Categories**: Unit (6), Integration (2)
++-++- **Top Tests**:
++-++  ‚úÖ NUnitTestDiscoveryTests.DiscoverTestsAsync_ValidAssembly (Score: 0.95)
++-++  ‚úÖ NUnitTestDiscoveryTests.DiscoverTestsAsync_EmptyAssembly (Score: 0.92)  
++-++  ‚úÖ TestAnalyzerTests.AnalyzeAssembly_WithNUnitTests (Score: 0.78)
++-++
++-++#### Medium Confidence (Target: 5 min, 85% confidence)  
++-++- **Selected**: 23 tests (includes all Fast + 15 more) ‚úÖ
++-++- **Time Estimate**: 4.2 minutes ‚úÖ
++-++- **Categories**: Unit (15), Integration (6), Database (2)
++-++- **Additional Tests**:
++-++  ‚úÖ CoreIntegrationTests.FullDiscoveryPipeline (Score: 0.65)
++-++  ‚úÖ MultiFrameworkTests.NUnitAndXUnit (Score: 0.58)
++-++
++-++#### High Confidence (Target: 15 min, 95% confidence)
++-++- **Selected**: 47 tests (includes all Medium + 24 more) ‚úÖ  
++-++- **Time Estimate**: 12.8 minutes ‚úÖ
++-++- **Categories**: Unit (25), Integration (15), Database (4), API (3)
++-++- **Additional Tests**:
++-++  ‚úÖ E2ETests.CompleteAnalysisWorkflow (Score: 0.35)
++-++  ‚ö†Ô∏è UnrelatedUITests.SomeUITest (Score: 0.12) - Questionable relevance
++-++
++-++#### Full Confidence
++-++- **Selected**: All 215 tests ‚úÖ
++-++- **Includes**: Every test in the solution
++-++
++-++### Manual Verification Results
++-++
++-++#### Direct Impact Validation ‚úÖ
++-++**Expected**: Tests that directly call NUnitTestDiscovery methods
++-++- Found 6 direct tests in TestIntelligence.Core.Tests
++-++- All 6 appeared in Fast confidence with scores > 0.8 ‚úÖ
++-++- Scores appropriately reflect call directness ‚úÖ
++-++
++-++#### Indirect Impact Validation ‚úÖ  
++-++**Expected**: Tests that call TestAnalyzer which uses NUnitTestDiscovery
++-++- Found 8 indirect tests across Core and CLI test projects
++-++- 7/8 appeared in Medium confidence ‚úÖ
++-++- 1 missing test: CLIIntegrationTests.AnalyzeCommand_WithNUnit ‚ùå
++-++- Scores appropriately lower (0.5-0.8 range) ‚úÖ
++-++
++-++#### Integration Test Validation ‚ö†Ô∏è
++-++**Expected**: End-to-end tests that exercise full discovery pipeline  
++-++- Found 12 integration tests
++-++- 10/12 appeared in High confidence ‚úÖ
++-++- 2 missing: PerformanceTests.LargeSolutionAnalysis, StressTests.ConcurrentDiscovery ‚ùå
++-++- Some questionable inclusions with very low relevance scores
++-++
++-++### Cross-Reference Validation
++-++
++-++#### Find-Tests Cross-Check ‚úÖ
++-++- Selected tests from Fast confidence all verified via find-tests command
++-++- No false positives detected in direct impact tests
++-++- Confidence scores align between select and find-tests commands
++-++
++-++#### Coverage Analysis Cross-Check ‚ö†Ô∏è
++-++- Medium confidence tests provide 78% coverage of changed code
++-++- Expected: ~85% based on confidence level target
++-++- Gap: Some edge cases in error handling not covered by selected tests
++-++- Recommendation: Include additional error handling tests
++-++
++-++### Selection Logic Assessment
++-++
++-++**Strengths**:
++-++- ‚úÖ Confidence levels properly nested (Fast ‚äÇ Medium ‚äÇ High ‚äÇ Full)
++-++- ‚úÖ Time estimates realistic and within targets
++-++- ‚úÖ Direct impact tests correctly prioritized
++-++- ‚úÖ Test categories appropriately distributed
++-++- ‚úÖ Relevance scores generally accurate
++-++
++-++**Issues Found**:
++-++- ‚ùå 2 high-relevance tests missed in Medium confidence
++-++- ‚ùå Some very low relevance tests included in High confidence  
++-++- ‚ùå Coverage gap vs confidence level expectations
++-++
++-++**Overall Accuracy**: 85% - Good test selection with minor gaps
++-++**Recommendation**: 
++-++- Review inclusion threshold for High confidence
++-++- Investigate why 2 relevant tests were missed
++-++- Consider adjusting relevance scoring for integration tests
++-++```
++-++
++-++### Advanced Test Scenarios
++-++
++-++#### Scenario D: Configuration Change Impact
++-++```bash
++-++# Test with configuration/settings changes that might affect many components
++-++echo "    // Configuration change" >> src/TestIntelligence.Core/Configuration/AnalysisSettings.cs
++-++```
++-++
++-++#### Scenario E: Multiple File Changes
++-++```bash  
++-++# Test selection with multiple related changes
++-++dotnet run --project src/TestIntelligence.CLI select \
++-++  --path TestIntelligence.sln \
++-++  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" "src/TestIntelligence.Core/TestAnalyzer.cs" \
++-++  --confidence Medium \
++-++  --output select-multifile.json
++-++```
++-++
++-++#### Scenario F: Max Tests Constraint
++-++```bash
++-++# Test that max-tests parameter is respected
++-++dotnet run --project src/TestIntelligence.CLI select \
++-++  --path TestIntelligence.sln \
++-++  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" \
++-++  --confidence High \
++-++  --max-tests 10 \
++-++  --output select-constrained.json
++-++```
++-++
++-++### Cleanup
++-++```bash
++-++# Restore original files after testing
++-++mv src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs.backup src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
++-++git checkout -- src/TestIntelligence.Core/TestAnalyzer.cs src/TestIntelligence.CLI/Commands/AnalyzeCommand.cs
++-++```
++-++
++-++## Usage Instructions for Claude
++-++
++-++When running this command:
++-++1. **Test all confidence levels** - verify the nested relationship and appropriateness
++-++2. **Validate time estimates** - check if they align with confidence level targets  
++-++3. **Cross-reference results** - use find-tests and analyze-coverage to verify selections
++-++4. **Check edge cases** - test with multiple files, constraints, and different change types
++-++5. **Assess relevance scoring** - ensure tests are ranked appropriately by impact likelihood
++-++6. **Verify completeness** - look for missing tests that should be included
++-++7. **Report systematically** - document accuracy, gaps, and recommendations
++-++
++-++This testing ensures the select command provides intelligent, accurate test selection that balances coverage with execution efficiency across different confidence levels.
++-+\ No newline at end of file
++-+diff --git a/Directory.Build.props b/Directory.Build.props
++-+index 14da534..fe3608c 100644
++-+--- a/Directory.Build.props
++-++++ b/Directory.Build.props
++-+@@ -10,7 +10,7 @@
++-+     <LangVersion>latest</LangVersion>
++-+     <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
++-+     <WarningsAsErrors />
++-+-    <WarningsNotAsErrors>NU1605;NU1701</WarningsNotAsErrors>
++-++    <WarningsNotAsErrors>NU1605;NU1701;MSB3277</WarningsNotAsErrors>
++-+     
++-+     <!-- Common package metadata -->
++-+     <Authors>TestIntelligence Contributors</Authors>
++-+diff --git a/src/TestIntelligence.CLI/Commands/BaseCommandHandler.cs b/src/TestIntelligence.CLI/Commands/BaseCommandHandler.cs
++-+index 3118751..5892681 100644
++-+--- a/src/TestIntelligence.CLI/Commands/BaseCommandHandler.cs
++-++++ b/src/TestIntelligence.CLI/Commands/BaseCommandHandler.cs
++-+@@ -35,28 +35,113 @@ namespace TestIntelligence.CLI.Commands
++-+             catch (OperationCanceledException)
++-+             {
++-+                 Logger.LogInformation("Command execution was cancelled");
++-+-                return 1;
++-++                Console.Error.WriteLine("Operation was cancelled by user.");
++-++                return 130; // Standard exit code for cancelled operations
++-+             }
++-+             catch (ArgumentException ex)
++-+             {
++-+                 Logger.LogError(ex, "Invalid arguments provided to command");
++-+-                Console.Error.WriteLine($"Error: {ex.Message}");
++-++                Console.Error.WriteLine($"‚ùå Invalid argument: {ex.Message}");
++-++                PrintUsageHint(context);
++-+                 return 1;
++-+             }
++-++            catch (FileNotFoundException ex)
++-++            {
++-++                Logger.LogError(ex, "Required file not found");
++-++                Console.Error.WriteLine($"‚ùå File not found: {ex.FileName ?? ex.Message}");
++-++                Console.Error.WriteLine("Please verify that the file path is correct and accessible.");
++-++                return 2;
++-++            }
++-++            catch (DirectoryNotFoundException ex)
++-++            {
++-++                Logger.LogError(ex, "Required directory not found");
++-++                Console.Error.WriteLine($"‚ùå Directory not found: {ex.Message}");
++-++                Console.Error.WriteLine("Please verify that the directory path is correct and accessible.");
++-++                return 2;
++-++            }
++-++            catch (UnauthorizedAccessException ex)
++-++            {
++-++                Logger.LogError(ex, "Access denied to file or directory");
++-++                Console.Error.WriteLine($"‚ùå Access denied: {ex.Message}");
++-++                Console.Error.WriteLine("Please check file/directory permissions or run with appropriate privileges.");
++-++                return 13; // Standard exit code for permission denied
++-++            }
++-++            catch (TimeoutException ex)
++-++            {
++-++                Logger.LogError(ex, "Operation timed out");
++-++                Console.Error.WriteLine($"‚ùå Operation timed out: {ex.Message}");
++-++                Console.Error.WriteLine("The operation took longer than expected. Try reducing the scope or running again.");
++-++                return 124; // Standard exit code for timeout
++-++            }
++-++            catch (System.IO.FileLoadException ex) when (ex.Message.Contains("Microsoft.Bcl.AsyncInterfaces"))
++-++            {
++-++                Logger.LogError(ex, "Assembly loading conflict detected");
++-++                Console.Error.WriteLine("‚ùå Assembly conflict detected:");
++-++                Console.Error.WriteLine($"   {ex.Message}");
++-++                Console.Error.WriteLine();
++-++                Console.Error.WriteLine("üí° This is usually caused by conflicting package versions. Try:");
++-++                Console.Error.WriteLine("   ‚Ä¢ Clearing NuGet cache: dotnet nuget locals all --clear");
++-++                Console.Error.WriteLine("   ‚Ä¢ Rebuilding the solution: dotnet clean && dotnet build");
++-++                Console.Error.WriteLine("   ‚Ä¢ Updating packages to consistent versions");
++-++                return 125; // Custom exit code for assembly conflicts
++-++            }
++-++            catch (System.Reflection.ReflectionTypeLoadException ex)
++-++            {
++-++                Logger.LogError(ex, "Failed to load types from assembly");
++-++                Console.Error.WriteLine("‚ùå Failed to load assembly types:");
++-++                if (ex.LoaderExceptions != null)
++-++                {
++-++                    foreach (var loaderEx in ex.LoaderExceptions.Take(3))
++-++                    {
++-++                        Console.Error.WriteLine($"   ‚Ä¢ {loaderEx?.Message}");
++-++                    }
++-++                    if (ex.LoaderExceptions.Length > 3)
++-++                    {
++-++                        Console.Error.WriteLine($"   ... and {ex.LoaderExceptions.Length - 3} more errors");
++-++                    }
++-++                }
++-++                Console.Error.WriteLine();
++-++                Console.Error.WriteLine("üí° This usually indicates missing dependencies or version mismatches.");
++-++                Console.Error.WriteLine("   Check that all required packages are installed and compatible.");
++-++                return 126; // Custom exit code for type loading failures
++-++            }
++-++            catch (OutOfMemoryException ex)
++-++            {
++-++                Logger.LogError(ex, "Out of memory during command execution");
++-++                Console.Error.WriteLine("‚ùå Insufficient memory to complete the operation.");
++-++                Console.Error.WriteLine("üí° Try reducing the scope (e.g., analyze fewer files) or increase available memory.");
++-++                return 127; // Custom exit code for memory issues
++-++            }
++-+             catch (Exception ex)
++-+             {
++-+                 Logger.LogError(ex, "Unexpected error during command execution");
++-+-                Console.Error.WriteLine($"Error: {ex.Message}");
++-++                Console.Error.WriteLine($"‚ùå Unexpected error: {ex.Message}");
++-+                 
++-+                 if (Logger.IsEnabled(LogLevel.Debug))
++-+                 {
++-+                     Console.Error.WriteLine($"Stack trace: {ex.StackTrace}");
++-+                 }
++-++                else
++-++                {
++-++                    Console.Error.WriteLine("Use --verbose for detailed error information.");
++-++                }
++-++                
++-++                Console.Error.WriteLine();
++-++                Console.Error.WriteLine("üí° If this error persists, please report it at:");
++-++                Console.Error.WriteLine("   https://github.com/TestIntelligence/TestIntelligence/issues");
++-+                 
++-+                 return 1;
++-+             }
++-+         }
++-+ 
++-++        /// <summary>
++-++        /// Prints usage hint for the current command.
++-++        /// </summary>
++-++        protected virtual void PrintUsageHint(CommandContext context)
++-++        {
++-++            Console.Error.WriteLine("üí° Use --help to see available options and usage examples.");
++-++        }
++-++
++-+         /// <summary>
++-+         /// Executes the command-specific logic. Override this in derived classes.
++-+         /// </summary>
++-+diff --git a/src/TestIntelligence.CLI/Commands/FindTestsCommandHandler.cs b/src/TestIntelligence.CLI/Commands/FindTestsCommandHandler.cs
++-+index 615231e..3ba1564 100644
++-+--- a/src/TestIntelligence.CLI/Commands/FindTestsCommandHandler.cs
++-++++ b/src/TestIntelligence.CLI/Commands/FindTestsCommandHandler.cs
++-+@@ -1,4 +1,5 @@
++-+ using System;
++-++using System.Collections.Generic;
++-+ using System.IO;
++-+ using System.Linq;
++-+ using System.Text;
++-+@@ -7,6 +8,7 @@ using System.Threading.Tasks;
++-+ using Microsoft.Extensions.Logging;
++-+ using TestIntelligence.CLI.Services;
++-+ using TestIntelligence.Core.Services;
++-++using TestIntelligence.Core.Models;
++-+ 
++-+ namespace TestIntelligence.CLI.Commands;
++-+ 
++-+@@ -32,27 +34,61 @@ public class FindTestsCommandHandler : BaseCommandHandler
++-+         var format = context.GetParameter<string>("format") ?? "text";
++-+         var verbose = context.GetParameter<bool>("verbose");
++-+ 
++-++        // Additional validation
++-++        ValidateInputs(method!, solution!, output, format);
++-++
++-+         Logger.LogInformation("Finding tests that exercise method: {Method} in solution: {Solution}", method, solution);
++-+         
++-+         // Get services from DI
++-+         var testCoverageAnalyzer = context.GetService<ITestCoverageAnalyzer>();
++-+         var outputFormatter = context.GetService<IOutputFormatter>();
++-+         
++-++        if (testCoverageAnalyzer == null)
++-++        {
++-++            throw new InvalidOperationException("Test coverage analyzer service is not available. Please check the application configuration.");
++-++        }
++-++        
++-++        if (outputFormatter == null)
++-++        {
++-++            throw new InvalidOperationException("Output formatter service is not available. Please check the application configuration.");
++-++        }
++-++        
++-+         Console.WriteLine($"Finding tests that exercise method: {method}");
++-+         Console.WriteLine($"Solution path: {solution}");
++-+         Console.WriteLine();
++-+ 
++-+-        var tests = await testCoverageAnalyzer.FindTestsExercisingMethodAsync(method!, solution!);
++-+-        
++-+-        if (!tests.Any())
++-++        IReadOnlyList<TestCoverageInfo> tests;
++-++        try
++-+         {
++-+-            Console.WriteLine("No tests found that exercise this method.");
++-++            tests = await testCoverageAnalyzer.FindTestsExercisingMethodAsync(method!, solution!, cancellationToken);
++-++            
++-++            if (tests == null || !tests.Any())
++-++            {
++-++                Console.WriteLine("No tests found that exercise this method.");
++-++                Console.WriteLine();
++-++                Console.WriteLine("üí° This could mean:");
++-++                Console.WriteLine("   ‚Ä¢ The method name/signature is incorrect");
++-++                Console.WriteLine("   ‚Ä¢ No tests actually exercise this method");
++-++                Console.WriteLine("   ‚Ä¢ The method is not public or accessible");
++-++                Console.WriteLine("   ‚Ä¢ There are compilation errors preventing analysis");
++-++                return 0;
++-++            }
++-++
++-++            Console.WriteLine($"Found {tests.Count} test(s) exercising this method:");
++-++            Console.WriteLine();
++-++        }
++-++        catch (ArgumentException)
++-++        {
++-++            // Re-throw argument exceptions to be handled by base class
++-++            throw;
++-++        }
++-++        catch (Exception ex) when (ex.Message.Contains("No test methods found"))
++-++        {
++-++            Console.WriteLine("No test methods found in the solution.");
++-++            Console.WriteLine("üí° Make sure the solution builds successfully and contains test projects.");
++-+             return 0;
++-+         }
++-+ 
++-+-        Console.WriteLine($"Found {tests.Count} test(s) exercising this method:");
++-+-        Console.WriteLine();
++-+-
++-+         if (format == "json")
++-+         {
++-+             var json = outputFormatter.FormatAsJson(tests);
++-+@@ -100,4 +136,45 @@ public class FindTestsCommandHandler : BaseCommandHandler
++-+         
++-+         return 0;
++-+     }
++-++
++-++    /// <summary>
++-++    /// Validates the input parameters for the find-tests command.
++-++    /// </summary>
++-++    private void ValidateInputs(string method, string solution, string? output, string format)
++-++    {
++-++        // Validate solution file exists
++-++        if (!File.Exists(solution))
++-++        {
++-++            throw new FileNotFoundException($"Solution file not found: {solution}");
++-++        }
++-++
++-++        // Validate method format (basic validation)
++-++        if (!method.Contains('.'))
++-++        {
++-++            throw new ArgumentException($"Method parameter should be in format 'Namespace.Class.Method', got: {method}");
++-++        }
++-++
++-++        // Validate output format
++-++        if (!string.Equals(format, "json", StringComparison.OrdinalIgnoreCase) && 
++-++            !string.Equals(format, "text", StringComparison.OrdinalIgnoreCase))
++-++        {
++-++            throw new ArgumentException($"Format must be 'json' or 'text', got: {format}");
++-++        }
++-++
++-++        // Validate output path if provided
++-++        if (!string.IsNullOrWhiteSpace(output))
++-++        {
++-++            var outputDir = Path.GetDirectoryName(Path.GetFullPath(output));
++-++            if (!string.IsNullOrEmpty(outputDir) && !Directory.Exists(outputDir))
++-++            {
++-++                throw new DirectoryNotFoundException($"Output directory does not exist: {outputDir}");
++-++            }
++-++        }
++-++    }
++-++
++-++    protected override void PrintUsageHint(CommandContext context)
++-++    {
++-++        Console.Error.WriteLine("üí° Usage: find-tests --method \"Namespace.Class.Method\" --solution \"path/to/solution.sln\"");
++-++        Console.Error.WriteLine("   Example: find-tests --method \"MyApp.Services.UserService.GetUser\" --solution \"MyApp.sln\"");
++-++    }
++-+ }
++-+\ No newline at end of file
++-+diff --git a/src/TestIntelligence.CLI/TestIntelligence.CLI.csproj b/src/TestIntelligence.CLI/TestIntelligence.CLI.csproj
++-+index c25bbd3..259c88d 100644
++-+--- a/src/TestIntelligence.CLI/TestIntelligence.CLI.csproj
++-++++ b/src/TestIntelligence.CLI/TestIntelligence.CLI.csproj
++-+@@ -27,6 +27,8 @@
++-+     <PackageReference Include="Microsoft.Extensions.Logging" Version="8.0.0" />
++-+     <PackageReference Include="Microsoft.Extensions.Logging.Console" Version="8.0.0" />
++-+     <PackageReference Include="Microsoft.Build.Locator" Version="1.6.10" />
++-++    <!-- Explicit reference to resolve conflicts -->
++-++    <PackageReference Include="Microsoft.Bcl.AsyncInterfaces" Version="8.0.0" />
++-+   </ItemGroup>
++-+ 
++-+   <ItemGroup>
++-+diff --git a/src/TestIntelligence.Core/Models/TestCoverageInfo.cs b/src/TestIntelligence.Core/Models/TestCoverageInfo.cs
++-+index a7b865a..0f50511 100644
++-+--- a/src/TestIntelligence.Core/Models/TestCoverageInfo.cs
++-++++ b/src/TestIntelligence.Core/Models/TestCoverageInfo.cs
++-+@@ -192,10 +192,15 @@ namespace TestIntelligence.Core.Models
++-+             if (fullMethodId.Equals(pattern, StringComparison.OrdinalIgnoreCase))
++-+                 return true;
++-+ 
++-+-            // Extract method name without parameters from full ID
++-++            // Remove global:: prefix if present for comparison
++-++            var normalizedMethodId = fullMethodId.StartsWith("global::", StringComparison.OrdinalIgnoreCase) 
++-++                ? fullMethodId.Substring(8) // Remove "global::" prefix
++-++                : fullMethodId;
++-++
++-++            // Extract method name without parameters from normalized ID
++-+             // Format: Namespace.Class.Method(params)
++-+-            var parenIndex = fullMethodId.IndexOf('(');
++-+-            var methodWithoutParams = parenIndex > 0 ? fullMethodId.Substring(0, parenIndex) : fullMethodId;
++-++            var parenIndex = normalizedMethodId.IndexOf('(');
++-++            var methodWithoutParams = parenIndex > 0 ? normalizedMethodId.Substring(0, parenIndex) : normalizedMethodId;
++-+ 
++-+             // Check if pattern matches the method without parameters
++-+             if (methodWithoutParams.Equals(pattern, StringComparison.OrdinalIgnoreCase))
++-+diff --git a/src/TestIntelligence.Core/TestIntelligence.Core.csproj b/src/TestIntelligence.Core/TestIntelligence.Core.csproj
++-+index 1cbbd22..3c05933 100644
++-+--- a/src/TestIntelligence.Core/TestIntelligence.Core.csproj
++-++++ b/src/TestIntelligence.Core/TestIntelligence.Core.csproj
++-+@@ -23,7 +23,7 @@
++-+     <PackageReference Include="System.Reflection.Metadata" Version="8.0.0" />
++-+     <PackageReference Include="System.Runtime.Loader" Version="4.3.0" />
++-+     <PackageReference Include="System.Reflection.MetadataLoadContext" Version="8.0.0" />
++-+-    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="6.0.4" />
++-++    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="8.0.0" />
++-+     <PackageReference Include="System.Text.Json" Version="8.0.5" />
++-+   </ItemGroup>
++-+ 
++-+diff --git a/src/TestIntelligence.DataTracker/TestIntelligence.DataTracker.csproj b/src/TestIntelligence.DataTracker/TestIntelligence.DataTracker.csproj
++-+index 5440411..dfbdb37 100644
++-+--- a/src/TestIntelligence.DataTracker/TestIntelligence.DataTracker.csproj
++-++++ b/src/TestIntelligence.DataTracker/TestIntelligence.DataTracker.csproj
++-+@@ -19,7 +19,7 @@
++-+   </PropertyGroup>
++-+ 
++-+   <ItemGroup>
++-+-    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="6.0.4" />
++-++    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="8.0.0" />
++-+     <!-- Entity Framework packages for database pattern detection -->
++-+     <PackageReference Include="Microsoft.EntityFrameworkCore" Version="3.1.32" />
++-+     <PackageReference Include="EntityFramework" Version="6.4.4" />
++-+diff --git a/src/TestIntelligence.ImpactAnalyzer/Analysis/LazyWorkspaceBuilder.cs b/src/TestIntelligence.ImpactAnalyzer/Analysis/LazyWorkspaceBuilder.cs
++-+index d91c774..40a3d3c 100644
++-+--- a/src/TestIntelligence.ImpactAnalyzer/Analysis/LazyWorkspaceBuilder.cs
++-++++ b/src/TestIntelligence.ImpactAnalyzer/Analysis/LazyWorkspaceBuilder.cs
++-+@@ -138,23 +138,50 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
++-+         {
++-+             return await _projectCache.GetOrAdd(projectPath, async path =>
++-+             {
++-++                CancellationTokenSource? timeoutCts = null;
++-++                CancellationTokenSource? combinedCts = null;
++-++                
++-+                 try
++-+                 {
++-+                     _logger.LogDebug("Loading project on-demand: {ProjectPath}", path);
++-+                     var startTime = DateTime.UtcNow;
++-+ 
++-+-                    var project = await _workspace.OpenProjectAsync(path);
++-++                    // Add timeout to prevent hanging on project loading
++-++                    timeoutCts = new CancellationTokenSource(TimeSpan.FromSeconds(15));
++-++                    combinedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, timeoutCts.Token);
++-++
++-++                    var projectTask = _workspace.OpenProjectAsync(path);
++-++                    var timeoutTask = Task.Delay(TimeSpan.FromSeconds(15), combinedCts.Token);
++-++                    
++-++                    var completedTask = await Task.WhenAny(projectTask, timeoutTask);
++-++                    if (completedTask == timeoutTask)
++-++                    {
++-++                        _logger.LogWarning("Project loading timed out after 15 seconds: {ProjectPath}", path);
++-++                        return null;
++-++                    }
++-++                    
++-++                    var project = await projectTask;
++-+                     
++-+                     var elapsed = DateTime.UtcNow - startTime;
++-+                     _logger.LogDebug("Project loaded in {ElapsedMs}ms: {ProjectName}", elapsed.TotalMilliseconds, project.Name);
++-+ 
++-+                     return project;
++-+                 }
++-++                catch (OperationCanceledException) when (timeoutCts?.Token.IsCancellationRequested == true)
++-++                {
++-++                    _logger.LogWarning("Project loading timed out after 15 seconds: {ProjectPath}", path);
++-++                    return null;
++-++                }
++-+                 catch (Exception ex)
++-+                 {
++-+                     _logger.LogError(ex, "Failed to load project: {ProjectPath}", path);
++-+                     return null;
++-+                 }
++-++                finally
++-++                {
++-++                    timeoutCts?.Dispose();
++-++                    combinedCts?.Dispose();
++-++                }
++-+             });
++-+         }
++-+ 
++-+@@ -291,8 +318,32 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
++-+         {
++-+             _logger.LogDebug("Loading solution metadata: {SolutionPath}", solutionPath);
++-+             
++-+-            // Load solution directly - we'll manage project loading separately
++-+-            _solution = await _workspace.OpenSolutionAsync(solutionPath);
++-++            // Load solution directly with timeout to prevent hanging
++-++            using var timeoutCts = new CancellationTokenSource(TimeSpan.FromSeconds(30));
++-++            using var combinedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, timeoutCts.Token);
++-++            
++-++            try
++-++            {
++-++                var solutionTask = _workspace.OpenSolutionAsync(solutionPath);
++-++                var timeoutTask = Task.Delay(TimeSpan.FromSeconds(30), combinedCts.Token);
++-++                
++-++                var completedTask = await Task.WhenAny(solutionTask, timeoutTask);
++-++                if (completedTask == timeoutTask)
++-++                {
++-++                    _logger.LogWarning("Solution loading timed out after 30 seconds, falling back to manual solution parsing");
++-++                    await InitializeFromSolutionManuallyAsync(solutionPath, cancellationToken);
++-++                    return;
++-++                }
++-++                
++-++                _solution = await solutionTask;
++-++            }
++-++            catch (OperationCanceledException) when (timeoutCts.Token.IsCancellationRequested)
++-++            {
++-++                _logger.LogWarning("Solution loading timed out after 30 seconds, falling back to manual solution parsing");
++-++                await InitializeFromSolutionManuallyAsync(solutionPath, cancellationToken);
++-++                return;
++-++            }
++-++            
++-+             var solutionInfo = _solution;
++-+ 
++-+             // Build file-to-project mapping from solution
++-+@@ -336,6 +387,70 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
++-+             }
++-+         }
++-+ 
++-++        /// <summary>
++-++        /// Manual solution parsing fallback when MSBuild workspace fails
++-++        /// </summary>
++-++        private async Task InitializeFromSolutionManuallyAsync(string solutionPath, CancellationToken cancellationToken)
++-++        {
++-++            try
++-++            {
++-++                _logger.LogInformation("Using manual solution parsing for: {SolutionPath}", solutionPath);
++-++                
++-++                // Parse solution file manually to get project paths
++-++                var solutionDir = Path.GetDirectoryName(solutionPath)!;
++-++                var solutionLines = await File.ReadAllLinesAsync(solutionPath, cancellationToken);
++-++                
++-++                var projectPaths = new List<string>();
++-++                foreach (var line in solutionLines)
++-++                {
++-++                    // Look for project lines: Project("{...}") = "ProjectName", "RelativePath", "{...}"
++-++                    if (line.StartsWith("Project(") && line.Contains(".csproj"))
++-++                    {
++-++                        var parts = line.Split(',');
++-++                        if (parts.Length >= 2)
++-++                        {
++-++                            var relativePath = parts[1].Trim().Trim('"');
++-++                            var fullPath = Path.GetFullPath(Path.Combine(solutionDir, relativePath));
++-++                            if (File.Exists(fullPath))
++-++                            {
++-++                                projectPaths.Add(fullPath);
++-++                            }
++-++                        }
++-++                    }
++-++                }
++-++                
++-++                _logger.LogInformation("Found {ProjectCount} projects via manual parsing", projectPaths.Count);
++-++                
++-++                // Build file-to-project mapping using file system scanning
++-++                foreach (var projectPath in projectPaths)
++-++                {
++-++                    try
++-++                    {
++-++                        var projectDir = Path.GetDirectoryName(projectPath)!;
++-++                        var csFiles = Directory.GetFiles(projectDir, "*.cs", SearchOption.AllDirectories)
++-++                            .Where(f => !f.Contains("bin") && !f.Contains("obj") && !f.Contains("packages"));
++-++                        
++-++                        foreach (var file in csFiles)
++-++                        {
++-++                            _fileToProjectMap[file] = projectPath;
++-++                        }
++-++                    }
++-++                    catch (Exception ex)
++-++                    {
++-++                        _logger.LogDebug(ex, "Failed to scan project directory: {ProjectPath}", projectPath);
++-++                    }
++-++                }
++-++                
++-++                _logger.LogInformation("Manual solution parsing completed: {ProjectCount} projects, {FileCount} file mappings", 
++-++                    projectPaths.Count, _fileToProjectMap.Count);
++-++            }
++-++            catch (Exception ex)
++-++            {
++-++                _logger.LogError(ex, "Manual solution parsing failed for: {SolutionPath}", solutionPath);
++-++                throw;
++-++            }
++-++        }
++-++
++-+         private void OnWorkspaceFailed(object? sender, WorkspaceDiagnosticEventArgs e)
++-+         {
++-+             _logger.LogDebug("Workspace diagnostic: {Kind} - {Message}", e.Diagnostic.Kind, e.Diagnostic.Message);
++-+diff --git a/src/TestIntelligence.ImpactAnalyzer/Analysis/RoslynAnalyzer.cs b/src/TestIntelligence.ImpactAnalyzer/Analysis/RoslynAnalyzer.cs
++-+index 9648e81..9a182a8 100644
++-+--- a/src/TestIntelligence.ImpactAnalyzer/Analysis/RoslynAnalyzer.cs
++-++++ b/src/TestIntelligence.ImpactAnalyzer/Analysis/RoslynAnalyzer.cs
++-+@@ -62,7 +62,9 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
++-+                 // Initialize lazy workspace for much better performance
++-+                 await InitializeLazyWorkspaceAsync(solutionFile, cancellationToken).ConfigureAwait(false);
++-+ 
++-+-                if (_incrementalCallGraphBuilder != null)
++-++                // TEMPORARY FIX: Disable incremental call graph builder due to placeholder implementation
++-++                // The GetMethodIdsFromFile method returns empty lists, causing 0 methods to be analyzed
++-++                if (false && _incrementalCallGraphBuilder != null)
++-+                 {
++-+                     _logger.LogInformation("Using high-performance incremental call graph builder");
++-+                     // For full solution analysis, we still need to analyze all files, but incrementally
++-+@@ -71,6 +73,7 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
++-+                 }
++-+                 
++-+                 // Fallback to legacy full analysis
++-++                _logger.LogInformation("Using legacy call graph builder (incremental builder temporarily disabled)");
++-+                 await InitializeWorkspaceAsync(solutionFile, cancellationToken).ConfigureAwait(false);
++-+ 
++-+                 if (_callGraphBuilder == null)
++-+diff --git a/src/TestIntelligence.ImpactAnalyzer/Analysis/SolutionWorkspaceBuilder.cs b/src/TestIntelligence.ImpactAnalyzer/Analysis/SolutionWorkspaceBuilder.cs
++-+index eb69959..b30e8e6 100644
++-+--- a/src/TestIntelligence.ImpactAnalyzer/Analysis/SolutionWorkspaceBuilder.cs
++-++++ b/src/TestIntelligence.ImpactAnalyzer/Analysis/SolutionWorkspaceBuilder.cs
++-+@@ -168,24 +168,37 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
++-+             try
++-+             {
++-+                 _logger.LogDebug("Loading solution using MSBuild workspace: {SolutionPath}", solutionPath);
++-+-                var solution = await workspace.OpenSolutionAsync(solutionPath, cancellationToken: cancellationToken);
++-+                 
++-+-                _logger.LogInformation("Solution loaded with {ProjectCount} projects", solution.Projects.Count());
++-++                // Apply timeout to prevent hanging - MSBuild operations can hang indefinitely
++-++                using var timeoutCts = new CancellationTokenSource(TimeSpan.FromMinutes(2)); // 2 minute timeout for solution loading
++-++                using var combinedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, timeoutCts.Token);
++-+                 
++-+-                // Log any diagnostics
++-+-                foreach (var diagnostic in workspace.Diagnostics)
++-++                try
++-+                 {
++-+-                    if (diagnostic.Kind == WorkspaceDiagnosticKind.Failure)
++-+-                    {
++-+-                        _logger.LogWarning("Workspace diagnostic: {Message}", diagnostic.Message);
++-+-                    }
++-+-                    else
++-++                    var solution = await workspace.OpenSolutionAsync(solutionPath, cancellationToken: combinedCts.Token);
++-++                    
++-++                    _logger.LogInformation("Solution loaded with {ProjectCount} projects", solution.Projects.Count());
++-++                    
++-++                    // Log any diagnostics
++-++                    foreach (var diagnostic in workspace.Diagnostics)
++-+                     {
++-+-                        _logger.LogDebug("Workspace diagnostic: {Message}", diagnostic.Message);
++-++                        if (diagnostic.Kind == WorkspaceDiagnosticKind.Failure)
++-++                        {
++-++                            _logger.LogWarning("Workspace diagnostic: {Message}", diagnostic.Message);
++-++                        }
++-++                        else
++-++                        {
++-++                            _logger.LogDebug("Workspace diagnostic: {Message}", diagnostic.Message);
++-++                        }
++-+                     }
++-++                    
++-++                    return solution;
++-++                }
++-++                catch (OperationCanceledException) when (timeoutCts.Token.IsCancellationRequested)
++-++                {
++-++                    _logger.LogError("Solution loading timed out after 2 minutes: {SolutionPath}", solutionPath);
++-++                    throw new TimeoutException($"Solution loading timed out after 2 minutes. This may indicate MSBuild version conflicts or complex solution structure: {solutionPath}");
++-+                 }
++-+-                
++-+-                return solution;
++-+             }
++-+             catch (Exception ex)
++-+             {
++-+diff --git a/src/TestIntelligence.ImpactAnalyzer/Analysis/SymbolIndex.cs b/src/TestIntelligence.ImpactAnalyzer/Analysis/SymbolIndex.cs
++-+index aa9727c..12a61fa 100644
++-+--- a/src/TestIntelligence.ImpactAnalyzer/Analysis/SymbolIndex.cs
++-++++ b/src/TestIntelligence.ImpactAnalyzer/Analysis/SymbolIndex.cs
++-+@@ -283,12 +283,13 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
++-+                     var solutionContent = File.ReadAllText(solutionPath);
++-+                     
++-+                     // Simple regex to find project references in solution file
++-+-                    var projectPattern = new Regex(@"Project\(.+\)\s*=\s*"".+"",\s*""([^""]+\.(?:cs|vb|fs)proj)""", RegexOptions.Compiled);
++-++                    var projectPattern = new Regex(@"Project\(.+\)\s*=\s*"".+"",\s*""([^""]+\.(?:csproj|vbproj|fsproj))""", RegexOptions.Compiled);
++-+                     var matches = projectPattern.Matches(solutionContent);
++-+                     
++-+                     foreach (Match match in matches)
++-+                     {
++-+-                        var projectPath = Path.Combine(solutionDir, match.Groups[1].Value);
++-++                        var relativePath = match.Groups[1].Value.Replace('\\', Path.DirectorySeparatorChar);
++-++                        var projectPath = Path.Combine(solutionDir, relativePath);
++-+                         if (File.Exists(projectPath))
++-+                         {
++-+                             var projectFiles = await GetSourceFilesFromProjectAsync(projectPath, cancellationToken);
++-+diff --git a/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs b/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs
++-+index b96e163..d7f075c 100644
++-+--- a/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs
++-++++ b/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs
++-+@@ -85,14 +85,39 @@ namespace TestIntelligence.ImpactAnalyzer.Services
++-+                 // Try to build call graph with MSBuild workspace first, fallback to assembly analysis
++-+                 try 
++-+                 {
++-++                    // Apply timeout to prevent hanging during call graph building
++-++                    using var timeoutCts = new CancellationTokenSource(TimeSpan.FromMinutes(3)); // 3 minute timeout
++-++                    using var combinedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, timeoutCts.Token);
++-++                    
++-+                     // Build the complete call graph using the solution path
++-+                     // The Roslyn analyzer will handle finding source files and prefer MSBuild workspace if .sln is provided
++-+-                    callGraph = await _roslynAnalyzer.BuildCallGraphAsync(new[] { solutionPath }, cancellationToken);
++-++                    callGraph = await _roslynAnalyzer.BuildCallGraphAsync(new[] { solutionPath }, combinedCts.Token);
++-+                     
++-+                     // Cache the result
++-+                     _cachedCallGraph = callGraph;
++-+                     _cachedSolutionPath = solutionPath;
++-+                 }
++-++                catch (TimeoutException ex)
++-++                {
++-++                    _logger.LogWarning(ex, "Call graph building timed out after 3 minutes, falling back to assembly-based analysis");
++-++                    
++-++                    // Fallback: Try to analyze compiled assemblies instead
++-++                    var assemblyPaths = FindTestAssembliesInSolution(solutionPath);
++-++                    if (assemblyPaths.Any())
++-++                    {
++-++                        _logger.LogInformation("Found {AssemblyCount} test assemblies for fallback analysis", assemblyPaths.Count);
++-++                        callGraph = await _roslynAnalyzer.BuildCallGraphAsync(assemblyPaths.ToArray(), cancellationToken);
++-++                        
++-++                        // Cache the result
++-++                        _cachedCallGraph = callGraph;
++-++                        _cachedSolutionPath = solutionPath;
++-++                    }
++-++                    else
++-++                    {
++-++                        _logger.LogWarning("No assemblies found for fallback analysis");
++-++                        return new TestCoverageMap(new Dictionary<string, List<TestCoverageInfo>>(), DateTime.UtcNow, solutionPath);
++-++                    }
++-++                }
++-+                 catch (InvalidOperationException ex) when (ex.Message.Contains("System.CodeDom") || ex.Message.Contains("MSBuild workspace"))
++-+                 {
++-+                     _logger.LogWarning(ex, "MSBuild workspace failed, falling back to assembly-based analysis");
++-+@@ -536,6 +561,16 @@ namespace TestIntelligence.ImpactAnalyzer.Services
++-+ 
++-+             var testMethods = _testClassifier.GetTestMethods(allMethods);
++-+             _logger.LogInformation("Found {TestMethodCount} test methods for streaming analysis", testMethods.Count);
++-++            
++-++            // Find actual method IDs that match the user's pattern
++-++            var targetMethodIds = FindMatchingMethodIds(methodId, allMethods);
++-++            _logger.LogDebug("Found {Count} target method IDs matching pattern: {Pattern}", targetMethodIds.Count, methodId);
++-++            
++-++            if (targetMethodIds.Count == 0)
++-++            {
++-++                _logger.LogWarning("No methods found matching pattern: {MethodId}", methodId);
++-++                yield break;
++-++            }
++-+ 
++-+             // Process test methods and yield results as we find them
++-+             foreach (var testMethod in testMethods)
++-+@@ -545,10 +580,23 @@ namespace TestIntelligence.ImpactAnalyzer.Services
++-+                 TestCoverageInfo? result = null;
++-+                 try
++-+                 {
++-+-                    var callPath = FindCallPath(testMethod.Id, methodId, callGraph);
++-+-                    if (callPath != null && callPath.Any())
++-++                    // Try to find call paths to any of the matching target methods
++-++                    string[]? callPath = null;
++-++                    string? matchedTargetMethodId = null;
++-++                    
++-++                    foreach (var targetId in targetMethodIds)
++-+                     {
++-+-                        var confidence = CalculateConfidence(callPath, testMethod, callGraph.GetMethodInfo(methodId)!);
++-++                        callPath = FindCallPath(testMethod.Id, targetId, callGraph);
++-++                        if (callPath != null && callPath.Any())
++-++                        {
++-++                            matchedTargetMethodId = targetId;
++-++                            break;
++-++                        }
++-++                    }
++-++                    if (callPath != null && callPath.Any() && matchedTargetMethodId != null)
++-++                    {
++-++                        var targetMethodInfo = callGraph.GetMethodInfo(matchedTargetMethodId)!;
++-++                        var confidence = CalculateConfidence(callPath, testMethod, targetMethodInfo);
++-+                         var testType = _testClassifier.ClassifyTestType(testMethod);
++-+ 
++-+                         result = new TestCoverageInfo(
++-+@@ -616,5 +664,63 @@ namespace TestIntelligence.ImpactAnalyzer.Services
++-+             _pathCache.Clear();
++-+             _logger.LogDebug("Cleared all caches");
++-+         }
++-++
++-++        /// <summary>
++-++        /// Find all method IDs in the call graph that match the given pattern.
++-++        /// Handles global:: prefix and parameter variations.
++-++        /// </summary>
++-++        private List<string> FindMatchingMethodIds(string pattern, IReadOnlyList<MethodInfo> allMethods)
++-++        {
++-++            var matchingIds = new List<string>();
++-++            
++-++            foreach (var method in allMethods)
++-++            {
++-++                if (IsMethodPatternMatch(method.Id, pattern))
++-++                {
++-++                    matchingIds.Add(method.Id);
++-++                }
++-++            }
++-++            
++-++            return matchingIds;
++-++        }
++-++
++-++        /// <summary>
++-++        /// Determines if a method ID matches the given pattern.
++-++        /// Supports pattern matching like the TestCoverageMap.IsMethodMatch method.
++-++        /// </summary>
++-++        private static bool IsMethodPatternMatch(string fullMethodId, string pattern)
++-++        {
++-++            if (string.IsNullOrEmpty(fullMethodId) || string.IsNullOrEmpty(pattern))
++-++                return false;
++-++
++-++            // Exact match
++-++            if (fullMethodId.Equals(pattern, StringComparison.OrdinalIgnoreCase))
++-++                return true;
++-++
++-++            // Remove global:: prefix if present for comparison
++-++            var normalizedMethodId = fullMethodId.StartsWith("global::", StringComparison.OrdinalIgnoreCase) 
++-++                ? fullMethodId.Substring(8) // Remove "global::" prefix
++-++                : fullMethodId;
++-++
++-++            // Extract method name without parameters from normalized ID
++-++            // Format: Namespace.Class.Method(params)
++-++            var parenIndex = normalizedMethodId.IndexOf('(');
++-++            var methodWithoutParams = parenIndex > 0 ? normalizedMethodId.Substring(0, parenIndex) : normalizedMethodId;
++-++
++-++            // Check if pattern matches the method without parameters
++-++            if (methodWithoutParams.Equals(pattern, StringComparison.OrdinalIgnoreCase))
++-++                return true;
++-++
++-++            // Check if pattern is just the method name (last part after final dot)
++-++            var lastDotIndex = methodWithoutParams.LastIndexOf('.');
++-++            if (lastDotIndex >= 0 && lastDotIndex < methodWithoutParams.Length - 1)
++-++            {
++-++                var methodNameOnly = methodWithoutParams.Substring(lastDotIndex + 1);
++-++                if (methodNameOnly.Equals(pattern, StringComparison.OrdinalIgnoreCase))
++-++                    return true;
++-++            }
++-++
++-++            return false;
++-++        }
++-+     }
++-+ }
++-+\ No newline at end of file
++-+diff --git a/src/TestIntelligence.ImpactAnalyzer/TestIntelligence.ImpactAnalyzer.csproj b/src/TestIntelligence.ImpactAnalyzer/TestIntelligence.ImpactAnalyzer.csproj
++-+index 66261c7..1cb2408 100644
++-+--- a/src/TestIntelligence.ImpactAnalyzer/TestIntelligence.ImpactAnalyzer.csproj
++-++++ b/src/TestIntelligence.ImpactAnalyzer/TestIntelligence.ImpactAnalyzer.csproj
++-+@@ -1,7 +1,7 @@
++-+ <Project Sdk="Microsoft.NET.Sdk">
++-+ 
++-+   <PropertyGroup>
++-+-    <TargetFramework>netstandard2.0</TargetFramework>
++-++    <TargetFramework>netstandard2.1</TargetFramework>
++-+     <LangVersion>latest</LangVersion>
++-+     <Nullable>enable</Nullable>
++-+     <PackageId>TestIntelligence.ImpactAnalyzer</PackageId>
++-+@@ -28,6 +28,8 @@
++-+     <!-- Other dependencies provided by Directory.Build.props: Microsoft.CodeAnalysis.CSharp, Newtonsoft.Json, System.Collections.Immutable, System.CodeDom -->
++-+     <PackageReference Include="System.Reflection.Metadata" Version="8.0.0" />
++-+     <PackageReference Include="System.Text.Json" Version="8.0.5" />
++-++    <!-- Add explicit reference to fix MSBuild conflicts -->
++-++    <PackageReference Include="Microsoft.Build.Framework" Version="17.9.5" ExcludeAssets="runtime" />
++-+   </ItemGroup>
++-+ 
++-+   <ItemGroup>
++-+diff --git a/src/TestIntelligence.SelectionEngine/TestIntelligence.SelectionEngine.csproj b/src/TestIntelligence.SelectionEngine/TestIntelligence.SelectionEngine.csproj
++-+index 41ee1d0..3a1d337 100644
++-+--- a/src/TestIntelligence.SelectionEngine/TestIntelligence.SelectionEngine.csproj
++-++++ b/src/TestIntelligence.SelectionEngine/TestIntelligence.SelectionEngine.csproj
++-+@@ -1,7 +1,7 @@
++-+ <Project Sdk="Microsoft.NET.Sdk">
++-+ 
++-+   <PropertyGroup>
++-+-    <TargetFramework>netstandard2.0</TargetFramework>
++-++    <TargetFramework>netstandard2.1</TargetFramework>
++-+     <LangVersion>latest</LangVersion>
++-+     <Nullable>enable</Nullable>
++-+     <PackageId>TestIntelligence.SelectionEngine</PackageId>
++-+diff --git a/tests/TestIntelligence.SelectionEngine.Tests/Engine/TestSelectionEngineTests.cs b/tests/TestIntelligence.SelectionEngine.Tests/Engine/TestSelectionEngineTests.cs
++-+index d4d4c36..55b8911 100644
++-+--- a/tests/TestIntelligence.SelectionEngine.Tests/Engine/TestSelectionEngineTests.cs
++-++++ b/tests/TestIntelligence.SelectionEngine.Tests/Engine/TestSelectionEngineTests.cs
++-+@@ -205,5 +205,222 @@ namespace TestIntelligence.SelectionEngine.Tests.Engine
++-+         {
++-+             // Sample method for reflection
++-+         }
++-++
++-++        #region Integration Tests for ScoreTestsAsync
++-++
++-++        [Fact]
++-++        public async Task ScoreTestsAsync_WithMixedTestTypes_ShouldPrioritizeBasedOnCategory()
++-++        {
++-++            var tests = new[]
++-++            {
++-++                CreateTestInfo("FastUnitTest", TestCategory.Unit, TimeSpan.FromMilliseconds(50), 0.0),
++-++                CreateTestInfo("SlowIntegrationTest", TestCategory.Integration, TimeSpan.FromSeconds(2), 0.0),
++-++                CreateTestInfo("DatabaseTest", TestCategory.Database, TimeSpan.FromSeconds(5), 0.0),
++-++                CreateTestInfo("UITest", TestCategory.UI, TimeSpan.FromSeconds(10), 0.0)
++-++            };
++-++
++-++            var engine = new TestSelectionEngine(_mockLogger.Object, new[] { _mockScoringAlgorithm.Object });
++-++            
++-++            // Configure mock to return different scores based on category
++-++            _mockScoringAlgorithm.Setup(x => x.CalculateScoreAsync(It.IsAny<TestInfo>(), It.IsAny<TestScoringContext>(), It.IsAny<CancellationToken>()))
++-++                .Returns<TestInfo, TestScoringContext, CancellationToken>((test, context, ct) => test.Category switch
++-++                {
++-++                    TestCategory.Unit => Task.FromResult(0.9), // Highest priority for unit tests
++-++                    TestCategory.Integration => Task.FromResult(0.7),
++-++                    TestCategory.Database => Task.FromResult(0.5),
++-++                    TestCategory.UI => Task.FromResult(0.3), // Lowest priority for UI tests
++-++                    _ => Task.FromResult(0.1)
++-++                });
++-++
++-++            var scoredTests = await engine.ScoreTestsAsync(tests);
++-++
++-++            scoredTests.Should().HaveCount(4);
++-++            scoredTests[0].TestMethod.GetDisplayName().Should().Contain("FastUnitTest");
++-++            scoredTests[1].TestMethod.GetDisplayName().Should().Contain("SlowIntegrationTest");
++-++            scoredTests[2].TestMethod.GetDisplayName().Should().Contain("DatabaseTest");
++-++            scoredTests[3].TestMethod.GetDisplayName().Should().Contain("UITest");
++-++        }
++-++
++-++        [Fact]
++-++        public async Task ScoreTestsAsync_WithCodeChanges_ShouldBoostRelatedTests()
++-++        {
++-++            var changes = CreateCodeChangeSet();
++-++            var tests = new[]
++-++            {
++-++                CreateTestInfo("UnrelatedTest", TestCategory.Unit, TimeSpan.FromMilliseconds(100)),
++-++                CreateTestInfo("RelatedTest_MyMethod", TestCategory.Unit, TimeSpan.FromMilliseconds(100)),
++-++                CreateTestInfo("RelatedTest_MyClass", TestCategory.Integration, TimeSpan.FromMilliseconds(500))
++-++            };
++-++
++-++            var engine = new TestSelectionEngine(_mockLogger.Object, new[] { _mockScoringAlgorithm.Object });
++-++            
++-++            // Configure mock to boost scores for related tests
++-++            _mockScoringAlgorithm.Setup(x => x.CalculateScoreAsync(It.IsAny<TestInfo>(), It.IsAny<TestScoringContext>(), It.IsAny<CancellationToken>()))
++-++                .Returns<TestInfo, TestScoringContext, CancellationToken>((test, context, ct) =>
++-++                {
++-++                    if (test.TestMethod.GetDisplayName().Contains("Related"))
++-++                        return Task.FromResult(0.9); // High score for related tests
++-++                    return Task.FromResult(0.3); // Lower score for unrelated tests
++-++                });
++-++
++-++            var scoredTests = await engine.ScoreTestsAsync(tests, changes);
++-++
++-++            scoredTests.Should().HaveCount(3);
++-++            // Related tests should be scored higher and appear first
++-++            scoredTests.Take(2).All(t => t.TestMethod.GetDisplayName().Contains("Related")).Should().BeTrue();
++-++            scoredTests.Last().TestMethod.GetDisplayName().Should().Contain("UnrelatedTest");
++-++        }
++-++
++-++        [Fact]
++-++        public async Task ScoreTestsAsync_WithExecutionHistoryContext_ShouldConsiderReliability()
++-++        {
++-++            var tests = new[]
++-++            {
++-++                CreateTestInfo("FlakeyTest", TestCategory.Unit, TimeSpan.FromMilliseconds(100)),
++-++                CreateTestInfo("ReliableTest", TestCategory.Unit, TimeSpan.FromMilliseconds(150)),
++-++                CreateTestInfo("NewTest", TestCategory.Unit, TimeSpan.FromMilliseconds(80))
++-++            };
++-++
++-++            // Simulate execution history for the tests
++-++            var flakeyTest = tests[0];
++-++            foreach(var result in new[]
++-++            {
++-++                new TestExecutionResult(false, TimeSpan.FromMilliseconds(100), DateTimeOffset.UtcNow.AddDays(-1)), // Failed
++-++                new TestExecutionResult(true, TimeSpan.FromMilliseconds(95), DateTimeOffset.UtcNow.AddHours(-12)), // Passed
++-++                new TestExecutionResult(false, TimeSpan.FromMilliseconds(110), DateTimeOffset.UtcNow.AddHours(-6)) // Failed
++-++            }) { flakeyTest.ExecutionHistory.Add(result); }
++-++
++-++            var reliableTest = tests[1];
++-++            foreach(var result in new[]
++-++            {
++-++                new TestExecutionResult(true, TimeSpan.FromMilliseconds(150), DateTimeOffset.UtcNow.AddDays(-1)), // Passed
++-++                new TestExecutionResult(true, TimeSpan.FromMilliseconds(145), DateTimeOffset.UtcNow.AddHours(-12)), // Passed
++-++                new TestExecutionResult(true, TimeSpan.FromMilliseconds(155), DateTimeOffset.UtcNow.AddHours(-6)) // Passed
++-++            }) { reliableTest.ExecutionHistory.Add(result); }
++-++
++-++            var engine = new TestSelectionEngine(_mockLogger.Object, new[] { _mockScoringAlgorithm.Object });
++-++            
++-++            // Configure mock to factor in reliability
++-++            _mockScoringAlgorithm.Setup(x => x.CalculateScoreAsync(It.IsAny<TestInfo>(), It.IsAny<TestScoringContext>(), It.IsAny<CancellationToken>()))
++-++                .Returns<TestInfo, TestScoringContext, CancellationToken>((test, context, ct) =>
++-++                {
++-++                    if (test.TestMethod.GetDisplayName().Contains("Reliable"))
++-++                        return Task.FromResult(0.9); // High score for reliable tests
++-++                    if (test.TestMethod.GetDisplayName().Contains("Flakey"))
++-++                        return Task.FromResult(0.4); // Lower score for flakey tests
++-++                    return Task.FromResult(0.7); // Medium score for new tests
++-++                });
++-++
++-++            var scoredTests = await engine.ScoreTestsAsync(tests);
++-++
++-++            scoredTests.Should().HaveCount(3);
++-++            scoredTests[0].TestMethod.GetDisplayName().Should().Contain("ReliableTest");
++-++            scoredTests[1].TestMethod.GetDisplayName().Should().Contain("NewTest");
++-++            scoredTests[2].TestMethod.GetDisplayName().Should().Contain("FlakeyTest");
++-++        }
++-++
++-++        [Fact]
++-++        public async Task ScoreTestsAsync_WithLargeTestSuite_ShouldHandlePerformantly()
++-++        {
++-++            // Create a large number of tests to verify performance
++-++            var tests = Enumerable.Range(1, 1000)
++-++                .Select(i => CreateTestInfo($"Test_{i:D4}", 
++-++                    (TestCategory)(i % 4), // Distribute across categories
++-++                    TimeSpan.FromMilliseconds(50 + (i % 200)), // Vary execution times
++-++                    0.0))
++-++                .ToArray();
++-++
++-++            var engine = new TestSelectionEngine(_mockLogger.Object, new[] { _mockScoringAlgorithm.Object });
++-++            
++-++            _mockScoringAlgorithm.Setup(x => x.CalculateScoreAsync(It.IsAny<TestInfo>(), It.IsAny<TestScoringContext>(), It.IsAny<CancellationToken>()))
++-++                .Returns<TestInfo, TestScoringContext, CancellationToken>((test, context, ct) =>
++-++                {
++-++                    // Simulate varying scoring based on test name hash
++-++                    var hash = test.TestMethod.GetDisplayName().GetHashCode();
++-++                    var score = (Math.Abs(hash) % 100) / 100.0; // Score between 0.0 and 1.0
++-++                    return Task.FromResult(score);
++-++                });
++-++
++-++            var stopwatch = System.Diagnostics.Stopwatch.StartNew();
++-++            var scoredTests = await engine.ScoreTestsAsync(tests);
++-++            stopwatch.Stop();
++-++
++-++            scoredTests.Should().HaveCount(1000);
++-++            scoredTests.Should().BeInDescendingOrder(t => t.SelectionScore);
++-++            
++-++            // Performance assertion - should complete within reasonable time
++-++            stopwatch.ElapsedMilliseconds.Should().BeLessThan(5000, "scoring 1000 tests should complete within 5 seconds");
++-++            
++-++            // Verify all tests have been scored
++-++            scoredTests.All(t => t.SelectionScore > 0).Should().BeTrue();
++-++        }
++-++
++-++        [Theory]
++-++        [InlineData(ConfidenceLevel.Fast)]
++-++        [InlineData(ConfidenceLevel.Medium)]
++-++        [InlineData(ConfidenceLevel.High)]
++-++        [InlineData(ConfidenceLevel.Full)]
++-++        public async Task ScoreTestsAsync_WithDifferentConfidenceLevels_ShouldAdjustScoring(ConfidenceLevel confidence)
++-++        {
++-++            var tests = new[]
++-++            {
++-++                CreateTestInfo("UnitTest", TestCategory.Unit, TimeSpan.FromMilliseconds(50)),
++-++                CreateTestInfo("IntegrationTest", TestCategory.Integration, TimeSpan.FromSeconds(1)),
++-++                CreateTestInfo("E2ETest", TestCategory.UI, TimeSpan.FromSeconds(10))
++-++            };
++-++
++-++            var changes = CreateCodeChangeSet();
++-++            var engine = new TestSelectionEngine(_mockLogger.Object, new[] { _mockScoringAlgorithm.Object });
++-++            
++-++            // Configure scoring based on confidence level
++-++            _mockScoringAlgorithm.Setup(x => x.CalculateScoreAsync(It.IsAny<TestInfo>(), It.IsAny<TestScoringContext>(), It.IsAny<CancellationToken>()))
++-++                .Returns<TestInfo, TestScoringContext, CancellationToken>((test, context, ct) =>
++-++                {
++-++                    var baseScore = test.Category switch
++-++                    {
++-++                        TestCategory.Unit => 0.8,
++-++                        TestCategory.Integration => 0.6,
++-++                        TestCategory.UI => 0.4,
++-++                        _ => 0.2
++-++                    };
++-++
++-++                    // Boost score based on confidence level
++-++                    var confidenceMultiplier = context.ConfidenceLevel switch
++-++                    {
++-++                        ConfidenceLevel.Fast => test.Category == TestCategory.Unit ? 1.2 : 0.8,
++-++                        ConfidenceLevel.Medium => test.Category <= TestCategory.Integration ? 1.1 : 0.9,
++-++                        ConfidenceLevel.High => 1.0,
++-++                        ConfidenceLevel.Full => 1.0,
++-++                        _ => 1.0
++-++                    };
++-++
++-++                    return Task.FromResult(baseScore * confidenceMultiplier);
++-++                });
++-++
++-++            var scoredTests = await engine.ScoreTestsAsync(tests, changes);
++-++
++-++            scoredTests.Should().HaveCount(3);
++-++            scoredTests.Should().BeInDescendingOrder(t => t.SelectionScore);
++-++            
++-++            // Verify confidence-specific behavior
++-++            switch (confidence)
++-++            {
++-++                case ConfidenceLevel.Fast:
++-++                    // Should prioritize unit tests
++-++                    scoredTests[0].Category.Should().Be(TestCategory.Unit);
++-++                    break;
++-++                case ConfidenceLevel.Medium:
++-++                    // Should include unit and integration tests with good scores
++-++                    scoredTests.Take(2).All(t => t.Category <= TestCategory.Integration).Should().BeTrue();
++-++                    break;
++-++                case ConfidenceLevel.High:
++-++                case ConfidenceLevel.Full:
++-++                    // Should include all test types
++-++                    scoredTests.Should().Contain(t => t.Category == TestCategory.UI);
++-++                    break;
++-++            }
++-++        }
++-++
++-++        #endregion
++-+     }
++-+ }
++-+\ No newline at end of file
++ diff --git a/src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs b/src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
++-index 410eadf..dc9ed54 100644
+++index 8c033b7..964cd0f 100644
++ --- a/src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
++ +++ b/src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
++-@@ -247,4 +247,4 @@ namespace TestIntelligence.Core.Discovery
+++@@ -250,4 +250,4 @@ namespace TestIntelligence.Core.Discovery
++              DiscoveryError?.Invoke(this, new TestDiscoveryErrorEventArgs(assemblyPath, exception));
++          }
++      }
++ -}
++ \ No newline at end of file
++-+}// Test change for coverage analysis
++-diff --git a/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs b/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs
++-index d7f075c..7b686cd 100644
++---- a/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs
++-+++ b/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs
++-@@ -723,4 +723,4 @@ namespace TestIntelligence.ImpactAnalyzer.Services
++-             return false;
++-         }
++++}// Test change for coverage analysis - Wed Sep  3 18:33:07 CDT 2025
+++diff --git a/src/TestIntelligence.DataTracker/TestDataDependencyTracker.cs b/src/TestIntelligence.DataTracker/TestDataDependencyTracker.cs
+++index 9d88644..c47e3ac 100644
+++--- a/src/TestIntelligence.DataTracker/TestDataDependencyTracker.cs
++++++ b/src/TestIntelligence.DataTracker/TestDataDependencyTracker.cs
+++@@ -413,4 +413,4 @@ namespace TestIntelligence.DataTracker
+++         public int TotalTestPairs => CanRunInParallel.Count + MustRunSequentially.Count;
+++         public double ParallelExecutionRatio => TotalTestPairs > 0 ? (double)CanRunInParallel.Count / TotalTestPairs : 0;
++      }
++ -}
++ \ No newline at end of file
++-+}// Test change for coverage analysis
++++}// Test change for coverage analysis - Wed Sep  3 18:33:13 CDT 2025
+diff --git a/test-changes.patch b/test-changes.patch
+index 11bbfa0..4549ffa 100644
+--- a/test-changes.patch
++++ b/test-changes.patch
+@@ -1,2130 +1,22 @@
+-diff --git a/recent-changes.patch b/recent-changes.patch
+-new file mode 100644
+-index 0000000..6d0dbc7
+---- /dev/null
+-+++ b/recent-changes.patch
+-@@ -0,0 +1,2102 @@
+-+diff --git a/.claude/commands/debug-find-tests.md b/.claude/commands/debug-find-tests.md
+-+new file mode 100644
+-+index 0000000..10c1e5e
+-+--- /dev/null
+-++++ b/.claude/commands/debug-find-tests.md
+-+@@ -0,0 +1,454 @@
+-++# Debug Find-Tests Command
+-++
+-++Debug version of find-tests testing with enhanced tracing to troubleshoot issues we've been experiencing with the find-tests command accuracy.
+-++
+-++## Known Issues to Investigate
+-++- Potential false positives in test detection
+-++- Missing tests that should be found
+-++- Incorrect confidence scoring
+-++- Call graph traversal problems
+-++- Assembly loading or reflection issues
+-++
+-++## Debug Testing Protocol
+-++
+-++### Step 1: Select Target Method with Debug Context
+-++1. **Choose a well-known method** with clear test relationships:
+-++   ```bash
+-++   # Example: Pick a method we know is tested
+-++   echo "üîç Selecting target method for debug analysis..."
+-++   grep -r "DiscoverTestsAsync\|AnalyzeAssembly\|ProcessDependencies" src/ --include="*.cs" -n | head -5
+-++   ```
+-++
+-++2. **Document expected behavior**:
+-++   ```bash
+-++   echo "üìù Documenting what we expect to find..."
+-++   # Manually identify tests that should be found
+-++   grep -r "TargetMethodName" tests/ --include="*.cs" -l
+-++   ```
+-++
+-++### Step 2: Add Debug Tracing to Source Code
+-++
+-++Before running the command, temporarily add debug statements to trace execution:
+-++
+-++```bash
+-++# Backup original files
+-++cp src/TestIntelligence.CLI/Commands/FindTestsCommand.cs src/TestIntelligence.CLI/Commands/FindTestsCommand.cs.debug-backup
+-++cp src/TestIntelligence.Core/Services/TestMethodMapper.cs src/TestIntelligence.Core/Services/TestMethodMapper.cs.debug-backup
+-++```
+-++
+-++#### Add debug statements to key files:
+-++
+-++**1. FindTestsCommand.cs - Entry point tracing**:
+-++```csharp
+-++// Add after method signature
+-++Console.WriteLine($"üîç DEBUG: Starting find-tests for method: {methodName}");
+-++Console.WriteLine($"üîç DEBUG: Solution path: {solutionPath}");
+-++Console.WriteLine($"üîç DEBUG: Output format: {format}");
+-++```
+-++
+-++**2. TestMethodMapper.cs - Core logic tracing**:
+-++```csharp
+-++// Add in FindTestsForMethod
+-++Console.WriteLine($"üîç DEBUG: Loading solution: {solutionPath}");
+-++Console.WriteLine($"üîç DEBUG: Target method: {targetMethod}");
+-++Console.WriteLine($"üîç DEBUG: Found {projects.Count} projects to analyze");
+-++
+-++// Add in call graph traversal
+-++Console.WriteLine($"üîç DEBUG: Building call graph for method: {method.Name}");
+-++Console.WriteLine($"üîç DEBUG: Found {callers.Count} direct callers");
+-++
+-++// Add in test discovery
+-++Console.WriteLine($"üîç DEBUG: Discovered {testMethods.Count} total test methods");
+-++Console.WriteLine($"üîç DEBUG: Filtering tests that call target method...");
+-++```
+-++
+-++**3. Assembly loading tracing**:
+-++```csharp
+-++// Add assembly loading debug info
+-++Console.WriteLine($"üîç DEBUG: Loading assembly: {assemblyPath}");
+-++Console.WriteLine($"üîç DEBUG: Assembly loaded successfully: {assembly.FullName}");
+-++Console.WriteLine($"üîç DEBUG: Found {types.Length} types in assembly");
+-++```
+-++
+-++### Step 3: Run Debug-Enhanced Find-Tests Command
+-++
+-++```bash
+-++# Clear cache to ensure fresh analysis
+-++dotnet run --project src/TestIntelligence.CLI cache \
+-++  --solution TestIntelligence.sln \
+-++  --action clear
+-++
+-++echo "üöÄ Running debug find-tests command..."
+-++dotnet run --project src/TestIntelligence.CLI find-tests \
+-++  --method "TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync" \
+-++  --solution TestIntelligence.sln \
+-++  --format json \
+-++  --output debug-find-tests-result.json \
+-++  --verbose 2>&1 | tee debug-find-tests-trace.log
+-++```
+-++
+-++### Step 4: Enhanced Debug Analysis
+-++
+-++#### 4.1 Trace Analysis
+-++```bash
+-++echo "üìä Analyzing debug trace..."
+-++
+-++# Check if solution loaded correctly
+-++grep "Loading solution" debug-find-tests-trace.log
+-++grep "Found.*projects" debug-find-tests-trace.log
+-++
+-++# Check assembly loading
+-++grep "Loading assembly" debug-find-tests-trace.log
+-++grep "Assembly loaded successfully" debug-find-tests-trace.log
+-++
+-++# Check call graph construction
+-++grep "Building call graph" debug-find-tests-trace.log
+-++grep "Found.*callers" debug-find-tests-trace.log
+-++
+-++# Check test discovery
+-++grep "Discovered.*test methods" debug-find-tests-trace.log
+-++grep "Filtering tests" debug-find-tests-trace.log
+-++```
+-++
+-++#### 4.2 Validate Each Step
+-++```bash
+-++echo "üîç Step-by-step validation..."
+-++
+-++# 1. Verify target method exists
+-++echo "1. Checking if target method exists in codebase:"
+-++grep -r "DiscoverTestsAsync" src/ --include="*.cs" -A 2 -B 2
+-++
+-++# 2. Verify test methods that should be found
+-++echo "2. Manual search for tests that should be found:"
+-++grep -r "DiscoverTestsAsync\|NUnitTestDiscovery" tests/ --include="*.cs" -n
+-++
+-++# 3. Check for false positives in results
+-++echo "3. Examining found tests for false positives:"
+-++jq '.foundTests[].testName' debug-find-tests-result.json
+-++
+-++# 4. Cross-reference with actual test code
+-++echo "4. Cross-referencing with actual test implementations:"
+-++for test in $(jq -r '.foundTests[].testName' debug-find-tests-result.json); do
+-++  echo "Examining test: $test"
+-++  # Find the test file and examine it
+-++  grep -r "$test" tests/ --include="*.cs" -A 10 -B 2
+-++done
+-++```
+-++
+-++### Step 5: Deep Dive Debugging
+-++
+-++#### 5.1 Call Graph Debugging
+-++```bash
+-++echo "üï∏Ô∏è Deep dive into call graph construction..."
+-++
+-++# Generate call graph for target method
+-++dotnet run --project src/TestIntelligence.CLI callgraph \
+-++  --path TestIntelligence.sln \
+-++  --format json \
+-++  --output debug-callgraph.json \
+-++  --verbose
+-++
+-++# Compare call graph with find-tests results
+-++echo "Comparing call graph with find-tests results..."
+-++jq '.methods[] | select(.name | contains("DiscoverTestsAsync"))' debug-callgraph.json
+-++```
+-++
+-++#### 5.2 Assembly Reflection Debugging
+-++Add deeper assembly inspection:
+-++```csharp
+-++// Add to assembly loading section
+-++Console.WriteLine($"üîç DEBUG: Assembly types found:");
+-++foreach (var type in assembly.GetTypes())
+-++{
+-++    Console.WriteLine($"  - {type.FullName}");
+-++    if (type.Name.Contains("Test"))
+-++    {
+-++        var methods = type.GetMethods().Where(m => m.GetCustomAttributes().Any());
+-++        Console.WriteLine($"    Test methods: {methods.Count()}");
+-++        foreach (var method in methods)
+-++        {
+-++            Console.WriteLine($"      - {method.Name}");
+-++        }
+-++    }
+-++}
+-++```
+-++
+-++### Step 6: Issue Classification and Reporting
+-++
+-++#### 6.1 Categorize Issues Found
+-++```bash
+-++echo "üìã Categorizing issues found during debug session..."
+-++
+-++# False Positives Analysis
+-++echo "‚ùå FALSE POSITIVES:"
+-++echo "Tests that were found but don't actually call the target method:"
+-++# Manual analysis based on code examination
+-++
+-++# False Negatives Analysis  
+-++echo "‚ùå FALSE NEGATIVES:"
+-++echo "Tests that should have been found but weren't:"
+-++# Compare manual grep results with CLI output
+-++
+-++# Confidence Score Issues
+-++echo "‚ö†Ô∏è CONFIDENCE SCORE ISSUES:"
+-++echo "Tests with inappropriate confidence scores:"
+-++# Analyze if scores match call depth/complexity
+-++```
+-++
+-++#### 6.2 Root Cause Analysis
+-++Based on debug output, identify likely causes:
+-++
+-++**Common Issues to Look For**:
+-++- **Assembly Loading**: Are all test assemblies being loaded?
+-++- **Reflection Issues**: Are test attributes being detected correctly?
+-++- **Call Graph**: Is method call traversal working correctly?
+-++- **Name Matching**: Are there namespace or overload resolution issues?
+-++- **Caching**: Are cached results stale or incorrect?
+-++
+-++### Step 7: Debug Report Format
+-++
+-++```
+-++## Debug Find-Tests Analysis Report
+-++
+-++**Target Method**: TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync
+-++**Debug Session Date**: [Current Date]
+-++**Known Issues Being Investigated**: False positives, missing integration tests
+-++
+-++### Debug Trace Summary
+-++- ‚úÖ Solution loaded: 15 projects found
+-++- ‚úÖ Target method located in: TestIntelligence.Core.dll
+-++- ‚ö†Ô∏è Assembly loading: 2 warnings about dependency versions
+-++- ‚úÖ Call graph construction: 45 direct callers found
+-++- ‚ùå Test discovery: Only 12 test methods found (expected ~20)
+-++
+-++### Execution Flow Analysis
+-++
+-++#### 1. Solution Loading (‚úÖ Working)
+-++```
+-++üîç DEBUG: Loading solution: TestIntelligence.sln
+-++üîç DEBUG: Found 15 projects to analyze
+-++```
+-++
+-++#### 2. Target Method Resolution (‚úÖ Working)
+-++```
+-++üîç DEBUG: Target method: TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync
+-++üîç DEBUG: Method located in assembly: TestIntelligence.Core
+-++```
+-++
+-++#### 3. Call Graph Construction (‚ö†Ô∏è Partial Issue)
+-++```
+-++üîç DEBUG: Building call graph for method: DiscoverTestsAsync
+-++üîç DEBUG: Found 45 direct callers
+-++Issue: Missing some integration test callers due to indirect invocation
+-++```
+-++
+-++#### 4. Test Discovery (‚ùå Major Issue)
+-++```
+-++üîç DEBUG: Discovered 89 total test methods
+-++üîç DEBUG: Filtering tests that call target method...
+-++Issue: Filter logic excluding valid tests with indirect calls
+-++```
+-++
+-++### Issues Identified
+-++
+-++#### ‚ùå Issue #1: Missing Integration Tests
+-++**Problem**: Integration tests that call TestAnalyzer.AnalyzeAssembly (which calls DiscoverTestsAsync) are not being found
+-++**Root Cause**: Call graph depth limit or indirect call resolution
+-++**Evidence**: Manual grep found 8 integration tests, CLI found only 2
+-++**Debug Trace**: 
+-++```
+-++Manual: grep -r "AnalyzeAssembly" tests/ found 8 matches
+-++CLI Result: Only 2 tests with confidence scores > 0.5
+-++```
+-++
+-++#### ‚ùå Issue #2: False Positive Detection
+-++**Problem**: Test "SomeUnrelatedTest" was found with 0.3 confidence
+-++**Root Cause**: Name collision or incorrect dependency analysis
+-++**Evidence**: Test code shows no actual calls to target method
+-++**Debug Trace**:
+-++```
+-++Test code analysis: Only calls DatabaseHelper.Setup() and Assert methods
+-++No path to DiscoverTestsAsync found in manual trace
+-++```
+-++
+-++#### ‚ö†Ô∏è Issue #3: Confidence Score Inaccuracy
+-++**Problem**: Direct test has confidence 0.7, indirect test has 0.8
+-++**Root Cause**: Scoring algorithm may be inverted or considering other factors
+-++**Evidence**: NUnitTestDiscoveryTests.DirectTest should have higher confidence than IntegrationTests.IndirectTest
+-++
+-++### Recommended Fixes
+-++
+-++1. **Call Graph Depth**: Increase traversal depth for integration tests
+-++2. **Filter Logic**: Review test filtering criteria to include indirect callers
+-++3. **Name Resolution**: Improve method name matching to avoid false positives
+-++4. **Confidence Scoring**: Review algorithm to properly weight direct vs indirect calls
+-++
+-++### Next Steps
+-++1. Apply debug fixes to core components
+-++2. Re-run debug session to validate improvements
+-++3. Add unit tests for edge cases discovered
+-++4. Update documentation with known limitations
+-++```
+-++
+-++### Step 8: Fix Issues Found
+-++
+-++**CRITICAL**: After identifying issues through debugging, you MUST implement fixes for all problems discovered.
+-++
+-++#### 8.1 Apply Fixes Based on Root Cause Analysis
+-++
+-++Based on the issues identified in the debug report, implement the following fixes:
+-++
+-++**Fix #1: Call Graph Depth Issues**
+-++```bash
+-++echo "üîß Fixing call graph traversal depth..."
+-++
+-++# Edit the call graph construction to increase depth limit
+-++# Look for depth limiting code in TestMethodMapper or CallGraphBuilder
+-++grep -r "depth\|limit" src/TestIntelligence.Core/ --include="*.cs" -n
+-++
+-++# Implement fix - example:
+-++# Change: const int MAX_DEPTH = 3;
+-++# To:     const int MAX_DEPTH = 5;
+-++```
+-++
+-++**Fix #2: Test Filtering Logic**
+-++```bash
+-++echo "üîß Fixing test filtering to include indirect callers..."
+-++
+-++# Find and fix the test filtering logic
+-++# Look for filtering criteria that might be too restrictive
+-++grep -r "filter\|where.*confidence\|threshold" src/TestIntelligence.Core/ --include="*.cs" -A 3 -B 3
+-++```
+-++
+-++**Fix #3: Confidence Score Algorithm**
+-++```bash
+-++echo "üîß Fixing confidence scoring algorithm..."
+-++
+-++# Locate confidence scoring logic
+-++grep -r "confidence.*score\|calculateConfidence" src/TestIntelligence.Core/ --include="*.cs" -n
+-++
+-++# Review and fix scoring to properly weight:
+-++# - Direct calls: Higher confidence (0.8-1.0)
+-++# - One-hop indirect: Medium confidence (0.6-0.8)  
+-++# - Multi-hop indirect: Lower confidence (0.3-0.6)
+-++# - No relation: Very low confidence (0.0-0.2)
+-++```
+-++
+-++**Fix #4: False Positive Prevention**
+-++```bash
+-++echo "üîß Implementing false positive detection..."
+-++
+-++# Add stricter validation for method relationships
+-++# Implement additional verification steps before including tests
+-++```
+-++
+-++#### 8.2 Implement Specific Code Changes
+-++
+-++For each identified issue, make the actual code changes:
+-++
+-++```bash
+-++echo "üìù Implementing code fixes..."
+-++
+-++# Example fix for call graph depth
+-++# Find the relevant file and implement the change
+-++# Use Edit tool to modify the source code with the fix
+-++```
+-++
+-++#### 8.3 Validate Fixes
+-++
+-++After implementing fixes, validate they work:
+-++
+-++```bash
+-++echo "‚úÖ Validating fixes..."
+-++
+-++# Rebuild the solution
+-++dotnet build
+-++
+-++# Clear cache to ensure fresh analysis
+-++dotnet run --project src/TestIntelligence.CLI cache \
+-++  --solution TestIntelligence.sln \
+-++  --action clear
+-++
+-++# Re-run the find-tests command to verify improvements
+-++dotnet run --project src/TestIntelligence.CLI find-tests \
+-++  --method "TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync" \
+-++  --solution TestIntelligence.sln \
+-++  --format json \
+-++  --output fixed-find-tests-result.json \
+-++  --verbose
+-++
+-++echo "üîç Comparing before/after results..."
+-++# Compare original debug results with fixed results
+-++echo "Before fix - tests found: $(jq '.foundTests | length' debug-find-tests-result.json)"
+-++echo "After fix - tests found: $(jq '.foundTests | length' fixed-find-tests-result.json)"
+-++
+-++# Verify specific issues were resolved:
+-++echo "Checking if missing integration tests are now found..."
+-++echo "Checking if false positives were eliminated..."
+-++echo "Checking if confidence scores are more accurate..."
+-++```
+-++
+-++#### 8.4 Run Comprehensive Tests
+-++
+-++Ensure fixes don't break other functionality:
+-++
+-++```bash
+-++echo "üß™ Running comprehensive tests after fixes..."
+-++
+-++# Run all relevant tests
+-++dotnet test tests/TestIntelligence.Core.Tests/ -v normal
+-++dotnet test tests/TestIntelligence.ImpactAnalyzer.Tests/ -v normal
+-++
+-++# Test with different target methods to ensure general improvement
+-++dotnet run --project src/TestIntelligence.CLI find-tests \
+-++  --method "TestIntelligence.Core.TestAnalyzer.AnalyzeAssembly" \
+-++  --solution TestIntelligence.sln \
+-++  --output validation-test-2.json
+-++
+-++dotnet run --project src/TestIntelligence.CLI find-tests \
+-++  --method "TestIntelligence.DataTracker.DatabaseAnalyzer.AnalyzeDependencies" \
+-++  --solution TestIntelligence.sln \
+-++  --output validation-test-3.json
+-++```
+-++
+-++### Step 9: Cleanup and Restoration
+-++
+-++```bash
+-++echo "üßπ Cleaning up debug modifications..."
+-++
+-++# Restore original files (debug tracing code)
+-++mv src/TestIntelligence.CLI/Commands/FindTestsCommand.cs.debug-backup src/TestIntelligence.CLI/Commands/FindTestsCommand.cs
+-++mv src/TestIntelligence.Core/Services/TestMethodMapper.cs.debug-backup src/TestIntelligence.Core/Services/TestMethodMapper.cs
+-++
+-++# Keep debug logs and results for reference
+-++mkdir -p debug-logs
+-++mv debug-find-tests-trace.log debug-logs/
+-++mv debug-find-tests-result.json debug-logs/
+-++mv fixed-find-tests-result.json debug-logs/
+-++mv debug-callgraph.json debug-logs/
+-++mv validation-test-*.json debug-logs/
+-++
+-++echo "‚úÖ Debug session complete with fixes applied. Logs saved to debug-logs/"
+-++```
+-++
+-++## Usage Instructions for Claude
+-++
+-++When running this debug command, you MUST:
+-++
+-++1. **Be systematic** - Follow each debug step to identify the exact failure point
+-++2. **Preserve evidence** - Save all debug output and manual verification results
+-++3. **Compare exhaustively** - Cross-reference CLI results with manual code analysis
+-++4. **Focus on root causes** - Don't just identify symptoms, trace to underlying issues
+-++5. **Document thoroughly** - Create detailed reports to help fix the underlying problems
+-++6. **IMPLEMENT FIXES** - Actually modify the source code to resolve identified issues
+-++7. **Validate fixes** - Re-run debug session and tests after applying fixes
+-++8. **Test comprehensively** - Ensure fixes don't break other functionality
+-++
+-++**CRITICAL REQUIREMENT**: This command is not complete until you have:
+-++- ‚úÖ Identified all issues through debugging
+-++- ‚úÖ Implemented code fixes for each identified problem
+-++- ‚úÖ Validated that fixes resolve the issues
+-++- ‚úÖ Confirmed no regressions were introduced
+-++- ‚úÖ Updated any relevant tests or documentation
+-++
+-++This debug-and-fix approach will not only identify where the find-tests command is failing but will also resolve those issues to improve the overall accuracy and reliability of the TestIntelligence library.
+-+\ No newline at end of file
+-+diff --git a/.claude/commands/test-analyze-coverage.md b/.claude/commands/test-analyze-coverage.md
+-+new file mode 100644
+-+index 0000000..9eb3bdc
+-+--- /dev/null
+-++++ b/.claude/commands/test-analyze-coverage.md
+-+@@ -0,0 +1,187 @@
+-++# Test Analyze Coverage Command
+-++
+-++Instructions for Claude to test the analyze-coverage command by selecting test methods and verifying how well they cover code changes.
+-++
+-++## Testing Protocol
+-++
+-++### Step 1: Create Test Scenario
+-++1. **Select Target Tests**: Choose 2-3 test methods from different test projects:
+-++   - Pick tests that exercise different parts of the codebase
+-++   - Include both unit tests and integration tests
+-++   - Choose tests you can manually trace through
+-++
+-++2. **Create Mock Changes**: Generate a git diff to analyze:
+-++   ```bash
+-++   # Option A: Create actual changes and diff them
+-++   echo "// Test change" >> src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
+-++   git add -A
+-++   git diff --cached > test-changes.patch
+-++   git reset HEAD
+-++   
+-++   # Option B: Use existing git history
+-++   git diff HEAD~1 > recent-changes.patch
+-++   ```
+-++
+-++### Step 2: Run the Analyze-Coverage Command
+-++```bash
+-++dotnet run --project src/TestIntelligence.CLI analyze-coverage \
+-++  --solution TestIntelligence.sln \
+-++  --tests "TestClass1.TestMethod1" "TestClass2.TestMethod2" "TestClass3.TestMethod3" \
+-++  --git-command "diff HEAD~1" \
+-++  --verbose \
+-++  --output coverage-analysis.json
+-++```
+-++
+-++Alternative with diff file:
+-++```bash
+-++dotnet run --project src/TestIntelligence.CLI analyze-coverage \
+-++  --solution TestIntelligence.sln \
+-++  --tests "TestClass1.TestMethod1" "TestClass2.TestMethod2" \
+-++  --diff-file test-changes.patch \
+-++  --verbose \
+-++  --output coverage-analysis.json
+-++```
+-++
+-++### Step 3: Manual Verification Process
+-++
+-++#### 3.1 Analyze the Output
+-++1. **Read Coverage Report**: Examine JSON results for:
+-++   - Coverage percentage for each test
+-++   - List of changed methods/classes covered by each test
+-++   - Uncovered changes identified
+-++   - Overall coverage metrics
+-++
+-++2. **Understand Change Set**: Review the git diff to identify:
+-++   - Which files were modified
+-++   - Which methods/classes were changed
+-++   - Nature of changes (new code, modifications, deletions)
+-++
+-++#### 3.2 Manual Coverage Verification
+-++For each test method:
+-++
+-++1. **Trace Test Execution**:
+-++   - Read the test method source code
+-++   - Follow all method calls made by the test
+-++   - Map the execution path through the codebase
+-++
+-++2. **Match Against Changes**:
+-++   - Compare test execution path with changed code
+-++   - Identify which changed methods/classes the test actually exercises
+-++   - Note any changed code the test doesn't reach
+-++
+-++3. **Validate Coverage Calculation**:
+-++   - Count changed methods covered vs. total changed methods
+-++   - Verify the coverage percentage is mathematically correct
+-++   - Check if the analysis missed any coverage or overcounted
+-++
+-++#### 3.3 Gap Analysis
+-++1. **Identify Uncovered Changes**:
+-++   - Find changed code not exercised by any of the selected tests
+-++   - Verify these are truly uncovered (not false negatives)
+-++
+-++2. **Find Coverage Gaps**:
+-++   - Look for changed code that should be covered but isn't
+-++   - Search for additional tests that might cover the gaps
+-++
+-++### Step 4: Verification Commands
+-++
+-++```bash
+-++# Search for tests that might cover a specific changed class
+-++grep -r "ChangedClassName" tests/ --include="*.cs" -l
+-++
+-++# Look at specific changed file to understand modifications
+-++git show HEAD~1:src/path/to/ChangedFile.cs | diff - src/path/to/ChangedFile.cs
+-++
+-++# Find all tests in a specific test class
+-++grep -n "\[Test\]\|\[Fact\]\|\[TestMethod\]" tests/path/to/TestClass.cs
+-++
+-++# Trace method usage across the codebase
+-++grep -r "ChangedMethodName" src/ --include="*.cs"
+-++```
+-++
+-++### Step 5: Sample Verification Report Format
+-++
+-++```
+-++## Analyze-Coverage Verification Report
+-++
+-++**Test Scenario**:
+-++- Selected Tests: 3 tests from Core and DataTracker projects
+-++- Change Set: Modified NUnitTestDiscovery.cs and TestAnalyzer.cs (8 methods changed)
+-++- Git Command: `diff HEAD~1`
+-++
+-++**CLI Output Summary**:
+-++- Test1 Coverage: 75% (6/8 changed methods)
+-++- Test2 Coverage: 25% (2/8 changed methods)  
+-++- Test3 Coverage: 0% (0/8 changed methods)
+-++- Overall Coverage: 87.5% (7/8 changed methods covered by at least one test)
+-++
+-++**Manual Verification**:
+-++
+-++‚úÖ **Test1: NUnitTestDiscoveryTests.DiscoverTestsAsync_ValidAssembly**
+-++   - Claimed Coverage: 75% (6/8 methods)
+-++   - Manual Trace: Calls NUnitTestDiscovery.DiscoverTestsAsync ‚Üí LoadAssembly ‚Üí ProcessTypes ‚Üí ExtractAttributes
+-++   - Actually Covers: NUnitTestDiscovery.DiscoverTestsAsync, LoadAssembly, ProcessTypes, ExtractAttributes, ValidateTest, FormatResults (6/8) ‚úÖ
+-++   - Coverage calculation: Correct
+-++
+-++‚úÖ **Test2: TestAnalyzerTests.AnalyzeFullSolution**  
+-++   - Claimed Coverage: 25% (2/8 methods)
+-++   - Manual Trace: Calls TestAnalyzer.AnalyzeAssembly ‚Üí NUnitTestDiscovery.DiscoverTestsAsync ‚Üí LoadAssembly
+-++   - Actually Covers: AnalyzeAssembly, DiscoverTestsAsync (2/8) ‚úÖ
+-++   - Coverage calculation: Correct
+-++
+-++‚ö†Ô∏è **Test3: DataTrackerTests.SomeUnrelatedTest**
+-++   - Claimed Coverage: 0% (0/8 methods)
+-++   - Manual Trace: Only exercises database tracking functionality
+-++   - Actually Covers: None of the changed methods ‚úÖ
+-++   - Coverage calculation: Correct (true negative)
+-++
+-++**Uncovered Changes Verification**:
+-++‚úÖ **TestAnalyzer.ValidateConfiguration** - Correctly identified as uncovered
+-++   - No selected tests call this method
+-++   - Manually confirmed by searching test codebase
+-++
+-++‚ùå **Missing Coverage Detection**:
+-++   - Found integration test `FullPipelineTests.CompleteAnalysis` that exercises ValidateConfiguration
+-++   - This test wasn't in the selected set but would provide coverage
+-++   - CLI correctly reported method as uncovered for the selected tests
+-++
+-++**Overall Accuracy**: 100% - All coverage calculations verified as correct
+-++**Coverage Gap Analysis**: 1/8 methods uncovered by selected tests (12.5% gap)
+-++
+-++**Recommendations**: 
+-++- Coverage analysis is mathematically accurate
+-++- Consider expanding test selection to include integration tests for better coverage
+-++- The uncovered method has tests available but weren't in the analyzed set
+-++```
+-++
+-++### Additional Verification Scenarios
+-++
+-++#### Scenario A: High Coverage Test Set
+-++Select tests known to exercise broad functionality:
+-++- Integration tests
+-++- End-to-end workflow tests  
+-++- Tests that call multiple components
+-++
+-++#### Scenario B: Low Coverage Test Set
+-++Select very focused unit tests:
+-++- Tests that only exercise one method
+-++- Isolated component tests
+-++- Mock-heavy tests with limited real code execution
+-++
+-++#### Scenario C: Mixed Framework Changes
+-++Create changes spanning multiple projects:
+-++- Core library changes
+-++- CLI command changes
+-++- Test framework changes
+-++
+-++## Usage Instructions for Claude
+-++
+-++When running this command:
+-++1. **Be methodical** - actually trace through test execution paths
+-++2. **Verify math** - check that coverage percentages are calculated correctly
+-++3. **Look for edge cases** - tests that might have unexpected coverage patterns
+-++4. **Consider test types** - unit vs integration tests may have different coverage patterns
+-++5. **Cross-reference** - use grep/search to validate coverage claims
+-++6. **Report thoroughly** - document both correct results and any discrepancies found
+-++
+-++This testing ensures the analyze-coverage command accurately maps test execution to code changes, which is critical for intelligent test selection and impact analysis.
+-+\ No newline at end of file
+-+diff --git a/.claude/commands/test-and-commit.md b/.claude/commands/test-and-commit.md
+-+new file mode 100644
+-+index 0000000..9db3c91
+-+--- /dev/null
+-++++ b/.claude/commands/test-and-commit.md
+-+@@ -0,0 +1,39 @@
+-++# Test and Commit
+-++
+-++Run all non-E2E tests, fix any issues found, and commit/push if all tests pass.
+-++
+-++## Command
+-++
+-++```bash
+-++# Run all tests except E2E tests
+-++dotnet test --filter "Category!=E2E" --verbosity normal
+-++
+-++# If tests fail, Claude will analyze and fix the issues
+-++# If all tests pass, commit and push changes
+-++if [ $? -eq 0 ]; then
+-++  echo "All tests passed! Committing and pushing changes..."
+-++  git add .
+-++  git commit -m "$(cat <<'EOF'
+-++Fix test issues and update codebase
+-++
+-++All non-E2E tests are now passing.
+-++
+-++ü§ñ Generated with [Claude Code](https://claude.ai/code)
+-++
+-++Co-Authored-By: Claude <noreply@anthropic.com>
+-++EOF
+-++)"
+-++  git push
+-++else
+-++  echo "Tests failed. Claude will analyze and fix the issues."
+-++fi
+-++```
+-++
+-++## Usage
+-++
+-++Run this command when you want to:
+-++1. Execute all tests except E2E tests
+-++2. Have Claude automatically fix any test failures
+-++3. Commit and push changes if all tests pass
+-++
+-++This command ensures your codebase maintains test quality while automating the commit process for successful test runs.
+-+\ No newline at end of file
+-+diff --git a/.claude/commands/test-find-tests.md b/.claude/commands/test-find-tests.md
+-+new file mode 100644
+-+index 0000000..89bb827
+-+--- /dev/null
+-++++ b/.claude/commands/test-find-tests.md
+-+@@ -0,0 +1,103 @@
+-++# Test Find-Tests Command
+-++
+-++Instructions for Claude to test the find-tests command by selecting a random method and verifying the output accuracy.
+-++
+-++## Testing Protocol
+-++
+-++### Step 1: Select a Random Method
+-++1. Use `find` or `grep` to discover methods in the src/ directory
+-++2. Pick a method from a Core, Categorizer, DataTracker, ImpactAnalyzer, or SelectionEngine class
+-++3. Choose a method that's likely to be tested (public methods, important functionality)
+-++
+-++### Step 2: Run the Find-Tests Command
+-++```bash
+-++dotnet run --project src/TestIntelligence.CLI find-tests \
+-++  --method "FullNamespace.ClassName.MethodName" \
+-++  --solution TestIntelligence.sln \
+-++  --format json \
+-++  --output find-tests-result.json \
+-++  --verbose
+-++```
+-++
+-++### Step 3: Manual Verification Process
+-++1. **Read the Output**: Examine the JSON results for:
+-++   - List of test methods that allegedly exercise the target method
+-++   - Confidence scores for each test
+-++   - Call path depth information
+-++
+-++2. **Code Analysis**: For each test found:
+-++   - Read the test method source code
+-++   - Trace through the test execution path
+-++   - Verify the test actually calls (directly or indirectly) the target method
+-++   - Check if the confidence score seems reasonable based on call depth
+-++
+-++3. **Completeness Check**: 
+-++   - Search the test codebase for the target method name
+-++   - Look for any tests that should have been found but weren't
+-++   - Verify no false positives (tests that don't actually exercise the method)
+-++
+-++4. **Report Results**:
+-++   - Summarize accuracy: "X out of Y tests correctly identified"
+-++   - Note any false positives or missed tests
+-++   - Comment on confidence score appropriateness
+-++   - Highlight any patterns or issues discovered
+-++
+-++### Step 4: Sample Commands to Help with Verification
+-++
+-++```bash
+-++# Search for direct method calls in tests
+-++grep -r "MethodName" tests/ --include="*.cs"
+-++
+-++# Search for class usage in tests
+-++grep -r "ClassName" tests/ --include="*.cs"
+-++
+-++# Look at specific test file
+-++cat tests/path/to/TestClass.cs
+-++```
+-++
+-++### Example Verification Report Format
+-++
+-++```
+-++## Find-Tests Verification Report
+-++
+-++**Target Method**: TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync
+-++
+-++**CLI Output Summary**:
+-++- Found: 5 tests
+-++- Confidence scores: High(2), Medium(2), Low(1)
+-++
+-++**Manual Verification**:
+-++‚úÖ TestIntelligence.Core.Tests.Discovery.NUnitTestDiscoveryTests.DiscoverTestsAsync_ValidAssembly_ReturnsTests
+-++   - Directly calls target method
+-++   - Confidence: High (appropriate)
+-++
+-++‚úÖ TestIntelligence.Core.Tests.TestAnalyzerTests.AnalyzeAssembly_WithNUnitTests_IncludesNUnitTests  
+-++   - Calls TestAnalyzer.AnalyzeAssembly which calls target method
+-++   - Confidence: Medium (appropriate for 1-hop call)
+-++
+-++‚ùå TestIntelligence.SelectionEngine.Tests.SomeUnrelatedTest
+-++   - False positive - doesn't actually call target method
+-++   - Issue: Possible name collision or incorrect call graph
+-++
+-++**Missing Tests**:
+-++- TestIntelligence.Core.Tests.Integration.FullAnalysisTests.CompleteAnalysis
+-++  - This test exercises the full pipeline including the target method
+-++  - Should have been found with Low confidence
+-++
+-++**Overall Accuracy**: 4/5 correct (80%)
+-++**Recommendations**: 
+-++- Investigate false positive detection
+-++- Review call graph completeness for integration tests
+-++```
+-++
+-++## Usage Instructions for Claude
+-++
+-++When running this command:
+-++1. Be thorough in your verification - actually read the test code
+-++2. Don't just trust the CLI output - verify by examining source code
+-++3. Look for both false positives and false negatives
+-++4. Consider the appropriateness of confidence scores
+-++5. Report your findings in a clear, structured format
+-++6. If you find issues, suggest potential causes or improvements
+-++
+-++This testing helps ensure the find-tests command is working accurately and can be trusted for real-world usage.
+-+\ No newline at end of file
+-+diff --git a/.claude/commands/test-select.md b/.claude/commands/test-select.md
+-+new file mode 100644
+-+index 0000000..dcb866c
+-+--- /dev/null
+-++++ b/.claude/commands/test-select.md
+-+@@ -0,0 +1,278 @@
+-++# Test Select Command
+-++
+-++Instructions for Claude to test the select command by creating code changes and verifying intelligent test selection accuracy across different confidence levels.
+-++
+-++## Testing Protocol
+-++
+-++### Step 1: Create Test Scenarios
+-++
+-++#### Scenario A: Single File Change (Core Component)
+-++```bash
+-++# Make a targeted change to a core component
+-++cp src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs.backup
+-++echo "        // Test change for select command validation" >> src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
+-++```
+-++
+-++#### Scenario B: Multi-File Change (Cross-Component)
+-++```bash
+-++# Make changes across multiple components
+-++echo "        // Cross-component change test" >> src/TestIntelligence.Core/TestAnalyzer.cs
+-++echo "        // Related CLI change" >> src/TestIntelligence.CLI/Commands/AnalyzeCommand.cs
+-++```
+-++
+-++#### Scenario C: Interface/Contract Change
+-++```bash
+-++# Modify an interface or base class that affects multiple implementations
+-++echo "        // Interface change affecting multiple implementations" >> src/TestIntelligence.Core/Interfaces/ITestDiscovery.cs
+-++```
+-++
+-++### Step 2: Test Different Confidence Levels
+-++
+-++#### 2.1 Fast Confidence (30 sec, 70% confidence)
+-++```bash
+-++dotnet run --project src/TestIntelligence.CLI select \
+-++  --path TestIntelligence.sln \
+-++  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" \
+-++  --confidence Fast \
+-++  --max-tests 20 \
+-++  --output select-fast.json \
+-++  --verbose
+-++```
+-++
+-++#### 2.2 Medium Confidence (5 min, 85% confidence)  
+-++```bash
+-++dotnet run --project src/TestIntelligence.CLI select \
+-++  --path TestIntelligence.sln \
+-++  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" \
+-++  --confidence Medium \
+-++  --max-tests 50 \
+-++  --output select-medium.json \
+-++  --verbose
+-++```
+-++
+-++#### 2.3 High Confidence (15 min, 95% confidence)
+-++```bash
+-++dotnet run --project src/TestIntelligence.CLI select \
+-++  --path TestIntelligence.sln \
+-++  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" \
+-++  --confidence High \
+-++  --max-tests 100 \
+-++  --output select-high.json \
+-++  --verbose
+-++```
+-++
+-++#### 2.4 Full Confidence (Complete suite, 100% confidence)
+-++```bash
+-++dotnet run --project src/TestIntelligence.CLI select \
+-++  --path TestIntelligence.sln \
+-++  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" \
+-++  --confidence Full \
+-++  --output select-full.json \
+-++  --verbose
+-++```
+-++
+-++### Step 3: Manual Verification Process
+-++
+-++#### 3.1 Analyze Selection Results
+-++For each confidence level, examine:
+-++1. **Number of tests selected**
+-++2. **Test categories included** (Unit, Integration, Database, API, UI)
+-++3. **Confidence scores** for each selected test
+-++4. **Execution time estimates**
+-++5. **Tests organized by priority/relevance**
+-++
+-++#### 3.2 Validate Test Selection Logic
+-++
+-++**Direct Impact Tests (Should be in Fast)**:
+-++```bash
+-++# Find tests that directly test the changed class
+-++grep -r "NUnitTestDiscovery" tests/ --include="*.cs" -l
+-++# These should appear in Fast confidence with high scores
+-++```
+-++
+-++**Indirect Impact Tests (Should be in Medium)**:
+-++```bash
+-++# Find tests that use classes that depend on the changed class
+-++grep -r "TestAnalyzer\|Discovery" tests/ --include="*.cs" -l
+-++# These should appear in Medium confidence with medium scores
+-++```
+-++
+-++**Integration Tests (Should be in High)**:
+-++```bash
+-++# Find integration tests that exercise the full pipeline
+-++grep -r "Integration\|EndToEnd\|FullPipeline" tests/ --include="*.cs" -l
+-++# These should appear in High confidence with lower scores
+-++```
+-++
+-++#### 3.3 Confidence Level Validation
+-++
+-++Verify that each confidence level follows the expected pattern:
+-++- **Fast ‚äÇ Medium ‚äÇ High ‚äÇ Full** (each level includes previous levels)
+-++- **Decreasing relevance scores** as confidence level increases
+-++- **Appropriate test count limits** respected
+-++- **Time estimates** align with confidence level targets
+-++
+-++### Step 4: Cross-Reference with Other Commands
+-++
+-++#### 4.1 Verify Against Find-Tests
+-++```bash
+-++# For each selected test, verify it actually relates to the changed code
+-++dotnet run --project src/TestIntelligence.CLI find-tests \
+-++  --method "TestIntelligence.Core.Discovery.NUnitTestDiscovery.DiscoverTestsAsync" \
+-++  --solution TestIntelligence.sln \
+-++  --output find-tests-cross-check.json
+-++```
+-++
+-++#### 4.2 Verify Against Coverage Analysis
+-++```bash
+-++# Check if selected tests actually provide good coverage of changes
+-++dotnet run --project src/TestIntelligence.CLI analyze-coverage \
+-++  --solution TestIntelligence.sln \
+-++  --tests $(jq -r '.selectedTests[].testName' select-medium.json | tr '\n' ' ') \
+-++  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" \
+-++  --output coverage-cross-check.json
+-++```
+-++
+-++### Step 5: Sample Verification Report Format
+-++
+-++```
+-++## Select Command Verification Report
+-++
+-++**Test Scenario**: Modified NUnitTestDiscovery.cs (single method change)
+-++**Change Type**: Core component modification affecting test discovery logic
+-++
+-++### Confidence Level Analysis
+-++
+-++#### Fast Confidence (Target: 30 sec, 70% confidence)
+-++- **Selected**: 8 tests
+-++- **Time Estimate**: 25 seconds ‚úÖ
+-++- **Categories**: Unit (6), Integration (2)
+-++- **Top Tests**:
+-++  ‚úÖ NUnitTestDiscoveryTests.DiscoverTestsAsync_ValidAssembly (Score: 0.95)
+-++  ‚úÖ NUnitTestDiscoveryTests.DiscoverTestsAsync_EmptyAssembly (Score: 0.92)  
+-++  ‚úÖ TestAnalyzerTests.AnalyzeAssembly_WithNUnitTests (Score: 0.78)
+-++
+-++#### Medium Confidence (Target: 5 min, 85% confidence)  
+-++- **Selected**: 23 tests (includes all Fast + 15 more) ‚úÖ
+-++- **Time Estimate**: 4.2 minutes ‚úÖ
+-++- **Categories**: Unit (15), Integration (6), Database (2)
+-++- **Additional Tests**:
+-++  ‚úÖ CoreIntegrationTests.FullDiscoveryPipeline (Score: 0.65)
+-++  ‚úÖ MultiFrameworkTests.NUnitAndXUnit (Score: 0.58)
+-++
+-++#### High Confidence (Target: 15 min, 95% confidence)
+-++- **Selected**: 47 tests (includes all Medium + 24 more) ‚úÖ  
+-++- **Time Estimate**: 12.8 minutes ‚úÖ
+-++- **Categories**: Unit (25), Integration (15), Database (4), API (3)
+-++- **Additional Tests**:
+-++  ‚úÖ E2ETests.CompleteAnalysisWorkflow (Score: 0.35)
+-++  ‚ö†Ô∏è UnrelatedUITests.SomeUITest (Score: 0.12) - Questionable relevance
+-++
+-++#### Full Confidence
+-++- **Selected**: All 215 tests ‚úÖ
+-++- **Includes**: Every test in the solution
+-++
+-++### Manual Verification Results
+-++
+-++#### Direct Impact Validation ‚úÖ
+-++**Expected**: Tests that directly call NUnitTestDiscovery methods
+-++- Found 6 direct tests in TestIntelligence.Core.Tests
+-++- All 6 appeared in Fast confidence with scores > 0.8 ‚úÖ
+-++- Scores appropriately reflect call directness ‚úÖ
+-++
+-++#### Indirect Impact Validation ‚úÖ  
+-++**Expected**: Tests that call TestAnalyzer which uses NUnitTestDiscovery
+-++- Found 8 indirect tests across Core and CLI test projects
+-++- 7/8 appeared in Medium confidence ‚úÖ
+-++- 1 missing test: CLIIntegrationTests.AnalyzeCommand_WithNUnit ‚ùå
+-++- Scores appropriately lower (0.5-0.8 range) ‚úÖ
+-++
+-++#### Integration Test Validation ‚ö†Ô∏è
+-++**Expected**: End-to-end tests that exercise full discovery pipeline  
+-++- Found 12 integration tests
+-++- 10/12 appeared in High confidence ‚úÖ
+-++- 2 missing: PerformanceTests.LargeSolutionAnalysis, StressTests.ConcurrentDiscovery ‚ùå
+-++- Some questionable inclusions with very low relevance scores
+-++
+-++### Cross-Reference Validation
+-++
+-++#### Find-Tests Cross-Check ‚úÖ
+-++- Selected tests from Fast confidence all verified via find-tests command
+-++- No false positives detected in direct impact tests
+-++- Confidence scores align between select and find-tests commands
+-++
+-++#### Coverage Analysis Cross-Check ‚ö†Ô∏è
+-++- Medium confidence tests provide 78% coverage of changed code
+-++- Expected: ~85% based on confidence level target
+-++- Gap: Some edge cases in error handling not covered by selected tests
+-++- Recommendation: Include additional error handling tests
+-++
+-++### Selection Logic Assessment
+-++
+-++**Strengths**:
+-++- ‚úÖ Confidence levels properly nested (Fast ‚äÇ Medium ‚äÇ High ‚äÇ Full)
+-++- ‚úÖ Time estimates realistic and within targets
+-++- ‚úÖ Direct impact tests correctly prioritized
+-++- ‚úÖ Test categories appropriately distributed
+-++- ‚úÖ Relevance scores generally accurate
+-++
+-++**Issues Found**:
+-++- ‚ùå 2 high-relevance tests missed in Medium confidence
+-++- ‚ùå Some very low relevance tests included in High confidence  
+-++- ‚ùå Coverage gap vs confidence level expectations
+-++
+-++**Overall Accuracy**: 85% - Good test selection with minor gaps
+-++**Recommendation**: 
+-++- Review inclusion threshold for High confidence
+-++- Investigate why 2 relevant tests were missed
+-++- Consider adjusting relevance scoring for integration tests
+-++```
+-++
+-++### Advanced Test Scenarios
+-++
+-++#### Scenario D: Configuration Change Impact
+-++```bash
+-++# Test with configuration/settings changes that might affect many components
+-++echo "    // Configuration change" >> src/TestIntelligence.Core/Configuration/AnalysisSettings.cs
+-++```
+-++
+-++#### Scenario E: Multiple File Changes
+-++```bash  
+-++# Test selection with multiple related changes
+-++dotnet run --project src/TestIntelligence.CLI select \
+-++  --path TestIntelligence.sln \
+-++  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" "src/TestIntelligence.Core/TestAnalyzer.cs" \
+-++  --confidence Medium \
+-++  --output select-multifile.json
+-++```
+-++
+-++#### Scenario F: Max Tests Constraint
+-++```bash
+-++# Test that max-tests parameter is respected
+-++dotnet run --project src/TestIntelligence.CLI select \
+-++  --path TestIntelligence.sln \
+-++  --changes "src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs" \
+-++  --confidence High \
+-++  --max-tests 10 \
+-++  --output select-constrained.json
+-++```
+-++
+-++### Cleanup
+-++```bash
+-++# Restore original files after testing
+-++mv src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs.backup src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
+-++git checkout -- src/TestIntelligence.Core/TestAnalyzer.cs src/TestIntelligence.CLI/Commands/AnalyzeCommand.cs
+-++```
+-++
+-++## Usage Instructions for Claude
+-++
+-++When running this command:
+-++1. **Test all confidence levels** - verify the nested relationship and appropriateness
+-++2. **Validate time estimates** - check if they align with confidence level targets  
+-++3. **Cross-reference results** - use find-tests and analyze-coverage to verify selections
+-++4. **Check edge cases** - test with multiple files, constraints, and different change types
+-++5. **Assess relevance scoring** - ensure tests are ranked appropriately by impact likelihood
+-++6. **Verify completeness** - look for missing tests that should be included
+-++7. **Report systematically** - document accuracy, gaps, and recommendations
+-++
+-++This testing ensures the select command provides intelligent, accurate test selection that balances coverage with execution efficiency across different confidence levels.
+-+\ No newline at end of file
+-+diff --git a/Directory.Build.props b/Directory.Build.props
+-+index 14da534..fe3608c 100644
+-+--- a/Directory.Build.props
+-++++ b/Directory.Build.props
+-+@@ -10,7 +10,7 @@
+-+     <LangVersion>latest</LangVersion>
+-+     <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
+-+     <WarningsAsErrors />
+-+-    <WarningsNotAsErrors>NU1605;NU1701</WarningsNotAsErrors>
+-++    <WarningsNotAsErrors>NU1605;NU1701;MSB3277</WarningsNotAsErrors>
+-+     
+-+     <!-- Common package metadata -->
+-+     <Authors>TestIntelligence Contributors</Authors>
+-+diff --git a/src/TestIntelligence.CLI/Commands/BaseCommandHandler.cs b/src/TestIntelligence.CLI/Commands/BaseCommandHandler.cs
+-+index 3118751..5892681 100644
+-+--- a/src/TestIntelligence.CLI/Commands/BaseCommandHandler.cs
+-++++ b/src/TestIntelligence.CLI/Commands/BaseCommandHandler.cs
+-+@@ -35,28 +35,113 @@ namespace TestIntelligence.CLI.Commands
+-+             catch (OperationCanceledException)
+-+             {
+-+                 Logger.LogInformation("Command execution was cancelled");
+-+-                return 1;
+-++                Console.Error.WriteLine("Operation was cancelled by user.");
+-++                return 130; // Standard exit code for cancelled operations
+-+             }
+-+             catch (ArgumentException ex)
+-+             {
+-+                 Logger.LogError(ex, "Invalid arguments provided to command");
+-+-                Console.Error.WriteLine($"Error: {ex.Message}");
+-++                Console.Error.WriteLine($"‚ùå Invalid argument: {ex.Message}");
+-++                PrintUsageHint(context);
+-+                 return 1;
+-+             }
+-++            catch (FileNotFoundException ex)
+-++            {
+-++                Logger.LogError(ex, "Required file not found");
+-++                Console.Error.WriteLine($"‚ùå File not found: {ex.FileName ?? ex.Message}");
+-++                Console.Error.WriteLine("Please verify that the file path is correct and accessible.");
+-++                return 2;
+-++            }
+-++            catch (DirectoryNotFoundException ex)
+-++            {
+-++                Logger.LogError(ex, "Required directory not found");
+-++                Console.Error.WriteLine($"‚ùå Directory not found: {ex.Message}");
+-++                Console.Error.WriteLine("Please verify that the directory path is correct and accessible.");
+-++                return 2;
+-++            }
+-++            catch (UnauthorizedAccessException ex)
+-++            {
+-++                Logger.LogError(ex, "Access denied to file or directory");
+-++                Console.Error.WriteLine($"‚ùå Access denied: {ex.Message}");
+-++                Console.Error.WriteLine("Please check file/directory permissions or run with appropriate privileges.");
+-++                return 13; // Standard exit code for permission denied
+-++            }
+-++            catch (TimeoutException ex)
+-++            {
+-++                Logger.LogError(ex, "Operation timed out");
+-++                Console.Error.WriteLine($"‚ùå Operation timed out: {ex.Message}");
+-++                Console.Error.WriteLine("The operation took longer than expected. Try reducing the scope or running again.");
+-++                return 124; // Standard exit code for timeout
+-++            }
+-++            catch (System.IO.FileLoadException ex) when (ex.Message.Contains("Microsoft.Bcl.AsyncInterfaces"))
+-++            {
+-++                Logger.LogError(ex, "Assembly loading conflict detected");
+-++                Console.Error.WriteLine("‚ùå Assembly conflict detected:");
+-++                Console.Error.WriteLine($"   {ex.Message}");
+-++                Console.Error.WriteLine();
+-++                Console.Error.WriteLine("üí° This is usually caused by conflicting package versions. Try:");
+-++                Console.Error.WriteLine("   ‚Ä¢ Clearing NuGet cache: dotnet nuget locals all --clear");
+-++                Console.Error.WriteLine("   ‚Ä¢ Rebuilding the solution: dotnet clean && dotnet build");
+-++                Console.Error.WriteLine("   ‚Ä¢ Updating packages to consistent versions");
+-++                return 125; // Custom exit code for assembly conflicts
+-++            }
+-++            catch (System.Reflection.ReflectionTypeLoadException ex)
+-++            {
+-++                Logger.LogError(ex, "Failed to load types from assembly");
+-++                Console.Error.WriteLine("‚ùå Failed to load assembly types:");
+-++                if (ex.LoaderExceptions != null)
+-++                {
+-++                    foreach (var loaderEx in ex.LoaderExceptions.Take(3))
+-++                    {
+-++                        Console.Error.WriteLine($"   ‚Ä¢ {loaderEx?.Message}");
+-++                    }
+-++                    if (ex.LoaderExceptions.Length > 3)
+-++                    {
+-++                        Console.Error.WriteLine($"   ... and {ex.LoaderExceptions.Length - 3} more errors");
+-++                    }
+-++                }
+-++                Console.Error.WriteLine();
+-++                Console.Error.WriteLine("üí° This usually indicates missing dependencies or version mismatches.");
+-++                Console.Error.WriteLine("   Check that all required packages are installed and compatible.");
+-++                return 126; // Custom exit code for type loading failures
+-++            }
+-++            catch (OutOfMemoryException ex)
+-++            {
+-++                Logger.LogError(ex, "Out of memory during command execution");
+-++                Console.Error.WriteLine("‚ùå Insufficient memory to complete the operation.");
+-++                Console.Error.WriteLine("üí° Try reducing the scope (e.g., analyze fewer files) or increase available memory.");
+-++                return 127; // Custom exit code for memory issues
+-++            }
+-+             catch (Exception ex)
+-+             {
+-+                 Logger.LogError(ex, "Unexpected error during command execution");
+-+-                Console.Error.WriteLine($"Error: {ex.Message}");
+-++                Console.Error.WriteLine($"‚ùå Unexpected error: {ex.Message}");
+-+                 
+-+                 if (Logger.IsEnabled(LogLevel.Debug))
+-+                 {
+-+                     Console.Error.WriteLine($"Stack trace: {ex.StackTrace}");
+-+                 }
+-++                else
+-++                {
+-++                    Console.Error.WriteLine("Use --verbose for detailed error information.");
+-++                }
+-++                
+-++                Console.Error.WriteLine();
+-++                Console.Error.WriteLine("üí° If this error persists, please report it at:");
+-++                Console.Error.WriteLine("   https://github.com/TestIntelligence/TestIntelligence/issues");
+-+                 
+-+                 return 1;
+-+             }
+-+         }
+-+ 
+-++        /// <summary>
+-++        /// Prints usage hint for the current command.
+-++        /// </summary>
+-++        protected virtual void PrintUsageHint(CommandContext context)
+-++        {
+-++            Console.Error.WriteLine("üí° Use --help to see available options and usage examples.");
+-++        }
+-++
+-+         /// <summary>
+-+         /// Executes the command-specific logic. Override this in derived classes.
+-+         /// </summary>
+-+diff --git a/src/TestIntelligence.CLI/Commands/FindTestsCommandHandler.cs b/src/TestIntelligence.CLI/Commands/FindTestsCommandHandler.cs
+-+index 615231e..3ba1564 100644
+-+--- a/src/TestIntelligence.CLI/Commands/FindTestsCommandHandler.cs
+-++++ b/src/TestIntelligence.CLI/Commands/FindTestsCommandHandler.cs
+-+@@ -1,4 +1,5 @@
+-+ using System;
+-++using System.Collections.Generic;
+-+ using System.IO;
+-+ using System.Linq;
+-+ using System.Text;
+-+@@ -7,6 +8,7 @@ using System.Threading.Tasks;
+-+ using Microsoft.Extensions.Logging;
+-+ using TestIntelligence.CLI.Services;
+-+ using TestIntelligence.Core.Services;
+-++using TestIntelligence.Core.Models;
+-+ 
+-+ namespace TestIntelligence.CLI.Commands;
+-+ 
+-+@@ -32,27 +34,61 @@ public class FindTestsCommandHandler : BaseCommandHandler
+-+         var format = context.GetParameter<string>("format") ?? "text";
+-+         var verbose = context.GetParameter<bool>("verbose");
+-+ 
+-++        // Additional validation
+-++        ValidateInputs(method!, solution!, output, format);
+-++
+-+         Logger.LogInformation("Finding tests that exercise method: {Method} in solution: {Solution}", method, solution);
+-+         
+-+         // Get services from DI
+-+         var testCoverageAnalyzer = context.GetService<ITestCoverageAnalyzer>();
+-+         var outputFormatter = context.GetService<IOutputFormatter>();
+-+         
+-++        if (testCoverageAnalyzer == null)
+-++        {
+-++            throw new InvalidOperationException("Test coverage analyzer service is not available. Please check the application configuration.");
+-++        }
+-++        
+-++        if (outputFormatter == null)
+-++        {
+-++            throw new InvalidOperationException("Output formatter service is not available. Please check the application configuration.");
+-++        }
+-++        
+-+         Console.WriteLine($"Finding tests that exercise method: {method}");
+-+         Console.WriteLine($"Solution path: {solution}");
+-+         Console.WriteLine();
+-+ 
+-+-        var tests = await testCoverageAnalyzer.FindTestsExercisingMethodAsync(method!, solution!);
+-+-        
+-+-        if (!tests.Any())
+-++        IReadOnlyList<TestCoverageInfo> tests;
+-++        try
+-+         {
+-+-            Console.WriteLine("No tests found that exercise this method.");
+-++            tests = await testCoverageAnalyzer.FindTestsExercisingMethodAsync(method!, solution!, cancellationToken);
+-++            
+-++            if (tests == null || !tests.Any())
+-++            {
+-++                Console.WriteLine("No tests found that exercise this method.");
+-++                Console.WriteLine();
+-++                Console.WriteLine("üí° This could mean:");
+-++                Console.WriteLine("   ‚Ä¢ The method name/signature is incorrect");
+-++                Console.WriteLine("   ‚Ä¢ No tests actually exercise this method");
+-++                Console.WriteLine("   ‚Ä¢ The method is not public or accessible");
+-++                Console.WriteLine("   ‚Ä¢ There are compilation errors preventing analysis");
+-++                return 0;
+-++            }
+-++
+-++            Console.WriteLine($"Found {tests.Count} test(s) exercising this method:");
+-++            Console.WriteLine();
+-++        }
+-++        catch (ArgumentException)
+-++        {
+-++            // Re-throw argument exceptions to be handled by base class
+-++            throw;
+-++        }
+-++        catch (Exception ex) when (ex.Message.Contains("No test methods found"))
+-++        {
+-++            Console.WriteLine("No test methods found in the solution.");
+-++            Console.WriteLine("üí° Make sure the solution builds successfully and contains test projects.");
+-+             return 0;
+-+         }
+-+ 
+-+-        Console.WriteLine($"Found {tests.Count} test(s) exercising this method:");
+-+-        Console.WriteLine();
+-+-
+-+         if (format == "json")
+-+         {
+-+             var json = outputFormatter.FormatAsJson(tests);
+-+@@ -100,4 +136,45 @@ public class FindTestsCommandHandler : BaseCommandHandler
+-+         
+-+         return 0;
+-+     }
+-++
+-++    /// <summary>
+-++    /// Validates the input parameters for the find-tests command.
+-++    /// </summary>
+-++    private void ValidateInputs(string method, string solution, string? output, string format)
+-++    {
+-++        // Validate solution file exists
+-++        if (!File.Exists(solution))
+-++        {
+-++            throw new FileNotFoundException($"Solution file not found: {solution}");
+-++        }
+-++
+-++        // Validate method format (basic validation)
+-++        if (!method.Contains('.'))
+-++        {
+-++            throw new ArgumentException($"Method parameter should be in format 'Namespace.Class.Method', got: {method}");
+-++        }
+-++
+-++        // Validate output format
+-++        if (!string.Equals(format, "json", StringComparison.OrdinalIgnoreCase) && 
+-++            !string.Equals(format, "text", StringComparison.OrdinalIgnoreCase))
+-++        {
+-++            throw new ArgumentException($"Format must be 'json' or 'text', got: {format}");
+-++        }
+-++
+-++        // Validate output path if provided
+-++        if (!string.IsNullOrWhiteSpace(output))
+-++        {
+-++            var outputDir = Path.GetDirectoryName(Path.GetFullPath(output));
+-++            if (!string.IsNullOrEmpty(outputDir) && !Directory.Exists(outputDir))
+-++            {
+-++                throw new DirectoryNotFoundException($"Output directory does not exist: {outputDir}");
+-++            }
+-++        }
+-++    }
+-++
+-++    protected override void PrintUsageHint(CommandContext context)
+-++    {
+-++        Console.Error.WriteLine("üí° Usage: find-tests --method \"Namespace.Class.Method\" --solution \"path/to/solution.sln\"");
+-++        Console.Error.WriteLine("   Example: find-tests --method \"MyApp.Services.UserService.GetUser\" --solution \"MyApp.sln\"");
+-++    }
+-+ }
+-+\ No newline at end of file
+-+diff --git a/src/TestIntelligence.CLI/TestIntelligence.CLI.csproj b/src/TestIntelligence.CLI/TestIntelligence.CLI.csproj
+-+index c25bbd3..259c88d 100644
+-+--- a/src/TestIntelligence.CLI/TestIntelligence.CLI.csproj
+-++++ b/src/TestIntelligence.CLI/TestIntelligence.CLI.csproj
+-+@@ -27,6 +27,8 @@
+-+     <PackageReference Include="Microsoft.Extensions.Logging" Version="8.0.0" />
+-+     <PackageReference Include="Microsoft.Extensions.Logging.Console" Version="8.0.0" />
+-+     <PackageReference Include="Microsoft.Build.Locator" Version="1.6.10" />
+-++    <!-- Explicit reference to resolve conflicts -->
+-++    <PackageReference Include="Microsoft.Bcl.AsyncInterfaces" Version="8.0.0" />
+-+   </ItemGroup>
+-+ 
+-+   <ItemGroup>
+-+diff --git a/src/TestIntelligence.Core/Models/TestCoverageInfo.cs b/src/TestIntelligence.Core/Models/TestCoverageInfo.cs
+-+index a7b865a..0f50511 100644
+-+--- a/src/TestIntelligence.Core/Models/TestCoverageInfo.cs
+-++++ b/src/TestIntelligence.Core/Models/TestCoverageInfo.cs
+-+@@ -192,10 +192,15 @@ namespace TestIntelligence.Core.Models
+-+             if (fullMethodId.Equals(pattern, StringComparison.OrdinalIgnoreCase))
+-+                 return true;
+-+ 
+-+-            // Extract method name without parameters from full ID
+-++            // Remove global:: prefix if present for comparison
+-++            var normalizedMethodId = fullMethodId.StartsWith("global::", StringComparison.OrdinalIgnoreCase) 
+-++                ? fullMethodId.Substring(8) // Remove "global::" prefix
+-++                : fullMethodId;
+-++
+-++            // Extract method name without parameters from normalized ID
+-+             // Format: Namespace.Class.Method(params)
+-+-            var parenIndex = fullMethodId.IndexOf('(');
+-+-            var methodWithoutParams = parenIndex > 0 ? fullMethodId.Substring(0, parenIndex) : fullMethodId;
+-++            var parenIndex = normalizedMethodId.IndexOf('(');
+-++            var methodWithoutParams = parenIndex > 0 ? normalizedMethodId.Substring(0, parenIndex) : normalizedMethodId;
+-+ 
+-+             // Check if pattern matches the method without parameters
+-+             if (methodWithoutParams.Equals(pattern, StringComparison.OrdinalIgnoreCase))
+-+diff --git a/src/TestIntelligence.Core/TestIntelligence.Core.csproj b/src/TestIntelligence.Core/TestIntelligence.Core.csproj
+-+index 1cbbd22..3c05933 100644
+-+--- a/src/TestIntelligence.Core/TestIntelligence.Core.csproj
+-++++ b/src/TestIntelligence.Core/TestIntelligence.Core.csproj
+-+@@ -23,7 +23,7 @@
+-+     <PackageReference Include="System.Reflection.Metadata" Version="8.0.0" />
+-+     <PackageReference Include="System.Runtime.Loader" Version="4.3.0" />
+-+     <PackageReference Include="System.Reflection.MetadataLoadContext" Version="8.0.0" />
+-+-    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="6.0.4" />
+-++    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="8.0.0" />
+-+     <PackageReference Include="System.Text.Json" Version="8.0.5" />
+-+   </ItemGroup>
+-+ 
+-+diff --git a/src/TestIntelligence.DataTracker/TestIntelligence.DataTracker.csproj b/src/TestIntelligence.DataTracker/TestIntelligence.DataTracker.csproj
+-+index 5440411..dfbdb37 100644
+-+--- a/src/TestIntelligence.DataTracker/TestIntelligence.DataTracker.csproj
+-++++ b/src/TestIntelligence.DataTracker/TestIntelligence.DataTracker.csproj
+-+@@ -19,7 +19,7 @@
+-+   </PropertyGroup>
+-+ 
+-+   <ItemGroup>
+-+-    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="6.0.4" />
+-++    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="8.0.0" />
+-+     <!-- Entity Framework packages for database pattern detection -->
+-+     <PackageReference Include="Microsoft.EntityFrameworkCore" Version="3.1.32" />
+-+     <PackageReference Include="EntityFramework" Version="6.4.4" />
+-+diff --git a/src/TestIntelligence.ImpactAnalyzer/Analysis/LazyWorkspaceBuilder.cs b/src/TestIntelligence.ImpactAnalyzer/Analysis/LazyWorkspaceBuilder.cs
+-+index d91c774..40a3d3c 100644
+-+--- a/src/TestIntelligence.ImpactAnalyzer/Analysis/LazyWorkspaceBuilder.cs
+-++++ b/src/TestIntelligence.ImpactAnalyzer/Analysis/LazyWorkspaceBuilder.cs
+-+@@ -138,23 +138,50 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
+-+         {
+-+             return await _projectCache.GetOrAdd(projectPath, async path =>
+-+             {
+-++                CancellationTokenSource? timeoutCts = null;
+-++                CancellationTokenSource? combinedCts = null;
+-++                
+-+                 try
+-+                 {
+-+                     _logger.LogDebug("Loading project on-demand: {ProjectPath}", path);
+-+                     var startTime = DateTime.UtcNow;
+-+ 
+-+-                    var project = await _workspace.OpenProjectAsync(path);
+-++                    // Add timeout to prevent hanging on project loading
+-++                    timeoutCts = new CancellationTokenSource(TimeSpan.FromSeconds(15));
+-++                    combinedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, timeoutCts.Token);
+-++
+-++                    var projectTask = _workspace.OpenProjectAsync(path);
+-++                    var timeoutTask = Task.Delay(TimeSpan.FromSeconds(15), combinedCts.Token);
+-++                    
+-++                    var completedTask = await Task.WhenAny(projectTask, timeoutTask);
+-++                    if (completedTask == timeoutTask)
+-++                    {
+-++                        _logger.LogWarning("Project loading timed out after 15 seconds: {ProjectPath}", path);
+-++                        return null;
+-++                    }
+-++                    
+-++                    var project = await projectTask;
+-+                     
+-+                     var elapsed = DateTime.UtcNow - startTime;
+-+                     _logger.LogDebug("Project loaded in {ElapsedMs}ms: {ProjectName}", elapsed.TotalMilliseconds, project.Name);
+-+ 
+-+                     return project;
+-+                 }
+-++                catch (OperationCanceledException) when (timeoutCts?.Token.IsCancellationRequested == true)
+-++                {
+-++                    _logger.LogWarning("Project loading timed out after 15 seconds: {ProjectPath}", path);
+-++                    return null;
+-++                }
+-+                 catch (Exception ex)
+-+                 {
+-+                     _logger.LogError(ex, "Failed to load project: {ProjectPath}", path);
+-+                     return null;
+-+                 }
+-++                finally
+-++                {
+-++                    timeoutCts?.Dispose();
+-++                    combinedCts?.Dispose();
+-++                }
+-+             });
+-+         }
+-+ 
+-+@@ -291,8 +318,32 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
+-+         {
+-+             _logger.LogDebug("Loading solution metadata: {SolutionPath}", solutionPath);
+-+             
+-+-            // Load solution directly - we'll manage project loading separately
+-+-            _solution = await _workspace.OpenSolutionAsync(solutionPath);
+-++            // Load solution directly with timeout to prevent hanging
+-++            using var timeoutCts = new CancellationTokenSource(TimeSpan.FromSeconds(30));
+-++            using var combinedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, timeoutCts.Token);
+-++            
+-++            try
+-++            {
+-++                var solutionTask = _workspace.OpenSolutionAsync(solutionPath);
+-++                var timeoutTask = Task.Delay(TimeSpan.FromSeconds(30), combinedCts.Token);
+-++                
+-++                var completedTask = await Task.WhenAny(solutionTask, timeoutTask);
+-++                if (completedTask == timeoutTask)
+-++                {
+-++                    _logger.LogWarning("Solution loading timed out after 30 seconds, falling back to manual solution parsing");
+-++                    await InitializeFromSolutionManuallyAsync(solutionPath, cancellationToken);
+-++                    return;
+-++                }
+-++                
+-++                _solution = await solutionTask;
+-++            }
+-++            catch (OperationCanceledException) when (timeoutCts.Token.IsCancellationRequested)
+-++            {
+-++                _logger.LogWarning("Solution loading timed out after 30 seconds, falling back to manual solution parsing");
+-++                await InitializeFromSolutionManuallyAsync(solutionPath, cancellationToken);
+-++                return;
+-++            }
+-++            
+-+             var solutionInfo = _solution;
+-+ 
+-+             // Build file-to-project mapping from solution
+-+@@ -336,6 +387,70 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
+-+             }
+-+         }
+-+ 
+-++        /// <summary>
+-++        /// Manual solution parsing fallback when MSBuild workspace fails
+-++        /// </summary>
+-++        private async Task InitializeFromSolutionManuallyAsync(string solutionPath, CancellationToken cancellationToken)
+-++        {
+-++            try
+-++            {
+-++                _logger.LogInformation("Using manual solution parsing for: {SolutionPath}", solutionPath);
+-++                
+-++                // Parse solution file manually to get project paths
+-++                var solutionDir = Path.GetDirectoryName(solutionPath)!;
+-++                var solutionLines = await File.ReadAllLinesAsync(solutionPath, cancellationToken);
+-++                
+-++                var projectPaths = new List<string>();
+-++                foreach (var line in solutionLines)
+-++                {
+-++                    // Look for project lines: Project("{...}") = "ProjectName", "RelativePath", "{...}"
+-++                    if (line.StartsWith("Project(") && line.Contains(".csproj"))
+-++                    {
+-++                        var parts = line.Split(',');
+-++                        if (parts.Length >= 2)
+-++                        {
+-++                            var relativePath = parts[1].Trim().Trim('"');
+-++                            var fullPath = Path.GetFullPath(Path.Combine(solutionDir, relativePath));
+-++                            if (File.Exists(fullPath))
+-++                            {
+-++                                projectPaths.Add(fullPath);
+-++                            }
+-++                        }
+-++                    }
+-++                }
+-++                
+-++                _logger.LogInformation("Found {ProjectCount} projects via manual parsing", projectPaths.Count);
+-++                
+-++                // Build file-to-project mapping using file system scanning
+-++                foreach (var projectPath in projectPaths)
+-++                {
+-++                    try
+-++                    {
+-++                        var projectDir = Path.GetDirectoryName(projectPath)!;
+-++                        var csFiles = Directory.GetFiles(projectDir, "*.cs", SearchOption.AllDirectories)
+-++                            .Where(f => !f.Contains("bin") && !f.Contains("obj") && !f.Contains("packages"));
+-++                        
+-++                        foreach (var file in csFiles)
+-++                        {
+-++                            _fileToProjectMap[file] = projectPath;
+-++                        }
+-++                    }
+-++                    catch (Exception ex)
+-++                    {
+-++                        _logger.LogDebug(ex, "Failed to scan project directory: {ProjectPath}", projectPath);
+-++                    }
+-++                }
+-++                
+-++                _logger.LogInformation("Manual solution parsing completed: {ProjectCount} projects, {FileCount} file mappings", 
+-++                    projectPaths.Count, _fileToProjectMap.Count);
+-++            }
+-++            catch (Exception ex)
+-++            {
+-++                _logger.LogError(ex, "Manual solution parsing failed for: {SolutionPath}", solutionPath);
+-++                throw;
+-++            }
+-++        }
+-++
+-+         private void OnWorkspaceFailed(object? sender, WorkspaceDiagnosticEventArgs e)
+-+         {
+-+             _logger.LogDebug("Workspace diagnostic: {Kind} - {Message}", e.Diagnostic.Kind, e.Diagnostic.Message);
+-+diff --git a/src/TestIntelligence.ImpactAnalyzer/Analysis/RoslynAnalyzer.cs b/src/TestIntelligence.ImpactAnalyzer/Analysis/RoslynAnalyzer.cs
+-+index 9648e81..9a182a8 100644
+-+--- a/src/TestIntelligence.ImpactAnalyzer/Analysis/RoslynAnalyzer.cs
+-++++ b/src/TestIntelligence.ImpactAnalyzer/Analysis/RoslynAnalyzer.cs
+-+@@ -62,7 +62,9 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
+-+                 // Initialize lazy workspace for much better performance
+-+                 await InitializeLazyWorkspaceAsync(solutionFile, cancellationToken).ConfigureAwait(false);
+-+ 
+-+-                if (_incrementalCallGraphBuilder != null)
+-++                // TEMPORARY FIX: Disable incremental call graph builder due to placeholder implementation
+-++                // The GetMethodIdsFromFile method returns empty lists, causing 0 methods to be analyzed
+-++                if (false && _incrementalCallGraphBuilder != null)
+-+                 {
+-+                     _logger.LogInformation("Using high-performance incremental call graph builder");
+-+                     // For full solution analysis, we still need to analyze all files, but incrementally
+-+@@ -71,6 +73,7 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
+-+                 }
+-+                 
+-+                 // Fallback to legacy full analysis
+-++                _logger.LogInformation("Using legacy call graph builder (incremental builder temporarily disabled)");
+-+                 await InitializeWorkspaceAsync(solutionFile, cancellationToken).ConfigureAwait(false);
+-+ 
+-+                 if (_callGraphBuilder == null)
+-+diff --git a/src/TestIntelligence.ImpactAnalyzer/Analysis/SolutionWorkspaceBuilder.cs b/src/TestIntelligence.ImpactAnalyzer/Analysis/SolutionWorkspaceBuilder.cs
+-+index eb69959..b30e8e6 100644
+-+--- a/src/TestIntelligence.ImpactAnalyzer/Analysis/SolutionWorkspaceBuilder.cs
+-++++ b/src/TestIntelligence.ImpactAnalyzer/Analysis/SolutionWorkspaceBuilder.cs
+-+@@ -168,24 +168,37 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
+-+             try
+-+             {
+-+                 _logger.LogDebug("Loading solution using MSBuild workspace: {SolutionPath}", solutionPath);
+-+-                var solution = await workspace.OpenSolutionAsync(solutionPath, cancellationToken: cancellationToken);
+-+                 
+-+-                _logger.LogInformation("Solution loaded with {ProjectCount} projects", solution.Projects.Count());
+-++                // Apply timeout to prevent hanging - MSBuild operations can hang indefinitely
+-++                using var timeoutCts = new CancellationTokenSource(TimeSpan.FromMinutes(2)); // 2 minute timeout for solution loading
+-++                using var combinedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, timeoutCts.Token);
+-+                 
+-+-                // Log any diagnostics
+-+-                foreach (var diagnostic in workspace.Diagnostics)
+-++                try
+-+                 {
+-+-                    if (diagnostic.Kind == WorkspaceDiagnosticKind.Failure)
+-+-                    {
+-+-                        _logger.LogWarning("Workspace diagnostic: {Message}", diagnostic.Message);
+-+-                    }
+-+-                    else
+-++                    var solution = await workspace.OpenSolutionAsync(solutionPath, cancellationToken: combinedCts.Token);
+-++                    
+-++                    _logger.LogInformation("Solution loaded with {ProjectCount} projects", solution.Projects.Count());
+-++                    
+-++                    // Log any diagnostics
+-++                    foreach (var diagnostic in workspace.Diagnostics)
+-+                     {
+-+-                        _logger.LogDebug("Workspace diagnostic: {Message}", diagnostic.Message);
+-++                        if (diagnostic.Kind == WorkspaceDiagnosticKind.Failure)
+-++                        {
+-++                            _logger.LogWarning("Workspace diagnostic: {Message}", diagnostic.Message);
+-++                        }
+-++                        else
+-++                        {
+-++                            _logger.LogDebug("Workspace diagnostic: {Message}", diagnostic.Message);
+-++                        }
+-+                     }
+-++                    
+-++                    return solution;
+-++                }
+-++                catch (OperationCanceledException) when (timeoutCts.Token.IsCancellationRequested)
+-++                {
+-++                    _logger.LogError("Solution loading timed out after 2 minutes: {SolutionPath}", solutionPath);
+-++                    throw new TimeoutException($"Solution loading timed out after 2 minutes. This may indicate MSBuild version conflicts or complex solution structure: {solutionPath}");
+-+                 }
+-+-                
+-+-                return solution;
+-+             }
+-+             catch (Exception ex)
+-+             {
+-+diff --git a/src/TestIntelligence.ImpactAnalyzer/Analysis/SymbolIndex.cs b/src/TestIntelligence.ImpactAnalyzer/Analysis/SymbolIndex.cs
+-+index aa9727c..12a61fa 100644
+-+--- a/src/TestIntelligence.ImpactAnalyzer/Analysis/SymbolIndex.cs
+-++++ b/src/TestIntelligence.ImpactAnalyzer/Analysis/SymbolIndex.cs
+-+@@ -283,12 +283,13 @@ namespace TestIntelligence.ImpactAnalyzer.Analysis
+-+                     var solutionContent = File.ReadAllText(solutionPath);
+-+                     
+-+                     // Simple regex to find project references in solution file
+-+-                    var projectPattern = new Regex(@"Project\(.+\)\s*=\s*"".+"",\s*""([^""]+\.(?:cs|vb|fs)proj)""", RegexOptions.Compiled);
+-++                    var projectPattern = new Regex(@"Project\(.+\)\s*=\s*"".+"",\s*""([^""]+\.(?:csproj|vbproj|fsproj))""", RegexOptions.Compiled);
+-+                     var matches = projectPattern.Matches(solutionContent);
+-+                     
+-+                     foreach (Match match in matches)
+-+                     {
+-+-                        var projectPath = Path.Combine(solutionDir, match.Groups[1].Value);
+-++                        var relativePath = match.Groups[1].Value.Replace('\\', Path.DirectorySeparatorChar);
+-++                        var projectPath = Path.Combine(solutionDir, relativePath);
+-+                         if (File.Exists(projectPath))
+-+                         {
+-+                             var projectFiles = await GetSourceFilesFromProjectAsync(projectPath, cancellationToken);
+-+diff --git a/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs b/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs
+-+index b96e163..d7f075c 100644
+-+--- a/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs
+-++++ b/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs
+-+@@ -85,14 +85,39 @@ namespace TestIntelligence.ImpactAnalyzer.Services
+-+                 // Try to build call graph with MSBuild workspace first, fallback to assembly analysis
+-+                 try 
+-+                 {
+-++                    // Apply timeout to prevent hanging during call graph building
+-++                    using var timeoutCts = new CancellationTokenSource(TimeSpan.FromMinutes(3)); // 3 minute timeout
+-++                    using var combinedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, timeoutCts.Token);
+-++                    
+-+                     // Build the complete call graph using the solution path
+-+                     // The Roslyn analyzer will handle finding source files and prefer MSBuild workspace if .sln is provided
+-+-                    callGraph = await _roslynAnalyzer.BuildCallGraphAsync(new[] { solutionPath }, cancellationToken);
+-++                    callGraph = await _roslynAnalyzer.BuildCallGraphAsync(new[] { solutionPath }, combinedCts.Token);
+-+                     
+-+                     // Cache the result
+-+                     _cachedCallGraph = callGraph;
+-+                     _cachedSolutionPath = solutionPath;
+-+                 }
+-++                catch (TimeoutException ex)
+-++                {
+-++                    _logger.LogWarning(ex, "Call graph building timed out after 3 minutes, falling back to assembly-based analysis");
+-++                    
+-++                    // Fallback: Try to analyze compiled assemblies instead
+-++                    var assemblyPaths = FindTestAssembliesInSolution(solutionPath);
+-++                    if (assemblyPaths.Any())
+-++                    {
+-++                        _logger.LogInformation("Found {AssemblyCount} test assemblies for fallback analysis", assemblyPaths.Count);
+-++                        callGraph = await _roslynAnalyzer.BuildCallGraphAsync(assemblyPaths.ToArray(), cancellationToken);
+-++                        
+-++                        // Cache the result
+-++                        _cachedCallGraph = callGraph;
+-++                        _cachedSolutionPath = solutionPath;
+-++                    }
+-++                    else
+-++                    {
+-++                        _logger.LogWarning("No assemblies found for fallback analysis");
+-++                        return new TestCoverageMap(new Dictionary<string, List<TestCoverageInfo>>(), DateTime.UtcNow, solutionPath);
+-++                    }
+-++                }
+-+                 catch (InvalidOperationException ex) when (ex.Message.Contains("System.CodeDom") || ex.Message.Contains("MSBuild workspace"))
+-+                 {
+-+                     _logger.LogWarning(ex, "MSBuild workspace failed, falling back to assembly-based analysis");
+-+@@ -536,6 +561,16 @@ namespace TestIntelligence.ImpactAnalyzer.Services
+-+ 
+-+             var testMethods = _testClassifier.GetTestMethods(allMethods);
+-+             _logger.LogInformation("Found {TestMethodCount} test methods for streaming analysis", testMethods.Count);
+-++            
+-++            // Find actual method IDs that match the user's pattern
+-++            var targetMethodIds = FindMatchingMethodIds(methodId, allMethods);
+-++            _logger.LogDebug("Found {Count} target method IDs matching pattern: {Pattern}", targetMethodIds.Count, methodId);
+-++            
+-++            if (targetMethodIds.Count == 0)
+-++            {
+-++                _logger.LogWarning("No methods found matching pattern: {MethodId}", methodId);
+-++                yield break;
+-++            }
+-+ 
+-+             // Process test methods and yield results as we find them
+-+             foreach (var testMethod in testMethods)
+-+@@ -545,10 +580,23 @@ namespace TestIntelligence.ImpactAnalyzer.Services
+-+                 TestCoverageInfo? result = null;
+-+                 try
+-+                 {
+-+-                    var callPath = FindCallPath(testMethod.Id, methodId, callGraph);
+-+-                    if (callPath != null && callPath.Any())
+-++                    // Try to find call paths to any of the matching target methods
+-++                    string[]? callPath = null;
+-++                    string? matchedTargetMethodId = null;
+-++                    
+-++                    foreach (var targetId in targetMethodIds)
+-+                     {
+-+-                        var confidence = CalculateConfidence(callPath, testMethod, callGraph.GetMethodInfo(methodId)!);
+-++                        callPath = FindCallPath(testMethod.Id, targetId, callGraph);
+-++                        if (callPath != null && callPath.Any())
+-++                        {
+-++                            matchedTargetMethodId = targetId;
+-++                            break;
+-++                        }
+-++                    }
+-++                    if (callPath != null && callPath.Any() && matchedTargetMethodId != null)
+-++                    {
+-++                        var targetMethodInfo = callGraph.GetMethodInfo(matchedTargetMethodId)!;
+-++                        var confidence = CalculateConfidence(callPath, testMethod, targetMethodInfo);
+-+                         var testType = _testClassifier.ClassifyTestType(testMethod);
+-+ 
+-+                         result = new TestCoverageInfo(
+-+@@ -616,5 +664,63 @@ namespace TestIntelligence.ImpactAnalyzer.Services
+-+             _pathCache.Clear();
+-+             _logger.LogDebug("Cleared all caches");
+-+         }
+-++
+-++        /// <summary>
+-++        /// Find all method IDs in the call graph that match the given pattern.
+-++        /// Handles global:: prefix and parameter variations.
+-++        /// </summary>
+-++        private List<string> FindMatchingMethodIds(string pattern, IReadOnlyList<MethodInfo> allMethods)
+-++        {
+-++            var matchingIds = new List<string>();
+-++            
+-++            foreach (var method in allMethods)
+-++            {
+-++                if (IsMethodPatternMatch(method.Id, pattern))
+-++                {
+-++                    matchingIds.Add(method.Id);
+-++                }
+-++            }
+-++            
+-++            return matchingIds;
+-++        }
+-++
+-++        /// <summary>
+-++        /// Determines if a method ID matches the given pattern.
+-++        /// Supports pattern matching like the TestCoverageMap.IsMethodMatch method.
+-++        /// </summary>
+-++        private static bool IsMethodPatternMatch(string fullMethodId, string pattern)
+-++        {
+-++            if (string.IsNullOrEmpty(fullMethodId) || string.IsNullOrEmpty(pattern))
+-++                return false;
+-++
+-++            // Exact match
+-++            if (fullMethodId.Equals(pattern, StringComparison.OrdinalIgnoreCase))
+-++                return true;
+-++
+-++            // Remove global:: prefix if present for comparison
+-++            var normalizedMethodId = fullMethodId.StartsWith("global::", StringComparison.OrdinalIgnoreCase) 
+-++                ? fullMethodId.Substring(8) // Remove "global::" prefix
+-++                : fullMethodId;
+-++
+-++            // Extract method name without parameters from normalized ID
+-++            // Format: Namespace.Class.Method(params)
+-++            var parenIndex = normalizedMethodId.IndexOf('(');
+-++            var methodWithoutParams = parenIndex > 0 ? normalizedMethodId.Substring(0, parenIndex) : normalizedMethodId;
+-++
+-++            // Check if pattern matches the method without parameters
+-++            if (methodWithoutParams.Equals(pattern, StringComparison.OrdinalIgnoreCase))
+-++                return true;
+-++
+-++            // Check if pattern is just the method name (last part after final dot)
+-++            var lastDotIndex = methodWithoutParams.LastIndexOf('.');
+-++            if (lastDotIndex >= 0 && lastDotIndex < methodWithoutParams.Length - 1)
+-++            {
+-++                var methodNameOnly = methodWithoutParams.Substring(lastDotIndex + 1);
+-++                if (methodNameOnly.Equals(pattern, StringComparison.OrdinalIgnoreCase))
+-++                    return true;
+-++            }
+-++
+-++            return false;
+-++        }
+-+     }
+-+ }
+-+\ No newline at end of file
+-+diff --git a/src/TestIntelligence.ImpactAnalyzer/TestIntelligence.ImpactAnalyzer.csproj b/src/TestIntelligence.ImpactAnalyzer/TestIntelligence.ImpactAnalyzer.csproj
+-+index 66261c7..1cb2408 100644
+-+--- a/src/TestIntelligence.ImpactAnalyzer/TestIntelligence.ImpactAnalyzer.csproj
+-++++ b/src/TestIntelligence.ImpactAnalyzer/TestIntelligence.ImpactAnalyzer.csproj
+-+@@ -1,7 +1,7 @@
+-+ <Project Sdk="Microsoft.NET.Sdk">
+-+ 
+-+   <PropertyGroup>
+-+-    <TargetFramework>netstandard2.0</TargetFramework>
+-++    <TargetFramework>netstandard2.1</TargetFramework>
+-+     <LangVersion>latest</LangVersion>
+-+     <Nullable>enable</Nullable>
+-+     <PackageId>TestIntelligence.ImpactAnalyzer</PackageId>
+-+@@ -28,6 +28,8 @@
+-+     <!-- Other dependencies provided by Directory.Build.props: Microsoft.CodeAnalysis.CSharp, Newtonsoft.Json, System.Collections.Immutable, System.CodeDom -->
+-+     <PackageReference Include="System.Reflection.Metadata" Version="8.0.0" />
+-+     <PackageReference Include="System.Text.Json" Version="8.0.5" />
+-++    <!-- Add explicit reference to fix MSBuild conflicts -->
+-++    <PackageReference Include="Microsoft.Build.Framework" Version="17.9.5" ExcludeAssets="runtime" />
+-+   </ItemGroup>
+-+ 
+-+   <ItemGroup>
+-+diff --git a/src/TestIntelligence.SelectionEngine/TestIntelligence.SelectionEngine.csproj b/src/TestIntelligence.SelectionEngine/TestIntelligence.SelectionEngine.csproj
+-+index 41ee1d0..3a1d337 100644
+-+--- a/src/TestIntelligence.SelectionEngine/TestIntelligence.SelectionEngine.csproj
+-++++ b/src/TestIntelligence.SelectionEngine/TestIntelligence.SelectionEngine.csproj
+-+@@ -1,7 +1,7 @@
+-+ <Project Sdk="Microsoft.NET.Sdk">
+-+ 
+-+   <PropertyGroup>
+-+-    <TargetFramework>netstandard2.0</TargetFramework>
+-++    <TargetFramework>netstandard2.1</TargetFramework>
+-+     <LangVersion>latest</LangVersion>
+-+     <Nullable>enable</Nullable>
+-+     <PackageId>TestIntelligence.SelectionEngine</PackageId>
+-+diff --git a/tests/TestIntelligence.SelectionEngine.Tests/Engine/TestSelectionEngineTests.cs b/tests/TestIntelligence.SelectionEngine.Tests/Engine/TestSelectionEngineTests.cs
+-+index d4d4c36..55b8911 100644
+-+--- a/tests/TestIntelligence.SelectionEngine.Tests/Engine/TestSelectionEngineTests.cs
+-++++ b/tests/TestIntelligence.SelectionEngine.Tests/Engine/TestSelectionEngineTests.cs
+-+@@ -205,5 +205,222 @@ namespace TestIntelligence.SelectionEngine.Tests.Engine
+-+         {
+-+             // Sample method for reflection
+-+         }
+-++
+-++        #region Integration Tests for ScoreTestsAsync
+-++
+-++        [Fact]
+-++        public async Task ScoreTestsAsync_WithMixedTestTypes_ShouldPrioritizeBasedOnCategory()
+-++        {
+-++            var tests = new[]
+-++            {
+-++                CreateTestInfo("FastUnitTest", TestCategory.Unit, TimeSpan.FromMilliseconds(50), 0.0),
+-++                CreateTestInfo("SlowIntegrationTest", TestCategory.Integration, TimeSpan.FromSeconds(2), 0.0),
+-++                CreateTestInfo("DatabaseTest", TestCategory.Database, TimeSpan.FromSeconds(5), 0.0),
+-++                CreateTestInfo("UITest", TestCategory.UI, TimeSpan.FromSeconds(10), 0.0)
+-++            };
+-++
+-++            var engine = new TestSelectionEngine(_mockLogger.Object, new[] { _mockScoringAlgorithm.Object });
+-++            
+-++            // Configure mock to return different scores based on category
+-++            _mockScoringAlgorithm.Setup(x => x.CalculateScoreAsync(It.IsAny<TestInfo>(), It.IsAny<TestScoringContext>(), It.IsAny<CancellationToken>()))
+-++                .Returns<TestInfo, TestScoringContext, CancellationToken>((test, context, ct) => test.Category switch
+-++                {
+-++                    TestCategory.Unit => Task.FromResult(0.9), // Highest priority for unit tests
+-++                    TestCategory.Integration => Task.FromResult(0.7),
+-++                    TestCategory.Database => Task.FromResult(0.5),
+-++                    TestCategory.UI => Task.FromResult(0.3), // Lowest priority for UI tests
+-++                    _ => Task.FromResult(0.1)
+-++                });
+-++
+-++            var scoredTests = await engine.ScoreTestsAsync(tests);
+-++
+-++            scoredTests.Should().HaveCount(4);
+-++            scoredTests[0].TestMethod.GetDisplayName().Should().Contain("FastUnitTest");
+-++            scoredTests[1].TestMethod.GetDisplayName().Should().Contain("SlowIntegrationTest");
+-++            scoredTests[2].TestMethod.GetDisplayName().Should().Contain("DatabaseTest");
+-++            scoredTests[3].TestMethod.GetDisplayName().Should().Contain("UITest");
+-++        }
+-++
+-++        [Fact]
+-++        public async Task ScoreTestsAsync_WithCodeChanges_ShouldBoostRelatedTests()
+-++        {
+-++            var changes = CreateCodeChangeSet();
+-++            var tests = new[]
+-++            {
+-++                CreateTestInfo("UnrelatedTest", TestCategory.Unit, TimeSpan.FromMilliseconds(100)),
+-++                CreateTestInfo("RelatedTest_MyMethod", TestCategory.Unit, TimeSpan.FromMilliseconds(100)),
+-++                CreateTestInfo("RelatedTest_MyClass", TestCategory.Integration, TimeSpan.FromMilliseconds(500))
+-++            };
+-++
+-++            var engine = new TestSelectionEngine(_mockLogger.Object, new[] { _mockScoringAlgorithm.Object });
+-++            
+-++            // Configure mock to boost scores for related tests
+-++            _mockScoringAlgorithm.Setup(x => x.CalculateScoreAsync(It.IsAny<TestInfo>(), It.IsAny<TestScoringContext>(), It.IsAny<CancellationToken>()))
+-++                .Returns<TestInfo, TestScoringContext, CancellationToken>((test, context, ct) =>
+-++                {
+-++                    if (test.TestMethod.GetDisplayName().Contains("Related"))
+-++                        return Task.FromResult(0.9); // High score for related tests
+-++                    return Task.FromResult(0.3); // Lower score for unrelated tests
+-++                });
+-++
+-++            var scoredTests = await engine.ScoreTestsAsync(tests, changes);
+-++
+-++            scoredTests.Should().HaveCount(3);
+-++            // Related tests should be scored higher and appear first
+-++            scoredTests.Take(2).All(t => t.TestMethod.GetDisplayName().Contains("Related")).Should().BeTrue();
+-++            scoredTests.Last().TestMethod.GetDisplayName().Should().Contain("UnrelatedTest");
+-++        }
+-++
+-++        [Fact]
+-++        public async Task ScoreTestsAsync_WithExecutionHistoryContext_ShouldConsiderReliability()
+-++        {
+-++            var tests = new[]
+-++            {
+-++                CreateTestInfo("FlakeyTest", TestCategory.Unit, TimeSpan.FromMilliseconds(100)),
+-++                CreateTestInfo("ReliableTest", TestCategory.Unit, TimeSpan.FromMilliseconds(150)),
+-++                CreateTestInfo("NewTest", TestCategory.Unit, TimeSpan.FromMilliseconds(80))
+-++            };
+-++
+-++            // Simulate execution history for the tests
+-++            var flakeyTest = tests[0];
+-++            foreach(var result in new[]
+-++            {
+-++                new TestExecutionResult(false, TimeSpan.FromMilliseconds(100), DateTimeOffset.UtcNow.AddDays(-1)), // Failed
+-++                new TestExecutionResult(true, TimeSpan.FromMilliseconds(95), DateTimeOffset.UtcNow.AddHours(-12)), // Passed
+-++                new TestExecutionResult(false, TimeSpan.FromMilliseconds(110), DateTimeOffset.UtcNow.AddHours(-6)) // Failed
+-++            }) { flakeyTest.ExecutionHistory.Add(result); }
+-++
+-++            var reliableTest = tests[1];
+-++            foreach(var result in new[]
+-++            {
+-++                new TestExecutionResult(true, TimeSpan.FromMilliseconds(150), DateTimeOffset.UtcNow.AddDays(-1)), // Passed
+-++                new TestExecutionResult(true, TimeSpan.FromMilliseconds(145), DateTimeOffset.UtcNow.AddHours(-12)), // Passed
+-++                new TestExecutionResult(true, TimeSpan.FromMilliseconds(155), DateTimeOffset.UtcNow.AddHours(-6)) // Passed
+-++            }) { reliableTest.ExecutionHistory.Add(result); }
+-++
+-++            var engine = new TestSelectionEngine(_mockLogger.Object, new[] { _mockScoringAlgorithm.Object });
+-++            
+-++            // Configure mock to factor in reliability
+-++            _mockScoringAlgorithm.Setup(x => x.CalculateScoreAsync(It.IsAny<TestInfo>(), It.IsAny<TestScoringContext>(), It.IsAny<CancellationToken>()))
+-++                .Returns<TestInfo, TestScoringContext, CancellationToken>((test, context, ct) =>
+-++                {
+-++                    if (test.TestMethod.GetDisplayName().Contains("Reliable"))
+-++                        return Task.FromResult(0.9); // High score for reliable tests
+-++                    if (test.TestMethod.GetDisplayName().Contains("Flakey"))
+-++                        return Task.FromResult(0.4); // Lower score for flakey tests
+-++                    return Task.FromResult(0.7); // Medium score for new tests
+-++                });
+-++
+-++            var scoredTests = await engine.ScoreTestsAsync(tests);
+-++
+-++            scoredTests.Should().HaveCount(3);
+-++            scoredTests[0].TestMethod.GetDisplayName().Should().Contain("ReliableTest");
+-++            scoredTests[1].TestMethod.GetDisplayName().Should().Contain("NewTest");
+-++            scoredTests[2].TestMethod.GetDisplayName().Should().Contain("FlakeyTest");
+-++        }
+-++
+-++        [Fact]
+-++        public async Task ScoreTestsAsync_WithLargeTestSuite_ShouldHandlePerformantly()
+-++        {
+-++            // Create a large number of tests to verify performance
+-++            var tests = Enumerable.Range(1, 1000)
+-++                .Select(i => CreateTestInfo($"Test_{i:D4}", 
+-++                    (TestCategory)(i % 4), // Distribute across categories
+-++                    TimeSpan.FromMilliseconds(50 + (i % 200)), // Vary execution times
+-++                    0.0))
+-++                .ToArray();
+-++
+-++            var engine = new TestSelectionEngine(_mockLogger.Object, new[] { _mockScoringAlgorithm.Object });
+-++            
+-++            _mockScoringAlgorithm.Setup(x => x.CalculateScoreAsync(It.IsAny<TestInfo>(), It.IsAny<TestScoringContext>(), It.IsAny<CancellationToken>()))
+-++                .Returns<TestInfo, TestScoringContext, CancellationToken>((test, context, ct) =>
+-++                {
+-++                    // Simulate varying scoring based on test name hash
+-++                    var hash = test.TestMethod.GetDisplayName().GetHashCode();
+-++                    var score = (Math.Abs(hash) % 100) / 100.0; // Score between 0.0 and 1.0
+-++                    return Task.FromResult(score);
+-++                });
+-++
+-++            var stopwatch = System.Diagnostics.Stopwatch.StartNew();
+-++            var scoredTests = await engine.ScoreTestsAsync(tests);
+-++            stopwatch.Stop();
+-++
+-++            scoredTests.Should().HaveCount(1000);
+-++            scoredTests.Should().BeInDescendingOrder(t => t.SelectionScore);
+-++            
+-++            // Performance assertion - should complete within reasonable time
+-++            stopwatch.ElapsedMilliseconds.Should().BeLessThan(5000, "scoring 1000 tests should complete within 5 seconds");
+-++            
+-++            // Verify all tests have been scored
+-++            scoredTests.All(t => t.SelectionScore > 0).Should().BeTrue();
+-++        }
+-++
+-++        [Theory]
+-++        [InlineData(ConfidenceLevel.Fast)]
+-++        [InlineData(ConfidenceLevel.Medium)]
+-++        [InlineData(ConfidenceLevel.High)]
+-++        [InlineData(ConfidenceLevel.Full)]
+-++        public async Task ScoreTestsAsync_WithDifferentConfidenceLevels_ShouldAdjustScoring(ConfidenceLevel confidence)
+-++        {
+-++            var tests = new[]
+-++            {
+-++                CreateTestInfo("UnitTest", TestCategory.Unit, TimeSpan.FromMilliseconds(50)),
+-++                CreateTestInfo("IntegrationTest", TestCategory.Integration, TimeSpan.FromSeconds(1)),
+-++                CreateTestInfo("E2ETest", TestCategory.UI, TimeSpan.FromSeconds(10))
+-++            };
+-++
+-++            var changes = CreateCodeChangeSet();
+-++            var engine = new TestSelectionEngine(_mockLogger.Object, new[] { _mockScoringAlgorithm.Object });
+-++            
+-++            // Configure scoring based on confidence level
+-++            _mockScoringAlgorithm.Setup(x => x.CalculateScoreAsync(It.IsAny<TestInfo>(), It.IsAny<TestScoringContext>(), It.IsAny<CancellationToken>()))
+-++                .Returns<TestInfo, TestScoringContext, CancellationToken>((test, context, ct) =>
+-++                {
+-++                    var baseScore = test.Category switch
+-++                    {
+-++                        TestCategory.Unit => 0.8,
+-++                        TestCategory.Integration => 0.6,
+-++                        TestCategory.UI => 0.4,
+-++                        _ => 0.2
+-++                    };
+-++
+-++                    // Boost score based on confidence level
+-++                    var confidenceMultiplier = context.ConfidenceLevel switch
+-++                    {
+-++                        ConfidenceLevel.Fast => test.Category == TestCategory.Unit ? 1.2 : 0.8,
+-++                        ConfidenceLevel.Medium => test.Category <= TestCategory.Integration ? 1.1 : 0.9,
+-++                        ConfidenceLevel.High => 1.0,
+-++                        ConfidenceLevel.Full => 1.0,
+-++                        _ => 1.0
+-++                    };
+-++
+-++                    return Task.FromResult(baseScore * confidenceMultiplier);
+-++                });
+-++
+-++            var scoredTests = await engine.ScoreTestsAsync(tests, changes);
+-++
+-++            scoredTests.Should().HaveCount(3);
+-++            scoredTests.Should().BeInDescendingOrder(t => t.SelectionScore);
+-++            
+-++            // Verify confidence-specific behavior
+-++            switch (confidence)
+-++            {
+-++                case ConfidenceLevel.Fast:
+-++                    // Should prioritize unit tests
+-++                    scoredTests[0].Category.Should().Be(TestCategory.Unit);
+-++                    break;
+-++                case ConfidenceLevel.Medium:
+-++                    // Should include unit and integration tests with good scores
+-++                    scoredTests.Take(2).All(t => t.Category <= TestCategory.Integration).Should().BeTrue();
+-++                    break;
+-++                case ConfidenceLevel.High:
+-++                case ConfidenceLevel.Full:
+-++                    // Should include all test types
+-++                    scoredTests.Should().Contain(t => t.Category == TestCategory.UI);
+-++                    break;
+-++            }
+-++        }
+-++
+-++        #endregion
+-+     }
+-+ }
+-+\ No newline at end of file
+ diff --git a/src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs b/src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
+-index 410eadf..dc9ed54 100644
++index 8c033b7..964cd0f 100644
+ --- a/src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
+ +++ b/src/TestIntelligence.Core/Discovery/NUnitTestDiscovery.cs
+-@@ -247,4 +247,4 @@ namespace TestIntelligence.Core.Discovery
++@@ -250,4 +250,4 @@ namespace TestIntelligence.Core.Discovery
+              DiscoveryError?.Invoke(this, new TestDiscoveryErrorEventArgs(assemblyPath, exception));
+          }
+      }
+ -}
+ \ No newline at end of file
+-+}// Test change for coverage analysis
+-diff --git a/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs b/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs
+-index d7f075c..7b686cd 100644
+---- a/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs
+-+++ b/src/TestIntelligence.ImpactAnalyzer/Services/TestCoverageAnalyzer.cs
+-@@ -723,4 +723,4 @@ namespace TestIntelligence.ImpactAnalyzer.Services
+-             return false;
+-         }
+++}// Test change for coverage analysis - Wed Sep  3 18:33:07 CDT 2025
++diff --git a/src/TestIntelligence.DataTracker/TestDataDependencyTracker.cs b/src/TestIntelligence.DataTracker/TestDataDependencyTracker.cs
++index 9d88644..c47e3ac 100644
++--- a/src/TestIntelligence.DataTracker/TestDataDependencyTracker.cs
+++++ b/src/TestIntelligence.DataTracker/TestDataDependencyTracker.cs
++@@ -413,4 +413,4 @@ namespace TestIntelligence.DataTracker
++         public int TotalTestPairs => CanRunInParallel.Count + MustRunSequentially.Count;
++         public double ParallelExecutionRatio => TotalTestPairs > 0 ? (double)CanRunInParallel.Count / TotalTestPairs : 0;
+      }
+ -}
+ \ No newline at end of file
+-+}// Test change for coverage analysis
+++}// Test change for coverage analysis - Wed Sep  3 18:33:13 CDT 2025
diff --git a/tests/TestIntelligence.API.Tests/Controllers/TestSelectionControllerTests.cs b/tests/TestIntelligence.API.Tests/Controllers/TestSelectionControllerTests.cs
index 5fa10db..71bb704 100644
--- a/tests/TestIntelligence.API.Tests/Controllers/TestSelectionControllerTests.cs
+++ b/tests/TestIntelligence.API.Tests/Controllers/TestSelectionControllerTests.cs
@@ -90,7 +90,7 @@ public class TestSelectionControllerTests
             "High confidence plan");
 
         _mockSelectionEngine
-            .GetOptimalTestPlanAsync(codeChanges, ConfidenceLevel.High, Arg.Any<CancellationToken>())
+            .GetOptimalTestPlanAsync(codeChanges, ConfidenceLevel.High, Arg.Any<TestSelectionOptions>(), Arg.Any<CancellationToken>())
             .Returns(expectedPlan);
 
         // Act
@@ -100,6 +100,7 @@ public class TestSelectionControllerTests
         await _mockSelectionEngine.Received(1).GetOptimalTestPlanAsync(
             codeChanges, 
             ConfidenceLevel.High, 
+            Arg.Any<TestSelectionOptions>(),
             Arg.Any<CancellationToken>());
     }
 
@@ -137,7 +138,7 @@ public class TestSelectionControllerTests
             .Returns(Task.FromResult(impactResult));
 
         _mockSelectionEngine
-            .GetOptimalTestPlanAsync(impactResult.CodeChanges, request.ConfidenceLevel, Arg.Any<CancellationToken>())
+            .GetOptimalTestPlanAsync(impactResult.CodeChanges, request.ConfidenceLevel, Arg.Any<TestSelectionOptions>(), Arg.Any<CancellationToken>())
             .Returns(testPlan);
 
         // Act
